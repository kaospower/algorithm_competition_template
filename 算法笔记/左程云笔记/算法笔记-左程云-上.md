# 1.gpt4$\checkmark$

# 2.社会实验$\checkmark$

# 3.二进制和位运算$\checkmark$

## 有符号正数转负数:

对应的二进制数-1再取反:如7为0111,-7则为1001,如8为1000,-8为1000

## 有符号负数转正数:

对应的二进制数取反再+1:如-7为1001,7为0111,如-8为1000,8为1000

## n位有符号二进制数:

范围是$-2^{n-1}....-1,0,1...2^{n-1}-1$

## 二进制相反数:

取反+1

## 或与异或

|,&,^

## 位运算

对于非负数,左移i位等于乘$2^i$,右移i位等于除以$2^i$

# 4.选择，冒泡和插入排序$\checkmark$

选择排序:i~n-1范围上,找到最小值并放在i位置,然后i+1~n-1范围上继续

冒泡排序:0~i范围上,相邻位置较大的数滚下去,最大值最终来到i位置,然后0~i-1位置上继续

插入排序:0~i范围上已经有序,新来的数从右到左滑到不再小的位置插入,然后继续

冒泡排序针对较为有序的数组,比较次数远大于插入排序

```python
#选择排序
def selectionSort(a):
    for i in range(len(a)-1):
        minIndex=i
        for j in range(i+1,len(a)):
        	if a[j]<a[minIndex]:
            	minIndex=j
        a[i],a[minIndex]=a[minIndex],a[i]
```

```python
#冒泡排序
def bubbleSort(a):
    for i in range(len(a)-1,0,-1):
        for j in range(i):
            if a[j]>a[j+1]:
                a[j],a[j+1]=a[j+1],a[j]
```

```python
#插入排序
def insertionSort(a):
    for i in range(1,len(a)):
        j=i-1
        while j>=0 and a[j]>a[j+1]:
            a[j],a[j+1]=a[j+1],a[j]
        	j-=1
```

# 5.对数器入门$\checkmark$



# 6.二分搜索$\checkmark$





```python
def find(arr,num):
    l=0
    r=len(arr)-1
    while l<=r:
        m=(l+r)//2
        if arr[m]==num:
            return true
        elif arr[m]>num:
            r=m-1
        else:
            l=m+1
    return false
```



```python
#有序数组中找>=num的最左位置
def findLeft(arr,num):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        #m=l+(r-l)/2
        #m=l+((r-l)>>1)
        m=(l+r)//2
        if arr[m]>=num:
            ans=m
            r=m-1
        else:
            l=m+1
    return ans
```

```python
#有序数组找<=num的最右位置
def findRight(arr,num):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        m=(l+r)//2
        if arr[m]<=num:
            ans=m
            l=m+1
        else:
            r=m-1
    return ans
```

# 7.时间复杂度和空间复杂度$\checkmark$

```python
for i in range(N):
    for j in range(i,N,i):
时间复杂度:O(nlogn),调和级数
```

# 8.算法和数据结构$\checkmark$

```python
硬计算类算法:精确求解
软计算类算法:神经网络,SVM等

连续结构
跳转结构
```

# 9.单链表及其反转-堆栈解释$\checkmark$

```python
按值传递
按引用传递:新拷贝变量,指向同一个内存中的值
```

# 10.合并两个有序链表$\checkmark$

# 11.两个有序链表相加$\checkmark$

# 12.划分链表$\checkmark$

# 13.队列和栈，链表数组实现$\checkmark$

# 14.队列和栈相互实现$\checkmark$

# 15.最小栈$\checkmark$

# 16.双端队列，双链表和固定数组实现$\checkmark$

# 17.二叉树三种序递归实现$\checkmark$

# 18.二叉树遍历非递归实现$\checkmark$

```python
均使用栈
先序:先压右，再压左
中序:有子树就把左边界全部压入,后面重复
后序:采用哨兵标记
```

# 19.笔试输入输出$\checkmark$

# 20.递归和master公式$\checkmark$

```python
master公式只能解决规模相同的子问题
```

$T(n)=aT(n/b)+O(n^c)$

1.$log_ba>c \rightarrow O(N^{log_ba})$

2.$log_ba<c \rightarrow O(N^c)$

3.$log_ba=c \rightarrow O(N^c*logN)$

$T(n)=2*T(n/2)+O(n*logn),时间复杂度是O(n*(logn)^2)$

# 21.归并排序$\checkmark$

```python
#归并排序
def mergeSort1(l,r):
    if l==r:
        return
    m=(l+r)//2
    mergeSort1(l,m)
    mergeSort1(m+1,r)
    merge(l,m,r)
def merge(l,m,r):
    i=l
    a=l
    b=m+1
    while a<=m and b<=r:
        if arr[a]<=arr[b]:
            h[i]=arr[a]
            a+=1
            i+=1
        else:
            h[i]=arr[b]
            b+=1
            i+=1
    while a<=m:
        h[i]=arr[a]
        a+=1
        i+=1
    while b<=r:
        h[i]=arr[b]
        b+=1
        i+=1
    for i in range(l,r+1):
        arr[i]=h[i]
#非递归
def mergeSort2():
    step=1
    while step<n:
        l=0
        while l<n:
            m=l+step-1
            if m+1>=n:#右部分开头
                break
            r=min(l+(step<<1)-1,n-1)
            merge(l,m,r)
            l=r+1
        step<<=1
```

# 22.归并分治$\checkmark$

```python
1.思考一个问题在大范围上的答案,是否等于,左部分的答案+右部分的答案+跨越左右产生的答案
2.计算"跨越左右产生的答案"时,如果加上左,右各自有序这个设定,会不会获得计算的便利性
```

# 23.随机快速排序$\checkmark$

```python
def quickSort(l,r):
    if l>=r:
        return
    x=arr[random.randint(l,r)]
    left,right=partition(l,r,x)
    quickSort(l,left-1)
    quickSort(right+1,r)
def partition(l,r,x):
    first=l
    last=r
    i=l
    while i<=last:
        if arr[i]==x:
            i+=1
        elif arr[i]<x:
            arr[i],arr[first]=arr[first],arr[i]
            i+=1
            first+=1
        else:
            arr[i],arr[last]=arr[last],arr[i]
            last-=1
    return first,last
```

# 24.随机选择算法$\checkmark$

# 25.堆结构和堆排序$\checkmark$

```python
完全二叉树和数组前缀范围来对应
i的父亲节点:(i-1)/2
i的孩子节点:左:i*2+1,右:i*2+2

增倍分析法
```

```python
def heapSort(arr):
    n=len(arr)
    for i in range(n):
        heapInsert(arr,i)
    size=n
    while size>1:
        size-=1
        arr[size],arr[0]=arr[0],arr[size]
        heapify(arr,0,size)
def heapInsert(arr,i):
    while arr[i]>arr[(i-1)//2] and i>=1:
        arr[i],arr[(i-1)//2]=arr[(i-1)//2],arr[i]
        i=(i-1)//2
def heapify(arr,i,size):
    l=i*2+1
    while l<size:
        best=l+1 if l+1<size and arr[l+1]>arr[l] else l
        best=best if arr[best]>arr[i] else i
        if best==i:
            break
        arr[best],arr[i]=arr[i],arr[best]
        i=best
        l=i*2+1
```

# 26.哈希表，有序表和比较器的用法$\checkmark$

# 27.堆结构常见题$\checkmark$

```python
#合并k个有序链表
#重合线段
```

# 28.基数排序$\checkmark$

```python
不基于比较的排序
```

```python
BASE=10
MAXN=50001
def sortArray(arr):
    n=len(arr)
    if n>1:
        minValue=min(arr)
        maxValue=0
        for i in range(n):
            arr[i]=arr[i]-minValue
            maxValue=max(maxValue,arr[i])
        radixSort(arr,n,bits(maxValue))
        for i in range(n):
            arr[i]+=minValue
    return arr
def bits(number):
    ans=0
    while number>0:
        ans+=1
        number//=BASE
    return ans
def radixSort(arr,n,bits):
    h=[0]*MAXN
    c=[0]*BASE
    offset=1
    while bits>0:
        c=[0]*BASE
        for i in range(n):
            c[(arr[i]//offset)%BASE]+=1
        for i in range(1,BASE):
            c[i]+=c[i-1]
        for i in range(n-1,-1,-1):
            h[c[(arr[i]//offset)%BASE]-1]=arr[i]
            c[(arr[i]//offset)%BASE]-=1
        for i in range(n):
            arr[i]=h[i]  
        bits-=1
        offset*=BASE

```

# 29.重要排序算法的总结$\checkmark$

```python
选择:不稳定
冒泡:稳定
插入:稳定
归并:稳定
快排:不稳定
堆排序:不稳定
计数排序:稳定
基数排序:稳定
```

# 30.异或运算的骚操作$\checkmark$

```python
1.交换两个数:a=a^b,b=a^b,a=a^b(a,b内存地址需要不同)
2.不用比较操作返回最大值
3.找到缺失的数字
4.找唯一出现奇数次的数
5.找唯二出现奇数次的数 
#Brian kernighan算法
提取最右侧的1:x&(-x)
6.找唯一的出现次数少于m次
```

# 31.位运算的骚操作$\checkmark$

```python
1.判断一个整数是不是2的幂
2.判断一个整数是不是3的幂
3.返回大于等于n的最小的2的幂
4.区间[left,right]内所有数字&的结果
5.逆序二进制的状态
6.二进制中有几个1
```

# 32.位图$\checkmark$

```python
a/b向上取整:(a+b-1)/b
位图只能保存连续范围数字

```



```mysql
别提醒：Python的同学实现位运算的题目需要特别注意，需要自己去手动处理溢出和符号扩展等问题
比如：(n << shift_amount) & 0xFFFFFFFF

位图原理
其实就是用bit组成的数组来存放值，用bit状态1、0代表存在、不存在，取值和存值操作都用位运算
限制是必须为连续范围且不能过大。好处是极大的节省空间，因为1个数字只占用1个bit的空间。

位图的实现
Bitset(int n)：初始化位图的大小，只支持0~n-1所有数字的增删改查
void add(int num)：把num加入到位图
void remove(int num)：把num从位图中删除
void reverse(int num)：如果位图里没有num，就加入；如果位图里有num，就删除
boolean contains(int num)：查询num是否在位图中
```



````python
#手写位图,对数器验证(对拍)
class Bitset:
    def __init__(self,n):
        self.set=[0]*((n+31)//32)
    def add(self,num):#增
        self.set[num//32]|=1<<(num%32)
    def remove(self,num):#删
        self.set[num//32]&=~(1<<(num%32))
    def reverse(self,num):#反转,有的改成没有,没有的改成有
        self.set[num//32]^=1<<(num%32)
    def contains(self,num):#查看是否包含某个元素
        return ((self.set[num//32]>>(num%32))&1)==1
````



````python
#对数器
from random import random
n=1000
testTimes=10000
print("测试开始")
bitSet=Bitset(n)
hashSet=set()
print("调用阶段开始")
for i in range(testTimes):
    decide=random()
    number=int(random()*n)
    if decide<0.333:
        bitSet.add(number)
        hashSet.add(number)
    elif decide<0.666:
        bitSet.remove(number)
        if number in hashSet:
            hashSet.remove(number)
    else:
        bitSet.reverse(number)
        if number in hashSet:
            hashSet.remove(number)
        else:
            hashSet.add(number)
print("调用阶段结束")
print("验证阶段开始")
for i in range(n):
    if bitSet.contains(i)!=(i in hashSet):
        print("出错了")
print("验证阶段结束")
print("测试结束")
````



``````mysql
1.设计位集(2166M)
``````



# 33.位运算实现加减乘除$\checkmark$

```mysql
异或:无进位相加
进位信息:与运算然后左移
所以原始相加=(异或,与运算然后左移)循环,直到进位信息变0
```



````
a-b=a+(-b)
-b=~b+1
````



# 34.链表高频题目和必备技巧$\checkmark$

```python
快慢指针求中点
```

```java
class Solution {
    public static ListNode sortList(ListNode head) {
		int n = 0;
		ListNode cur = head;
		while (cur != null) {
			n++;
			cur = cur.next;
		}
		// l1...r1 每组的左部分
		// l2...r2 每组的右部分
		// next 下一组的开头
		// lastTeamEnd 上一组的结尾
		ListNode l1, r1, l2, r2, next, lastTeamEnd;
		for (int step = 1; step < n; step <<= 1) {
			// 第一组很特殊，因为要决定整个链表的头，所以单独处理
			l1 = head;
			r1 = findEnd(l1, step);
			l2 = r1.next;
			r2 = findEnd(l2, step);
			next = r2.next;
			r1.next = null;
			r2.next = null;
			merge(l1, r1, l2, r2);
			head = start;
			lastTeamEnd = end;
			while (next != null) {
				l1 = next;
				r1 = findEnd(l1, step);
				l2 = r1.next;
				if (l2 == null) {
					lastTeamEnd.next = l1;
					break;
				}
				r2 = findEnd(l2, step);
				next = r2.next;
				r1.next = null;
				r2.next = null;
				merge(l1, r1, l2, r2);
				lastTeamEnd.next = start;
				lastTeamEnd = end;
			}
		}
		return head;
	}

	// 包括s在内，往下数k个节点返回
	// 如果不够，返回最后一个数到的非空节点
	public static ListNode findEnd(ListNode s, int k) {
		while (s.next != null && --k != 0) {
			s = s.next;
		}
		return s;
	}

	public static ListNode start;

	public static ListNode end;

	// l1...r1 -> null : 有序的左部分
	// l2...r2 -> null : 有序的右部分
	// 整体merge在一起，保证有序
	// 并且把全局变量start设置为整体的头，全局变量end设置为整体的尾
	public static void merge(ListNode l1, ListNode r1, ListNode l2, ListNode r2) {
		ListNode pre;
		if (l1.val <= l2.val) {
			start = l1;
			pre = l1;
			l1 = l1.next;
		} else {
			start = l2;
			pre = l2;
			l2 = l2.next;
		}
		while (l1 != null && l2 != null) {
			if (l1.val <= l2.val) {
				pre.next = l1;
				pre = l1;
				l1 = l1.next;
			} else {
				pre.next = l2;
				pre = l2;
				l2 = l2.next;
			}
		}
		if (l1 != null) {
			pre.next = l1;
			end = r1;
		} else {
			pre.next = l2;
			end = r2;
		}
	}
}
```

# 35.数据结构设计高频题$\checkmark$

```python
1.setAll功能的哈希表:哈希表外加三个标记变量
2.LRU:双向链表加哈希表
3.O(1) 时间插入、删除和获取随机元素:动态数组加哈希表
4.插删随O(1)的结构加强版:动态数组加哈希表，哈希表value为set
5.快速获得数据流的中位数结构:大根堆加小根堆
6.最大频率栈:两个哈希表，第一个哈希表value为数组
7.全O(1)的数据结构:双向链表加哈希表
```

# 36.二叉树高频题目-上$\checkmark$

```mysql
满二叉树:每一层节点都是满的,数量满足2的n次方
完全二叉树:除了最后一层外,所有层都被完全填满,并且最后一层中的所有节点都尽可能靠左。最后一层(第h层)中可以包含1到2h个节点。
满二叉树节点个数:2的h次方-1,h为树高

1.二叉树的层序遍历(102M)
2.二叉树的锯齿形层序遍历(103M)
3.二叉树的最大宽度(662M)
4.二叉树的最大深度(104E)
5.二叉树的最小深度(111E)
6.二叉树的序列化和反序列化(297H)
7.从先序与中序遍历序列构造二叉树(105M)
8.二叉树的完全性检验(958M)
9.完全二叉树的节点个数(222E)
```

# 37.二叉树高频题目-下$\checkmark$

```
1.二叉树的最近公共祖先(236M)
2.二叉搜索树的最近公共祖先(235M)
3.路径总和II(113M)
4.平衡二叉树(110E)
5.验证二叉搜索树(98M)
6.修剪二叉搜索树(669M)
7.打家劫舍III(337M)
```

# 38常见经典递归过程解析

```mysql
1.子集II(90M)
2.全排列(46M)
3.全排列II(47M)
```



# 39.嵌套类问题的递归解题套路$\checkmark$

```mysql
嵌套类问题的解题套路
大概过程: 
定义全局变量 int where
递归函数f(i) : s[i..]，从i位置出发开始解析，遇到 字符串终止 或 嵌套条件终止 就返回
返回值是f(i)负责这一段的结果
f(i)在返回前更新全局变量where，让上级函数通过where知道解析到了什么位置，进而继续

执行细节:
如果f(i)遇到 嵌套条件开始，就调用下级递归去处理嵌套，下级会负责嵌套部分的计算结果
f(i)下级处理完成后，f(i)可以根据下级更新的全局变量where，知道该从什么位置继续解析
```



```mysql
1.基本计算器III(772H)
2.字符串解码(394M)
3.原子的质量(726H)
```



# 40.N皇后问题-重点是位运算的版本$\checkmark$

```mysql
1.N皇后问题II(52H)
```



```python
#位运算+递归
class Solution:
    def totalNQueens(self, n: int) -> int:
        #低n位全部填充1w
        limit=(1<<n)-1
        return self.f(limit,0,0,0)
    #limit表示是几皇后问题,col,left,right分别代表列以及两条对角线的影响
    def f(self,limit,col,left,right):
        #列的影响==limit,说明放完了
        if col==limit:
            return 1
        #总限制
        ban=col|left|right
        #~ban:1可以放皇后,0不可以放皇后,与上limit将高位1全部消掉
        #同时之前列的影响取反后变0,也被消掉
        #剩下的1表示有效的位置
        candidate=limit&(~ban)
        #放置皇后的尝试
        place=0
        ans=0
        while candidate!=0:
            #提取candidate最右侧的1(Brian kenighan算法)
            place=candidate&(-candidate)
            #将col,left,right的状态更新,代表哪些位置不能放皇后,然后调递归
            ans+=self.f(limit,col|place,(left|place)>>1,(right|place)<<1)

            #消掉提取到的1(作用类似for循环中的i++,i--)
            candidate^=place
        return ans
```



```mysql
#递归
#n皇后问题数组实现版本(速度较慢,不推荐)
class Solution:
    def totalNQueens(self, n: int) -> int:
        return self.f(0,[0]*n,n)
    #0...i-1行已经摆完了,i...n-1行可以去尝试的情况下还能找到几种有效的方法
    def f(self,i,path,n):
        if i==n:
            return 1
        ans=0
        for j in range(n):
            #判断位置是否冲突
            if self.check(path,i,j):
                path[i]=j
                ans+=self.f(i+1,path,n)
        return ans
    #当前在i行,j列的位置,摆了一个皇后
    #0...i-1行的皇后状况存储在path[0...i-1]
    #返回会不会冲突,不会冲突,有效返回True,否则返回False
    def check(self,path,i,j):
        for k in range(i):
            #列相同或者在同一条对角线,冲突,返回False
            if j==path[k] or abs(i-k)==abs(j-path[k]):
                return False
        return True
```



# 41.最大公约数,同余原理$\checkmark$

```python
求最大公约数:辗转相除法(欧几里得算法)
  def gcd(a,b):#最大公约数
      return a if b==0 else gcd(b,a%b)
  def lcm(a,b):#最小公倍数
      return a/gcd(a,b)*b
同余原理:(a+b)%m=(a%m+b%m)%m (a-b)%m=(a%m-b%m+m)%m
1.第N个神奇数字(878H)
```



# 42.对数器打表找规律的技巧$\checkmark$

```python
1.用袋子买苹果问题
2.AB轮流吃草的赢家问题
3.是否为连续正整数的和
3.red好串数量问题
```

# 43.根据数据量猜解法-天字第一号重要技巧$\checkmark$

```mysql
一个基本事实:
C/C++运行时间1s,java/python/go等其他语言运行时间1s~2s,对应的常数指令操作量是10^7~10^8,不管什么测试平台,不管什么CPU,都是这个数量级,所以可以根据这个基本事实,来猜测自己设计的算法最终有没有可能在规定时间内通过。
1.回文数(9E)
2.超级回文数(906H)
```

# 44.前缀树原理和代码详解$\checkmark$

```mysql
前缀树(字典树):trie
每个样本都从头节点开始,根据前缀字符后者前缀数字建出来的一棵大树,就是前缀树
没有路就新建节点,已经有路了,就复用节点
前缀树的使用场景:需要根据前缀信息来查询的场景
前缀树的优点:根据前缀信息选择树上的分支,可以节省大量的时间
前缀树的缺点:比较浪费空间,和总字符数量有关,字符的种类有关
前缀树的定制:pass,end等信息

```

```mysql
1.实现Trie(前缀树)II(1804M)
2.实现Trie(前缀树)(208M)
```



# 45.前缀树的相关题目

```mysql
1.
2.数组中两个数异或的最大值(421M)(此题不建议用前缀树,用哈希表解决较好)
3.单词搜索(212H)
```



# 46.构建前缀信息的技巧-解决子数组求和问题$\checkmark$

```mysql
1.区域和检索-数组不可变(303E)
2.和为k的子数组(560M)
3.表现良好的最长时间段(1124M)
4.使数组和能被P整除(1590M)
5.每个原因包含偶数次的最长子字符串(1371M)
```



# 47.一维差分与等差数列差分

```python
一维差分:
对于差分数组:L位置+v，R+1位置-v,然后计算前缀和
不支持边操作边查询
差分数组初始化成长度和原数组一样长的全0数组

等差数列差分:
arr[l]+=s,arr[l+1]+=d-s,arr[r+1]-=d+e,arr[r+2]+=e
其中d是公差,s是首项,e是末项
然后计算两遍前缀和

1.航班预订统计(1109M)
```

# 48.二维前缀和,二维差分,离散化技巧

```mysql
二维前缀和:
目的是预处理出一个结构,以后每次查询二维数组任何范围上的累加和都是O(1)的操作
1.根据原始状况,生成二维前缀和数组sum,
sum[i][j]:代表左上角(0,0)到右下角(i,j)这个范围的累加和
sum[i][j]+=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]
2.查询左上角(a,b)到右下角(c,d)这个范围的累加和
sum[c][d]-sum[c][b-1]-sum[a-1][d]+sum[a-1][b-1]
3.实际过程中往往补第0行,第0列来减少很多条件判断
当然也可以不补。根据个人习惯决定。

二维差分:
对于左上角(a,b),右下角(c,d)的区域
diff[a][b]+=v
diff[c+1][b]-=v
diff[a][d+1]-=v
diff[c+1][d+1]+=v
最后加工一遍二维前缀和
实际处理时真实数据用一圈0包裹起来,可以减少很多边界讨论

离散化技巧:放大地图
X左=X*2-r,X右=X*2+r
```

```mysql
1.二维区域和检索-矩阵不可变(304M)
2.最大的以1为边界的正方形(1139M)
3.用邮票贴满网格图(2132H)
4.最强祝福力场(LCP74M)
```



# 49.滑动窗口技巧与相关题目$\checkmark$

```python
思路:
    1.维持左,右边界都不回退的一段范围，来求解很多子数组(串)相关问题
    2.找到范围和答案指标之间的单调性关系(类似贪心)
    3.滑动窗口可以用简单变量或者结构来维护信息
    4.求子数组在每个位置开头或结尾情况下的答案
1.累加和>=k的最短子数组
2.无重复字符的最长子串
3.最小覆盖子串
4.加油站的良好出发点
5.替换子串得到平衡字符串
6.k个不同整数的子数组
7.至少k个重复字符的最长子串
```

# 50.双指针技巧与相关题目$\checkmark$

```mysql
1.按奇偶排序数组II(922E)
2.寻找重复数(287M)
3.环形链表(142M)
4.接雨水(42H)
5.救生艇(881M)
6.盛水最多的容器(11M)
7.供暖器(475M)
8.缺失的第一个正数(41H)
```