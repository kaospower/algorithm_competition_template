# 51.二分答案法

```python
方法:
    1.估计最终答案可能的范围是什么
    2.分析问题的答案和给定条件之间的单调性，大部分时候只需要用到自然智慧
    3.建立一个f函数，当答案固定的情况下，判断给定的条件是否达标
    4.在最终答案可能的范围上不断二分搜索，每次用f函数判断，直到二分结束，找到最合适的答案
1.爱吃香蕉的珂珂
2.画匠问题
3.
4.找出第k小的距离
5.同时运行n台电脑的时间
6.
7.
```

# 52.单调栈-上$\checkmark$

```mysql
单调栈最经典的用法
每个位置都求:  

#大压小单调栈
#当栈顶元素大于当前遍历的元素时,弹出,弹出的元素压着的元素就是它左侧最近最小,遍历到的元素就是它右侧最近最小
当前位置的左侧比当前位置的数字小，且距离最近的位置在哪  
当前位置的的右侧比当前为位置的数字小，且距离最近的位置在哪  
或者  

#小压大单调栈
当前位置的左侧比当前位置的数字大，且距离最近的位置在哪  
当前位置的右侧比当前位置的数字大，且距离最近的位置在哪

1.每日温度(739M)
2.子数组的最小值之和(907M)
3.柱状图中最大的矩形(84H)
4.最大矩形(85H)
```

# 53.单调栈-下$\checkmark$

```mysql
单调栈还可以维持求解答案的可能性
单调栈里的所有对象按照规定好的单调性来组织
当某个对象进入单调栈时,会从栈顶开始依次淘汰单调栈里对后续求解答案没有帮助的对象
每个对象从栈顶弹出时结算当前对象参与的答案,随后这个对象不再参与后续求解答案的过程
其实是先有对题目的分析,进而发现单调性,然后利用单调栈的特征去实现

1.最大宽度坡（962M）
2.去除重复字母(316M)
3.使数组按非递减顺序排列(2289M)
4.统计全1子矩形(1504M)
```

# 54.单调队列-上

```mysql
单掉队列用来维护滑动窗口的最大或最小值
1.滑动窗口最大值(239H)
2.绝对差不超过限制的最长连续子数组(1438M)
3.
```

# 55.单调队列-下

```mysql
单调队列还可以维持求解答案的可能性:
单调队列里的所有对象按照规定好的单调性来组织
当某个对象从队尾进入单调队列时,会从队头或者队尾依次淘汰单调队列里,对后续求解答案没有帮助的对象
每个对象一旦从单调队列弹出,可以结算此时这个对象参与的答案
随后这个对象不再参与后续求解答案的过程
先对题目的分析,进而发现单调性,然后利用单调队列的特征去实现
1.和至少为K的最短子数组(862H)
2.满足不等式的最大值(1499H)
3.你可以安排的最多任务数吗(2071H)
```



# 56.并查集上$\checkmark$

```mysql
并查集的使用是如下的场景:
一开始每个元素都拥有自己的集合,在自己的集合里只有这个元素自己  
find(i):查找i所在集合的代表元素,代表元素来代表i所在的集合  
isSameSet(a,b):判断a和b在不在一个集合里 
void union(a,b):a所在集合所有元素与b所在集合所有元素合并成一个集合  
各种操作单次调用的均摊时间复杂度为O(1)  
实际操作时省略isSameSet(),直接将逻辑写到union()中,避免重复操作
```



```python
#并查集,扁平化,省略小挂大
class UnionFind:
    def __init__(self,n):
        self.n=n
        self.father = [i for i in range(self.n)]
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
    def union(self,x,y):
        fx=self.find(x)
        fy=self.find(y)
        if fx!=fy:
            self.father[fx]=fy
```



```mysql
1.情侣牵手(765H)
2.相似字符串组(839H)
```

# 57 并查集下$\checkmark$

```mysql
1.移除最多的同行或同列的石头(947M)
2.好路径的数目(2421H)
3.尽量减少恶意软件的传播(928H)
```



# 58.洪水填充$\checkmark$

```mysql
洪水填充是一种很简单的技巧,设置路径信息进行剪枝和统计,类似感染的过程
路径信息不撤销,来保证每一片的感染过程可以得到区分
```

```mysql
1.岛屿数量(200M)
2.被围绕的区域(130M)
3.最大人工岛屿(827H)
4.打砖块(803H)(使用了时光倒流技巧)
```

# 59.建图,链式前向星,拓扑排序$\checkmark$

```mysql
有向图
邻接矩阵(时间,空间复杂度较高,不常用)
邻接表(更常用)
无向图:(等价于双向有向图)

链式前向星

拓扑排序:每个节点的前置节点都在这个节点之前
要求:有向图,没有环

1.课程表II(210M)
2.火星词典(269H)
3.戳印序列(936H)
```

# 60.拓扑排序的扩展技巧$\checkmark$

```mysql
上游节点给下游节点推消息
1.喧闹和富有（851M）
2.并行课程III(2050H)
3.参加会议的最多员工数（2127H）
```

# 61.最小生成树

```mysql
在无向带权图中选择一些边,在保证联通性的情况下,边的总权值最小
最小生成树可能不止一棵,只要保证边的总权值最小,就都是正确的最小生成树
如果无向带权图有n个点,那么最小生成树一定有n-1条边
```



```mysql
Kruskal算法(最常用)
1.把所有的边,根据权值从小到大排序,从权值小的边开始考虑
2.如果连接当前的边不会形成环，就选择当前的边
3.如果连接当前的边会形成环,就不要当前的边
4.考察完所有边之后,最小生成树也就得到了
```



```mysql
Prim算法(不常用)
1.解锁的点的集合叫set(普通集合),解锁的边的集合叫heap(小根堆)。set和heap都为空。
2.可从任意点开始,开始点加入到set,开始点的所有边加入到heap
3.从heap中弹出权值最小的边e,查看边e所去往的点x
	A.如果x已经在set中,边e舍弃,重复步骤3
	B.如果x不在set中,边e属于最小生成树,把x加入set,重复步骤3
4.当heap为空,最小生成树也就得到了
```



```mysql
1.水资源分配优化(1168H)
2.检查边长度限制的路径是否存在(1697H)
3.
```



# 62.宽度优先遍历及其扩展$\checkmark$

```mysql
单源，多源宽度优先遍历
01bfs,宽度优先遍历与双端队列结合
宽度优先遍历与优先队列结合
宽度优先遍历与深度优先遍历结合，去生成路径

bfs特点是逐层扩散，从源头点到目标点扩散了几层，最短路径就是多少
bfs可以使用的特征是：任意两个节点之间的相互距离相同（无向图）
bfs开始时，可以是单个源头，也可以是多个源头
bfs频繁使用队列，形式可以是单点弹出或者整层弹出
bfs进行时，进入队列的节点需要标记状态，防止同一个节点重复进出队列
bfs进行时，可能会包含剪枝策略的设计
bfs是一个理解难度很低的算法，难点在于节点如何找到路，路的展开和剪枝设计

```



```mysql
01bfs,适用于图中所有边的权重只有0和1两种值,求源点到目标点的最短距离,时间复杂度为O(节点数量+边的数量)

过程:  
1.distance[i]表示从源点到i点的最短距离,初始时所有点的distance设置为无穷大
2.源点进入双端队列,distance[源点]=0
3.双端队列头部弹出x
	A如果x是目标点,返回distance[x]表示源点到目标点的最短距离
	B考察从x出发的每一条边,假设某边去y点,边权为w
		1)如果distance[y]>distance[x]+w,处理改变;否则忽略该边 
		2)处理时,更新distance[y]=distance[x]+w
			如果w==0,y从头部进入双端队列。继续重复步骤3
			如果w==1,y从尾部进入双端队列。继续重复步骤3
4.双端队列为空停止
```





```mysql
1.地图分析(1162M)
2.贴纸拼词(691H)
3.到达角落需要移除障碍物的最小数目(2290H)
4.使网格图至少有一条有效路径的代价(1368H)
5.接雨水II(407H)
6.单词接龙(126H)
```

# 63.双向广搜

```mysql
双向广搜常见用途1:小优化
bfs的剪枝策略,分两侧展开分支,哪侧数量少就从哪侧展开
双向广搜常见用途2:(重要)用于解决特征很明显的一类问题
特征:全量样本不允许递归完全展开,但是半量样本可以完全展开
过程:把数据分成两部分,每部分各自展开计算结果,然后设计两部分结果的整合逻辑

1.单词接龙(127H)
2.最接近目标值的子序列(1755H)
```

# 64.Dijkstra算法,分层最短路

```mysql
Dijkstra算法:给定一个源点,求解从源点到每个点的最短路径长度。单源最短路径算法。
使用范围:有向图,边的权值没有负数

普通堆实现的Dijkstra算法,时间复杂度O(m*logn),m为边数,n为点数
1.distance[i]表示从源点到i点的最短距离,visited[i]表示i节点是否从小根堆弹出过
2.准备好小根堆,小根堆存放记录:(x点,源点到x的距离),小根堆根据距离组织
3.令distance[源点]=0,(源点,0)进入小根堆
4.从小根堆弹出(u点,源点到u的距离)
	a.如果visited[u]==True,不做任何处理,重复步骤4
	b.如果visited[u]==False,令visited[u]=True,u就算弹出过了
	然后考察u的每一条边,假设某边去往v,边权为w
	1)如果visited[v]==False 并且 distance[u]+w<distance[v]
	  令distance[v]=distance[u]+w,把(v,distance[u]+w)加入小根堆
    2)处理完u的每一条边之后,重复步骤4
5.小根堆为空过程结束,distance表记录了源点到每个节点的最短距离
```



```mysql
反向索引堆实现的Dijkstra算法,时间复杂度O(m*logn),n为节点数,m为边数

1.准备好反向索引堆,根据源点到当前点的距离组织小根堆,可以做到如下操作
	a.新增记录(X,源点到x的距离)
	b.当源点到x的距离更新时,可以进行堆的调整
	c.x点一旦弹出,以后忽略x
	d.弹出堆顶的记录(u,源点到u的距离)
2.把(源点,0)加入反向索引堆,过程开始
3.反向索引堆弹出(u,源点到u的距离),考察u的每一条边,假设某边去往v,边权为w
	1)如果v没有进入过反向索引堆里,新增记录(v,源点到u的距离+w)
	2)如果v曾经从反向索引堆弹出过,忽略
	3)如果v在反向索引堆里,看看源点到v的距离能不能变得更小,如果能,调整堆;不能,忽略
	4)处理完u的每一条边,重复步骤3
4.反向索引堆为空过程结束。反向索引堆里记录了源点到每个节点的最短距离。
```



```mysql
分层图最短路(扩点最短路)
不把实际位置看做图上的点,而是把实际位置及其状态的组合看做是图上的点,然后搜索bfs或者Dijkstra的过程不变，
只是扩了点(分层)而已
```



```mysql
1.网络延迟时间(743M)
2.最小体力消耗路径(1631M)
3.水位上升的泳池中游泳(778H)
4.获取所有钥匙的最短路径(864H)
5.电动车游城市(LCP35H)
6.
```

# 65.A星、Floyd、Bellman-Ford与SPFA

```mysql
Bellman-Ford算法，解决可以有负权边但是不能有负环（保证最短路存在）的图，单源最短路算法
适用于小图

松弛操作
假设源点为A，从A到任意点F的最短距离为distance[F]
假设从点P出发某条边，去往点S，边权为W
如果发现，distance[P] + W < distance[S]，也就是通过该边可以让distance[S]变小
那么就说，P出发的这条边对点S进行了松弛操作

Bellman-Ford过程
1，每一轮考察每条边，每条边都尝试进行松弛操作，那么若干点的distance会变小
2，当某一轮发现不再有松弛操作出现时，算法停止

```



````
Bellman-Ford算法时间复杂度
假设点的数量为N，边的数量为M，每一轮时间复杂度O(M)
最短路存在的情况下，因为1次松弛操作会使1个点的最短路的边数+1
而从源点出发到任何点的最短路最多走过全部的n个点，所以松弛的轮数必然 <= n - 1
所以Bellman-Ford算法时间复杂度O(M*N)

重要推广：判断从某个点出发能不能到达负环
上面已经说了，如果从A出发存在最短路（没有负环），那么松弛的轮数必然 <= n - 1
而如果从A点出发到达一个负环，那么松弛操作显然会无休止地进行下去
所以，如果发现从A点出发，在第n轮时松弛操作依然存在，说明从A点出发能够到达一个负环
````



```mysql
Bellman-Ford一般结合SPFA优化使用
```



```mysql
1.K站中转内最便宜的航班(787M)
```



# 66.从递归入手一维动态规划$\checkmark$

```mysql
动态规划:用空间代替重复计算
有些递归在展开计算时,总是重复调用同一个子问题的解,这种重复调用的递归变成动态规划很有收益
如果每次展开都是不同的解,或者重复调用的现象很少,那么没有改动态规划的必要
任何动态规划问题都一定对应着一个有重复调用行为的递归
任何动态规划的题目都一定可以从递归入手,逐渐实现动态规划的方法
自顶向下带缓存表:记忆化搜索  
自底向上使用递推数组:动态规划  
```

```mysql
动态规划的大致过程：
想出设计优良的递归尝试(方法、经验、固定套路很多)，有关尝试展开顺序的说明
-> 记忆化搜索(从顶到底的动态规划) ，如果每个状态的计算枚举代价很低，往往到这里就可以了
-> 严格位置依赖的动态规划(从底到顶的动态规划) ，更多是为了下面说的 进一步优化枚举做的准备
-> 进一步优化空间（空间压缩），一维、二维、多维动态规划都存在这种优化
-> 进一步优化枚举也就是优化时间（本节没有涉及，但是后续巨多内容和这有关）

解决一个问题，可能有很多尝试方法
众多的尝试方法中，可能若干的尝试方法有重复调用的情况，可以转化成动态规划
若干个可以转化成动态规划的方法中，又可能有优劣之分
判定哪个是最优的动态规划方法，依据来自题目具体参数的数据量
最优的动态规划方法实现后，后续又有一整套的优化技巧
```



```mysql
1.斐波那契数(509E)
2.最低票价(983M)
3.解码方法(91M)
4.解码方法II(639H)
5.丑数II(264M)
6.最长有效括号(32H)
7.环绕字符串中唯一的子字符串(467M)
8.不同的子序列II(940H)
```

# 67.从递归入手二维动态规划

```mysql
动态规划分析过程  
尝试函数有1个可变参数可以完全决定返回值，进而可以改出1维动态规划表的实现  
同理  
尝试函数有2个可变参数可以完全决定返回值，那么就可以改出2维动态规划的实现  
    

一维、二维、三维甚至多维动态规划问题，大体过程都是：  
写出尝试递归
记忆化搜索(从顶到底的动态规划)  
严格位置依赖的动态规划(从底到顶的动态规划)  
空间、时间的更多优化
```



```mysql
动态规划表的大小：  
每个可变参数的可能性数量相乘  
动态规划方法的时间复杂度：动态规划表的大小 * 每个格子的枚举代价  


二维动态规划依然需要去整理 动态规划表的格子之间的依赖关系  
找寻依赖关系，往往 通过画图来建立空间感，使其更显而易见  
然后依然是 从简单格子填写到复杂格子 的过程，即严格位置依赖的动态规划(从底到顶)  


二维动态规划的压缩空间技巧原理不难，会了之后千篇一律  
但是不同题目依赖关系不一样，需要 很细心的画图来整理具体题目的依赖关系  
最后进行空间压缩的实现  

```



```mysql
能改成动态规划的递归，统一特征：
决定返回值的可变参数类型往往都比较简单，一般不会比int类型更复杂。

从这个角度，可以解释 带路径的递归（可变参数类型复杂），不适合或者说没有必要改成动态规划

一定要 写出可变参数类型简单（不比int类型更复杂），并且 可以完全决定返回值的递归，
保证做到 这些可变参数可以完全代表之前决策过程对后续过程的影响！再去改动态规划！


不管几维动态规划
经常从递归的定义出发，避免后续进行很多边界讨论
这需要一定的经验来预知

```



```mysql
1.最小路径和(64M)
2.单词搜索(79M)(不能用动态规划)
3.最长公共子序列(1143M)
4.最长回文子序列(516M)
5.
6.矩阵中的最长递增路径(329H)
```



# 68.见识更多二维动态规划题目

```mysql
1.不同的子序列(115H)
2.编辑距离(72M)
3.交错字符串(97M)
4.
5.
```

# 69.从递归入手三维动态规划$\checkmark$

```mysql
1.一和零(474M)(多维费用背包)
2.盈利计划(879H)
3.骑士落在棋盘上的概率(688M)
4.矩阵中和能被k整除的路径(2435H)
5.扰乱字符串(87H)
```



# 70.子数组最大累加和问题与扩展$\checkmark$

```python
1.最大子数组和(53M)
2.打家劫舍(198M)
3.环形子数组的最大和(918M)
4.打家劫舍II(213M)
5.打家劫舍IV(2560M)
6.最大子矩阵(面试题17.24H)
```

# 71.子数组最大累加和问题与扩展下

```mysql
1.乘积最大子数组(152M)
2.
3.
4.三个无重叠子数组的最大和(689H)
5.
6.
```

# 72.最长递增子序列问题与扩展

```mysql
1.最长递增子序列(300M)
2.俄罗斯套娃信封问题(354H)
3.使数组k递增的最少操作次数(2111H)
4.最长对数链(646M)
5.
***.最长递增子序列的个数(673M)(实际为树状数组题目)
```



# 73.背包dp,01背包,有依赖背包

```mysql
#01背包模版

#dp[i][j]:1...i物品自由选择,容量不超过j的情况下的最大价值
#体积cost[i],价值val[i]
#二维dp
def compute(n,t,cost,val):
    dp=[[0]*(t+1) for _ in range(n+1)]
    for i in range(1,n+1):
        for j in range(t+1):
            #不要i号物品
            dp[i][j]=dp[i-1][j]
            if j-cost[i]>=0:
                dp[i][j]=max(dp[i][j],dp[i-1][j-cost[i]]+val[i])
    return dp[n][t]
```



```mysql
#空间压缩
def compute(n,t,cost,val):
    dp=[0]*(t+1)
    for i in range(1,n+1):
        j=t
        while j>=cost[i]:
            dp[j]=max(dp[j],dp[j-cost[i]]+val[i])
            j-=1
    return dp[t]
```



```mysql
1.采药(P1048)
2.夏季特惠(bytedance-006E)
3.目标和(494M)
4.最后一块石头的重量II(1049M)
5.
6.
```



# 74.分组背包，完全背包

```mysql
#分组背包
dp[i][j]:[1~j]组上,每组只能选一件商品,(注意:i代表组,不是商品),容量不超过j的情况下,最大价值
1)不要i组商品,dp[i-1][j]
2)要i组商品,要哪一件,全试
	a)dp[i-1][j-a体积]+a价值
	b)dp[i-1][j-b体积]+b价值
	c)dp[i-1][j-c体积]+c价值
	所有分支求max
	......
```



```mysql
#完全背包
dp[i][j]:1...i号商品,每种商品可以无限拿,容量不超过j,最大价值
1)dp[i-1][j]
2)dp[i][j-i号商品的体积]+i号商品的价值 #拿了i物品之后i物品还是可以拿
```

```mysql
1.通天之分组背包(P1757)
2.从栈中取出k个硬币的最大面值和(2218H)
3.疯狂的采药(P1616)
4.正则表达式匹配(10H)
5.通配符匹配(44H)
6.
```

# 75.多重背包,混合背包

```mysql
```



# 76.区间dp-上$\checkmark$

```mysql
1.让字符串成为回文串的最少插入次数(1312H)
2.预测赢家(486M)
3.多边形三角剖分多最低得分(1039M)
4.切棍子的最小成本(1547H)
5.戳气球(312H)
6.布尔运算(面试题08.14M)
```

# 77.区间dp-下

```mysql
1.
2.奇怪的打印机(664H)
3.
4.移除盒子(546H)
5.合并石头的最低成本(1000H)
6.统计不同回文子序列(730H)
```

# 78.树型dp-上

```mysql
1.最大二叉搜索子树(333M)
2.二叉搜索子树的最大键值和(1373H)
3.二叉树的直径(543E)
4.在二叉树中分配硬币(979M)
5.打家劫舍III(337M)
6.监控二叉树(968H)
7.路径总和(437M)
```

# 79.树型dp-下

```mysql
dfn序
用深度优先遍历的方式遍历整棵树
给每个节点依次标记序号
编号从小到大的顺序就是dfn序

dfn序 + 每颗子树的大小，可以起到定位子树节点的作用
如果某个节点的dfn序号是x，以这个节点为头的子树大小为y
那么可知，dfn序号从x ~ x+y-1所代表的节点，都属于这个节点的子树
利用这个性质
```

```mysql
1.到达首都的最少油耗(2477M)
2.相邻字符不同的最长路径(2246H)
3.移除子树后的二叉树高度(2458M)
4.从树中删除边的最小分数(2322H)
5.
```

# 80.状压dp-上

```mysql
设计一个整型可变参数status，利用status的位信息，来表示：
某个样本是否还能使用，然后利用这个信息进行尝试
写出尝试的递归函数 -> 记忆化搜索 -> 严格位置依赖的动态规划 -> 空间压缩等优化

如果有k个样本，那么表示这些样本的状态，数量是2^k
所以可变参数status的范围： 0 ~ (2^k)-1

样本每增加一个，状态的数量是指数级增长的，所以状压dp能解决的问题往往样本数据量都不大
一般样本数量在20个以内(10^6)，如果超过这个数量，计算量(指令条数)会超过 10^7 ~ 10^8
```



```mysql
1.我能赢吗(464M)
2.火柴拼正方形(473M)
3.划分为k个相等的子集(698M)
```

# 81.状压dp-下$\checkmark$

```mysql
j=(j-1)&status操作来枚举二进制状态的子集
```



```mysql
1.每个人戴不同帽子的方案数(1434H)
2.最优账单平衡(465H)
3.好子集的数目(1994H)
4.分配重复整数(1655H)
```

# 82.动态规划中用观察优化枚举的技巧-上$\checkmark$

```mysql
1.买卖股票的最佳时机(121E)
2.买卖股票的最佳时机II(122M)
3.买卖股票的最佳时机III(123H)
4.买卖股票的最佳时机IV(188H)
5.买卖股票的最佳时机含手续费(714M)
6.买卖股票的最佳时机含冷冻期(309M)
7.DI序列的有效排列(903H)
```

# 83.动态规划中用观察优化枚举的技巧-下

```mysql
1.k个逆序对数组(629H)
2.规划兼职工作(1235H)
3.自由之路(514H)
```

# 84.数位dp上$\checkmark$

```mysql
1.统计各位数字都不同的数字个数(357M)
2.最大为N的数字组合(902H)
3.统计整数数目(2719H)
4.统计特殊整数(2376H)
5.至少有1位重复的数字(1012H)
```

# 85.数位dp下

```mysql
1.
2.
3.不含连续1的个数(600H)
4.范围内的数字计数(1067H)
5.数字1的个数(233H)
```

# 86.动态规划中得到具体决策方案的技巧

```mysql
1.
2.最少的必要团队(1125H)
3.
4.
```

# 87.动态规划中根据数据量猜解法的技巧

```mysql
1.
2.
3.
4.使数组严格递增(1187H)
```

# 88.动态规划专题总结

```mysql
设计的可变参数类型简单,不比int类型更复杂的递归,可以变成动态规划
重叠子结构
最优子问题
无后效性
```



# 89.贪心经典题目专题1

```mysql
狭义的贪心
每一步都做出在当前状态下最好或最优的选择，从而希望最终的结果是最好或最优的算法

广义的贪心
通过分析题目自身的特点和性质，只要发现让求解答案的过程得到加速的结论，都算广义的贪心

贪心是最符合自然智慧的思想，一般分析门槛不高
理解基本的排序、有序结构，有基本的逻辑思维就能理解
但是贪心的题目，千题千面，极难把握
难度在于证明局部最优可以得到全局最优，好在！我们有对数器！
```



```mysql
有关贪心的若干现实 & 提醒
1，不要去纠结严格证明，每个题都去追求严格证明，浪费时间、收益很低，而且千题千面。玄学！
2，一定要掌握用对数器验证的技巧，这是解决贪心问题的关键
3，解法几乎只包含贪心思路的题目，代码量都不大
4，大量累积贪心的经验，重点不是证明，而是题目的特征，以及贪心方式的特征，做好总结方便借鉴
5，关注题目数据量，题目的解可能来自贪心，也很可能不是，如果数据量允许，能不用贪心就不用（稳）
6，贪心在笔试中出现概率不低，但是面试中出现概率较低，原因是 淘汰率 vs 区分度
7，广义的贪心无所不在，可能和别的思路结合，一般都可以通过自然智慧想明白，依然不纠结证明
```



```mysql
1.最大数(179M)
2.两地调度(1029M)
3.吃掉N个橘子的最少天数(1553H)
4.会议室II(253M)
5.课程表III(630H)
6.连接的最低费用(1167M)
```

# 90.贪心经典题目专题2

```mysql
1.砍竹子(LCR132M)
2.最多可以参加的会议数目(1353M)
3.IPO(502H)
```

# 91.贪心经典题目专题3

```mysql
1.最短无序连续子数组(581M)
2.最小区间(632H)
```

#  92.贪心经典题目专题4

```mysql
1.数据的最小偏移量(1675H)
2.森林中的兔子(781M)
3.使数组相似的最少操作次数(2449H)
4.
5.将数组分成几个递增序列(1121H)
6.最低加油次数(871H)
```



# 93.贪心经典题目专题5

```mysql
1.跳跃游戏(55M)
2.跳跃游戏II(45M)(自己补充的)
3.灌溉花园的最少水龙头数目(1326H)
4.字符串转化(1153H)
5.
6.超级洗衣机(517H)
```



# 94.贪心经典题目专题6

```mysql
1.消灭怪物的最大数量(1921M)
2.最大回文数字(2384M)
3.最大平均通过率(1792M)
4.雇佣k名工人的最低成本(857H)
5.
```



