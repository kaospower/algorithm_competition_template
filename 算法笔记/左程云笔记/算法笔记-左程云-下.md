# 97.质数判断,质因子分解,质数筛

```mysql
1.埃氏筛
从i*i的开始设置合数,分别将它的1...n倍标记成合数
2.欧拉筛
每个合数只被自己的最小的质因子筛一遍

```



```mysql
1.按公因数计算最大组件大小(952H)
2.计数质数(204M)
```

# 98.快速幂,矩阵快速幂与两类问题

````
斐波那契数列是1维2阶问题
如F(n)=F(n-1)+F(n-2),固定递推表达式

矩阵乘法、矩阵快速幂，题目2、3、4、5、6、7
固定关系的1维k阶递推表达式，用矩阵快速幂求解时间复杂度O(logn * k的3次方)，题目2、3、4、5
固定关系的k维1阶递推表达式，用矩阵快速幂求解时间复杂度O(logn * k的3次方)，题目6、7

1维k阶问题:
每一个位置都只有一个答案要求,依赖于i-1,i-2,i-3,...等
k维1阶问题:
每一个i位置都有k个答案要求,然后每个答案都只依赖于i+1位置的k个答案
````



```mysql
乘法快速幂:
求a^b,把b拆成二进制形式,比如求10^75,将75拆成1001011,然后计算10^1*10^2*10^8*10^64

如果a是固定位数，并且结果要求取模，那么任何中间结果也都是固定位数
那么求a的n次方取模后的结果，使用乘法快速幂可以做到时间复杂度O(logn)
```



```mysql
对于类似斐波那契数列的一维k阶表达式
矩阵第一列是递推式的系数,后面的系数带入前几项可以求出来
斐波那契数列的关系矩阵[[1,1],[1,0]]
```



```mysql
1.快速幂(P1226)
2.斐波那契数数(509E)
3.爬楼梯(70E)
4.第N个泰波那契数(1137E)
5.多米诺和托米诺平铺(790M)
6.统计元音字母序列的数目(1220H)
7.学生出勤记录II(552H)
```

# 99 .逆元和除法同余,容斥原理

```mysql
如果你想计算：a / b，然后 % MOD结果
1) 必须保证a/b可以整除，每次有除法的时候，都需要保证绝对能整除
2) 必须保证MOD是质数，求逆元的原理是费马小定理，要求MOD是质数，比如1000000007
3) 必须保证b和MOD的最大公约数为1，也就是b和MOD互质

题目给定的数据一定会满足上面三点，那么就有如下的结论，直接记住，证明略，不用多问为什么
先求 1/b 的乘法同余数，也就是b的逆元，b的逆元 = b的(MOD-2)次方 % MOD
然后，(a / b) % MOD的结果，等于，((a % MOD) * (b的逆元)) % MOD的结果

比如，(10 / 5) % 3，先求5的1次方 % 3 = 2，((10 % 3) * 2) % 3，结果得到2，这是正确的


你可以假设各种例子，a、b、MOD，但要保证 : a/b能整除、MOD是质数、b和MOD互质
```



```mysql
连续数字逆元的线性递推
在 % p意义下，
1、2、3 . . . n，求每个数的逆元
用inv[i]，代表i的逆元
inv[1] = 1
inv[i] = (int) (p - (long) inv[p % i] * (p / i) % p); // 从左往右线性递推

连续阶乘逆元的线性递推
在 % p意义下，
1!、2!、3! . . . n!，求每个数的逆元，
用inv[i]，代表i!的逆元
先求n!乘法同余的结果，假设为a，然后求a的逆元，假设为b
inv[n] = b
inv[i] = ((long) (i + 1) * inv[i + 1]) % MOD; // 从右往左线性递推
```



```mysql
1.播放列表的数量(920H)
```



# 100.KMP算法原理和代码详解

```mysql
KMP解决的问题:s1字符串是否包含s2字符串,如果包含返回s1中包含s2的最左开头位置,不包含返回-1
暴力方法就是s1的每个位置都做开头,然后去匹配s2整体,时间复杂度O(n*m)
KMP算法可以做到时间复杂度O(n+m)

next数组的定义:前缀和后缀的最大匹配长度
next数组对s2求
next[i]表示,不包含当前位置i,0...i-1串前缀和后缀的最大匹配长度(不能包含整体)

next加速过程:
当s1和s2在某个位置i处不匹配时,查询next[i]=w,将s2[w]和s1[i]对齐,然后从i位置继续向后匹配
```



```python
#kmp算法模版
def kmp(self,s1,s2):
        n,m=len(s1),len(s2)
        next=self.nextArray(s2,m)
        x=y=0
        while x<n and y<m:
            if s1[x]==s2[y]:
                x+=1
                y+=1
            elif y==0:
                x+=1
            else:
                y=next[y]
        return x-y if y==m else -1
    def nextArray(self,s,m):
        if m==1:
            return [-1]
        next=[0]*m
        next[0]=-1
        next[1]=0
        i,cn=2,0
        while i<m:
            if s[i-1]==s[cn]:
                cn+=1
                next[i]=cn
                i+=1
            elif cn>0:
                cn=next[cn]
            else:
                next[i]=0
                i+=1
        return next
```



```mysql
1.找出字符串中第一个匹配项的下标(28E)
2.另一棵树的子树(572E)
```

# 101 KMP算法相关题目

```mysql
1.二叉树中的链表(1367M)
2.找到所有好字符串(1397H)
3.
4.
```

# 102 AC自动机原理,优化,代码详解

```mysql
自动机又叫确定有限状态自动机
常见的自动机:
前缀树,KMP自动机(KMP算法),回文自动机(Manacher算法),后缀自动机(SAM),AC自动机
```



```mysql
AC自动机的功能
给你若干目标字符串，还有一篇文章，返回每个目标字符串在文章中出现了几次

AC自动机就是加上了fail指针的前缀树，经典的AC自动机，课上图解一下
```



```mysql
fail指针含义：
AC自动机上的某个节点a，表示某个目标串的前缀串s的终止节点
所有目标字符串的前缀串，要求和s的某个后缀串完全一样，并且要求长度最大，并且不能是s的整体
满足这三点的前缀串假设为t，那么节点a的fail指针就指向t的终止节点
```



# 103 Manacher算法,扩展KMP

```mysql
为了方便处理,在原字符直接加上'#'这种虚字符,称为Manacher扩展串
Manacher扩展串，可以方便的寻找奇长度、偶长度的回文，扩展字符可以随意设置，不会影响计算
回文半径,中心字符+回文字符的串长度
回文半径和真实回文长度的对应，真实长度 = p[i] - 1
扩展回文串结尾下标和真实回文串终止位置的对应，真实回文串终止位置 = 扩展回文串结尾下标 / 2

理解回文半径数组p、理解回文覆盖最右边界r、理解回文中心c
p,回文串的一半长度(包含中心)
r,回文串恰好到不了的位置
c,回文串的中心点
```



```mysql
Manacher算法的加速过程，当来到的中心点i，如何利用p、r、c来进行回文扩展，课上详细图解
   a，i没有被r包住，那么以i为中心直接扩展
   b，i被r包住，对称点 2*c-i 的回文半径，在大回文区域以内，直接确定p[i] = p[2*c-i](p[x]:x下标回文半径)
   c，i被r包住，对称点 2*c-i 的回文半径，在大回文区域以外，直接确定p[i] = r - i
   d，i被r包住，对称点 2*c-i 的回文半径，撞线大回文区域的边界，从r之外的位置进行扩展
Manacher算法的时间复杂度分析，时间复杂度O(n)
顺口溜:没包扩,小于包,大于截,等于扩
```



```python
#manacher算法模版
def manacher(s):
    n=len(s)<<1|1
    p=[0]*n#p是回文半径数组
    ss='#'+'#'.join(s)+'#'#ss是Manacher扩展串
    maxv=0
    #i代表遍历的字符位置,c代表回文中心,r代表回文覆盖右边界
    c=r=0
    for i in range(n):
        #至少的回文半径长度
        lens=min(p[2*c-i],r-i) if r>i else 1
        while i+lens<n and i-lens>=0 and ss[i+lens]==ss[i-lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        maxv=max(maxv,lens)
        p[i]=lens
    return maxv-1
```



```mysql
扩展KMP,z数组
z数组:z[i]表示s从i下标开始的后缀串与s的最长公共前缀长度
z[0]固定等于s长度

1，理解z数组、理解匹配右边界r、理解匹配中心c，课上会图解
2，理解扩展KMP的过程，当来到的出发点i，如何利用z、r、c来进扩展过程的加速，课上详细图解
   a，i没有被r包住，那么以i为出发点直接扩展
   b，i被r包住，但是前点 i-c 的扩展长度，对应在大扩展区域以内，直接确定z[i] = z[i-c]
   c，i被r包住，但是前点 i-c 的扩展长度，对应在大扩展区域以外，直接确定z[i] = r - i
   d，i被r包住，但是前点 i-c 的扩展长度，对应在大扩展区域的边界，从r之外的位置进行扩展
3，理解了Manacher算法，可以轻易理解生成z数组的时间复杂度O(n)
顺口溜:没包扩,小于包,大于截,等于扩
```



```mysql
扩展KMP,e数组
e数组:e[i]表示,对于两个字符串A,B,A从下标i出发和B从下标0出发最大匹配长度
求解e数组要用到z数组
```



```python
def zArray(s,n):
    z[0]=n
    c=r=1
    for i in range(1,n):
        lens=min(r-i,z[i-c]) if r>i else 0
        while i+lens<n and s[i+lens]==s[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        z[i]=lens
```



```python
def eArray(a,b,n,m):
    c=r=0
    for i in range(n):
        lens=min(r-i,z[i-c]) if r>i else 0
        while i+lens<n and lens<m and a[i+lens]==b[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        e[i]=lens    
```



```mysql
1. 将单词恢复初始状态所需的最短时间II(3031H)
```



# 104 Manacher算法相关题目

```mysql
1.最长回文子串(5M)
2.回文子串数量(647M)
3.不重叠回文子字符串的最大数目(2472H)
4.
5.
```

# 105 字符串哈希原理,代码,题目详解

```mysql
哈希函数的用处
把复杂样本变成数字，以后复杂样本之间的对比，就变成了数字之间的对比

哈希函数的基本性质
1）输入参数的可能性是无限的，输出的值范围相对有限
2）输入同样的样本一定得到同样的输出值，也就是哈希函数没有任何随机机制
3）输入不同的样本也可能得到同样的输出值，此时叫哈希碰撞
4）输入大量不同的样本，得到的大量输出值，会几乎均匀的分布在整个输出域上，课上重点图解

哈希函数的种类很多，但都符合上述性质
性质4是最重要的，哈希碰撞理论上无法避免，但是好的哈希函数会让碰撞几率变的很低

可以把性质4直观理解为：
不管有没有规律，也不管多么相似，总之一堆不同的输入，得到的输出结果从分布上看，熵最大！
```



`````
哈希函数的算法有很多，字符串哈希是其中最常用的，也是唯一需要掌握代码实现的哈希函数

字符串哈希：如何得到整个字符串的哈希值
1）理解long类型自然溢出，计算加、减、乘时，自然溢出后的状态等同于对2的64次方取模的值状态
2）字符串转化成base进制的数字并让其自然溢出
3）base可以选择一些质数比如：433、499、599、1000000007
   也可以选择已经被证实了很好用的值：31、131、1313、13131、131313等
  建议选择质数，不要选经典值，因为会被出题人刻意构造碰撞
4）转化时让每一位的值从1开始，不从0开始，这样就得到了一个long类型的数字代表字符串
5）利用数字的比较去替代字符串的比较，可以大大减少复杂度

字符串哈希从理论上说会有碰撞导致出错，但现实中的算法考察样本量太少了，出错概率非常低
`````



````mysql
字符串哈希：如何快速得到字符串中任意子串的哈希值
1）选择一个质数做进制数，base
2）得到base的各种次方，在自然溢出下的结果，用pow数组记录
3）得到每个位置的hash[i]，hash[i] = hash[i-1] * base + s[i] - 'a' + 1
4）子串s[l...r]的哈希值 = hash[r] - hash[l-1] * base的(r-l+1)次方，课上会重点讲解


字符串中子串对比变成哈希值对比非常好用的！大量节省时间

很多较难的算法都可以被字符串哈希替代，都是因为子串对比的代价变为O(1)

字符串哈希易于理解且使用灵活，因为非常方便的子串对比，很多难题变得非常好想

````



````mysql
1.每个数字的频率都相同的独特子字符串的数量(2168M)
2.找出字符串中第一个匹配项的下标(28E)
3.重复叠加字符串匹配(686M)
4.串联所有单词的子串(30H)
5.
````



# 108.树状数组原理，扩展，代码详解

```mysql
树状数组维护信息的类型
树状数组一般用来维护可差分的信息
比如：累加和、累乘积、或者出题人发现了某个可差分信息来出题考你

不可差分的信息，比如：最大值、最小值、除此之外的很多信息
不可差分的信息一般不用树状数组维护，会选择用线段树维护，因为线段树维护的方式思考难度更低
树状数组维护不可差分信息的内容不再讲述，后续会详细讲解线段树

大多数情况下，线段树可以替代树状数组，两者的时间复杂度差不多，单次调用都是O(log n)
线段树的优势：用法全面、思考难度低、维护信息类型多（包括可差分信息、不可差分信息）
线段树的劣势：代码较多、使用空间较大、常数时间稍差
树状数组优势：代码量少、使用空间少、常数时间优异
树状数组劣势：维护信息的类型少、维护某些不可差分的信息时思考难度大并且不易实现
```



```mysql
数组数组下标i位置所管的范围:
先将i拆成二进制,然后去掉最右侧的1,再加1,得到的数为x,范围就是x到i
```



```mysql
计算累加和:
1到15累加和=sum[15]+sum[14]+sum[12]+sum[8]
利用二进制跳转实现
```



```mysql
1.用法1
2.用法2
3.二维区域和检索-矩阵可修改(308M)
```

# 109.树状数组相关题目

```mysql
1.交易逆序对的总数(LCR170H)
2.
3.最长递增子序列的个数(673M)
5.得到回文串的最少操作次数(2193H)
```

# 110.线段树专题1-线段树原理和代码详解

```
线段树维护的信息类型
父范围上的某个信息，可以用O(1)的时间，从子范围的信息加工得到
满足的信息比如：累加和、最大值、最小值；不满足的信息比如：某范围上出现次数最多的数

线段树的经典功能，如下操作单次调用的时间复杂度为O(log n)
1，范围查询，包括范围内累加和、最大值、最小值等等信息
2，范围修改，包括范围内每个数都增加、重置等等操作

线段树的范围修改功能，想做到单次调用时间复杂度为O(log n)的要求：
一段范围上统一进行了某种修改操作，可以用O(1)的时间，就把这段范围维护的信息加工出来
满足的情况，比如：这段范围所有数字都加v，累加和可以快速的加工出来
不满足的情况，比如：这段范围上每个数字都逆序，累加和不能快速的加工出来

```



```mysql
1.线段树1(P3372)
```

# 111.线段树专题2-线段树的离散化、二分搜索、特别修改

```mysql
1.掉落的方块(699H)
```

# 114.线段树专题5-开点线段树、区间最值和历史最值

```mysql
开点线段树
可以支持很大的范围，一开始不为每个范围都分配空间
当真的需要开辟左侧、右侧的空间时，再临时申请
父范围的空间编号i，利用cnt自增给左右两侧申请的空间，记录在left[i]和right[i]里
除此之外和线段树再无区别

开点线段树适用的范围：需要支持的范围很大，但实际操作数量并不大
```

开点线段树适用的范围:需要支持的范围很大,但实际操作数量并不大

开点线段树可以支持很大的范围,一开始不为每个范围都分配空间

left,right,sum,add四个信息



```mysql
1.传教(P2781)
2.统计区间中的整数数目(2276H)
```



# 115.线段树专题6-线段树与扫描线结合的题目

```mysql
扫描线是一种设计
与堆结合,还有延迟删除
```



```mysql
扫描线
根据实际出现的边界来处理，边界从小到大依次扫描过去
扫描到每个边界时，把该边界造成的影响维护好
扫描的期间求解想要的答案

如果边界造成的影响比较简单，那么用简单结构维护
题目1、题目2 : 扫描线 + 堆 + 延迟删除
```



```mysql
1.包含每个查询的最小区间(1851H)
2.天际线问题(218H)
3.矩形面积并
```

```mysql
```





# 116.摩尔投票

```mysql
水王数:出现次数 >n//2 的数
有水王数:一次删掉两个不同的数,那么最终水王数会剩下来
无水王数:一次删掉两个不同的数,最终剩下的数不一定是水王数,但如果剩下来的数不是水王数,说明水王数根本不存在

初始血量为0,候选为无
1)如果无候选,当前的数成为候选,血量=1
2)如果有候选
	a)当前数!=候选,血量-1
	b)当前数==候选,血量+1
	
摩尔投票只关心比较结果
```



```mysql
摩尔投票可以解决投票智力题
摩尔投票可以多线程并发执行
```

```mysql
1.多数元素(169E)
2.合法分割的最小下标(2780M)
3.多数元素II(229M)
4.子数组中占绝大多数的元素(1157H)#需要用到线段树合并,待解
```

# 117 倍增算法和ST表

```python
#寻找最大的<=x的2的幂是多少(防溢出写法)
while (1<<power) <=(x>>1):
    power++
```



```mysql
线段上有n个点，给定每个点i往右边跳1步能最远覆盖的点jump[i]
已知从任意点出发都能到达最后的点，并且在i < j时，必有jump[i] <= jump[j]
1）如何构建一张表
可以查询从任意点出发：跳1步、跳2步、跳4步、跳8步..每回最远能到达的点
也就是可以查询，从任意点i出发，任意跳(2的p次方)步，最远能到达的点
2）如何快速计算任意的两点之间，最少跳几步能到达？

构建出的表叫做ST表(Sparse Table)(稀疏表)
构建方式：st[i][p] = st[st[i][p-1]][p-1]，p代表：跳2的p次方步，表大小为n * logn
利用ST表，从x到y跳跃的过程中，先从最大步长开始，每次步长减少一半去尝试，最终得到答案
时间复杂度O(log n)
```

# 118 树上问题专题1-树上倍增和LCA-上

```mysql
树
每个节点只有一个头节点的图结构，就叫做树
如果所有节点形成一棵树，那么节点数为n，那么边的数量为n-1，也可能整体是森林结构
树上问题所指的树，包括一叉树、二叉树、多叉树

树上倍增
1）建立每个节点的深度表，deep数组
2）建立每个节点往上跳1步、跳2步、跳4步、跳8步..能到达的节点编号，ST表
3）给定任意节点i，可以快速查询，从i节点往上走的路径中位于第s层的节点编号

生成deep数组时间复杂度O(n)
生成ST表时间复杂度O(n * logn)
单次查询时间复杂度O(log n)
```



```mysql
LCA问题
给定树上的任意两点a和b，如何快速查询出a和b的最低公共祖先，常见的有三个方法
1）树上倍增
2）tarjan算法+并查集
3）树链剖分，后续的课会讲述！

算法过程：
1）先让a和b往上跳到同一层
2）利用倍增算法找到a和b的最低公共祖先


如果节点数为n，建立预处理结构的时间复杂度O(n*logn)，单次查询的时间复杂度O(log n)

优势是可以在线查询，如果一共m条查询，那么查询的总复杂度O(m * logn)
```



```mysql
tarjan算法解决LCA问题
测试链接 : https://www.luogu.com.cn/problem/P3379

算法过程：
1）处理所有问题，建好每个节点的问题列表，然后遍历树
2）来到当前节点cur，令visited[cur] = true，表示当前节点已经访问
3）遍历cur的所有子树，每棵子树遍历完都和cur节点合并成一个集合，集合设置cur做头节点
4）遍历完所有子树后，处理关于cur节点的每一条查询(cur, x)
   如果发现x已经访问过，cur和x的最低公共祖先 = x所在集合的头节点
   如果发现x没有访问过，那么当前查询先不处理，等到x节点时再去处理查询(x, cur)得到答案
课上重点图解过程

需要用到并查集
```



```mysql
1.树节点的第k个祖先(1483H)
```

# 119 树上问题专题2-树上倍增和LCA-下

```mysql
有一个显而易见的结论
如果边的权值为正，假设节点a和节点b的最低公共祖先是节点c
那么
a到b的路径长度 = 头节点到a的长度 + 头节点到b的长度 - (头节点到c的长度 * 2)

```

```mysql
1.2846H
```



# 125 轮廓线dp

```mysql
轮廓线dp是状压dp的一种

位运算的几个简单操作

得到状态s第j位的状态 : (s >> j) & 1

把状态s第j位的状态设置成1，其他位置状态不变 : s = s | (1 << j)

把状态s第j位的状态设置成0，其他位置状态不变 : s = s & (~(1 << j))

```



```mysql
1.P1896 互不侵犯(K国王问题)
```

# 126三进制状压dp

```mysql
如果每个格子，值的可能性不是2的幂，还要用二进制去拼状态的话，会浪费状态空间

此时可以选择直接用k进制来拼状态，比如3进制状态的表达、5进制状态的表达

很容易扩展到k进制状态的表达，如此一来，申请状态空间的时候，完全不浪费状态空间
```

$(x/k^i)\%k$ 第i位的值为x除以k的i次方再对k取模

```mysql
1.最大化网格幸福噶(1659H)
2.用三种不同颜色为网格涂色(1931H)
```



# 127 动态规划优化专题1-优化尝试和状态设计-上

```mysql
1.摘樱桃(741H)
```

# 128 动态规划优化专题2-优化尝试和状态设计-下

```mysql
1.鸡蛋掉落(887H)
2.将珠子放入背包中(2551Heedeeewwdeededee)
```

# 129 动态规划优化专题3-倍增优化  

```mysql
1.最多可以参加会议的数目II(1751H)
2.统计重复个数(466H)
```

# 130.动态规划优化专题4-单调队列和单调栈优化

```mysql
1.
2.
3.
4.
5.最小移动距离(2463H)
6.巫师力量和(2281H)
7.
8.送箱子到码头的最少行程数(1687H)
```

# 131.动态规划优化专题5-树状数组和线段树优化

````mysql
1.区间和的个数(327H)
2.平衡子序列的最大和(2926H)
3.最长理想子序列(2370M)
````

# 132.动态规划优化专题6-预处理数组优化

```mysql
1.粉刷房子(1473H)
```

# 146.康托展开、约瑟夫环、完美洗牌

```latex
康托展开
数字从1到n，可以有很多排列，给出具体的一个排列，求该排列的名次，排名从0开始，使用树状数组解决
```

$排列S的排名=\displaystyle\sum_{i=1}^{n}rightSmall(S[i])\times (n-i)!$

```mysql
约瑟夫环问题
老编号=(新编号+k-1)%n+1
```



```mysql
完美洗牌
交换数组的两部分:1)左部分逆序,2)右部分逆序,3)整体逆序,逆序都通过双指针实现

完美洗牌算法
给定数组arr，给定某个范围arr[l..r]，该范围长度为n，n是偶数
因为n是偶数，所以范围可以分成左右两部分，arr[l1, l2, ..lk, r1, r2, ..rk]，k = n / 2
请把arr[l..r]范围上的数字调整成arr[r1, l1, r2, l2, .. rk, lk]，其他数字不变
要求时间复杂度O(n)，额外空间复杂度O(1)
1，左右部分交换的原地调整实现
2，下标编号的变化分析 + 下标循环怼的基本思路
3，一些特殊长度，可以利用一个数学结论，就能找到所有子环的起点，分批进行下标循环怼
4，这些特殊长度，类似某种进制，任意偶数长度都可以从大到小拆分成特殊长度，使问题得到解决
5，时间复杂度和空间复杂度分析

分解成3^k-1,如2,8,26,80...
```



```mysql
1.摆动排序II(324M)
```



# 148 有序表专题1-AVL树

```mysql
有序表
有序表可以理解为一个抽象类，实现这个抽象类的方式很多，可以用平衡树实现，或用其他结构实现
有序表中的key按序组织，并且支持和序有关的查询操作，增加或者删除某个key时，也要维护序
不管实现有序表的结构是什么，都要做到增、删、改、查，时间复杂度为O(log n)
```



```mysql
AVL树是理解平衡树的起点结构，也是最经典的平衡搜索二叉树

平衡性：任意子树上，左树高度和右树高度，相差不超过1

单次增、删、改、查，时间复杂度都为O(log n)
```



```mysql
AVL树的核心是理解以下内容：
1，静态数组实现AVL树，空间的使用方式
2，处理不同查询，有时需要多维护一些数据，value信息、词频计数信息、子树的数字总数信息等等
3，左旋和右旋操作
4，四种违规情况：LL型、LR型、RL型、RR型，每种违规情况对应的调整
5，增加节点的过程
6，删除节点的过程，其中替换节点的过程是重点
```



```mysql
增加或者删除节点时,会发生以下四种违规情况
四种违规情况的调整
LL:右旋父节点(整体)
LR:先左旋左孩子,然后右旋父节点(整体)
RL:先右旋右孩子,然后左旋父节点(整体)
RR:左旋父节点(整体)

四种违规类型的判断
LL:左子树高度大于右子树,并且左孩子的左子树高度大于左孩子的右子树高度
LR:左子树高度大于右子树,并且左孩子的左子树高度小于左孩子的右子树高度
RR:右子树高度大于左子树,并且右孩子的右子树高度大于右孩子的左子树高度
RL:右子树高度大于左子树,并且右孩子的左子树高度大于右孩子的右子树高度

删除节点时可能出现LL和LR同时出现的情况,此时进行LL调整
```



```mysql
1.普通平衡树(P3369)
2.根据身高重建队列(406M)
```

# 156.带权并查集的原理和扩展题目

```mysql
带权并查集的原理，一维数轴相对距离模型
1，点权代表当前节点到集合头节点的距离，并不保证实时正确，可以经过find过程修正正确
2，void union(l, r, v)，l和r属于两个集合，并且l到r距离为v，合并两个集合
    find(l)头为lf，find(r)头rf，find过程会修正dist[l]和dist[r]
    father[lf] = rf
    dist[lf] = dist[r] - dist[l] + v
3，int find(i)，寻找i所在集合的头，同时修正dist[i]的值
    路径压缩之前i的父为t，路径压缩之后，dist[i] += dist[t]
4，int query(l, r)，查询l和r之间的距离关系
    find(l) == find(r)，才有距离关系，距离 = dist[l] - dist[r]
```

# 157.可持久化线段树和标记永久化

## 1.单点修改单点查询



```c++
#include<bits/stdc++.h>
using namespace std;
// 单点修改的可持久化线段树模版题1，C++版
// 给定一个长度为n的数组arr，下标1~n，原始数组认为是0号版本
// 一共有m条操作，每条操作是如下两种类型中的一种
// v 1 x y : 基于v号版本的数组，把x位置的值设置成y，生成新版本的数组
// v 2 x   : 基于v号版本的数组，打印x位置的值，生成新版本的数组和v版本一致
// 每条操作后得到的新版本数组，版本编号为操作的计数
// 1 <= n, m <= 10^6
// 测试链接 : https://www.luogu.com.cn/problem/P3919
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

const int MAXN = 1000001;
const int MAXT = MAXN * 23;
int n, m;
int arr[MAXN];
int root[MAXN];
int ls[MAXT];
int rs[MAXT];
int value[MAXT];
int cnt = 0;

int build(int l, int r) {
    int rt = ++cnt;
    if (l == r) {
        value[rt] = arr[l];
    } else {
        int mid = (l + r) >> 1;
        ls[rt] = build(l, mid);
        rs[rt] = build(mid + 1, r);
    }
    return rt;
}

int update(int jobi, int jobv, int l, int r, int i) {
    int rt = ++cnt;
    ls[rt] = ls[i];
    rs[rt] = rs[i];
    value[rt] = value[i];
    if (l == r) {
        value[rt] = jobv;
    } else {
        int mid = (l + r) >> 1;
        if (jobi <= mid) {
            ls[rt] = update(jobi, jobv, l, mid, ls[rt]);
        } else {
            rs[rt] = update(jobi, jobv, mid + 1, r, rs[rt]);
        }
    }
    return rt;
}

int query(int jobi, int l, int r, int i) {
    if (l == r) {
        return value[i];
    }
    int mid = (l + r) >> 1;
    if (jobi <= mid) {
        return query(jobi, l, mid, ls[i]);
    } else {
        return query(jobi, mid + 1, r, rs[i]);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    root[0] = build(1, n);
    for (int i = 1, version, op, x, y; i <= m; i++) {
        cin >> version >> op >> x;
        if (op == 1) {
            cin >> y;
            root[i] = update(x, y, 1, n, root[version]);
        } else {
            root[i] = root[version];
            cout << query(x, 1, n, root[i]) << '\n';
        }
    }
    return 0;
}
```

## 2.单点修改范围查询

```c++
#include<bits/stdc++.h>

using namespace std;
// 单点修改的可持久化线段树模版题2，C++版
// 给定一个长度为n的数组arr，下标1~n，一共有m条查询
// 每条查询 l r k : 打印arr[l..r]中第k小的数字
// 1 <= n、m <= 2 * 10^5
// 0 <= arr[i] <= 10^9
// 测试链接 : https://www.luogu.com.cn/problem/P3834
// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
// 提交如下代码，可以通过所有测试用例

const int MAXN = 200001;
const int MAXT = MAXN * 22;
int n, m, s;
int arr[MAXN];
int sorted[MAXN];
int root[MAXN];
int ls[MAXT];
int rs[MAXT];
int siz[MAXT];
int cnt;

int kth(int num) {
    int left = 1, right = s, mid, ans = 0;
    while (left <= right) {
        mid = (left + right) / 2;
        if (sorted[mid] <= num) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

int build(int l, int r) {
    int rt = ++cnt;
    siz[rt] = 0;
    if (l < r) {
        int mid = (l + r) / 2;
        ls[rt] = build(l, mid);
        rs[rt] = build(mid + 1, r);
    }
    return rt;
}

int insert(int jobi, int l, int r, int i) {
    int rt = ++cnt;
    ls[rt] = ls[i];
    rs[rt] = rs[i];
    siz[rt] = siz[i] + 1;
    if (l < r) {
        int mid = (l + r) / 2;
        if (jobi <= mid) {
            ls[rt] = insert(jobi, l, mid, ls[rt]);
        } else {
            rs[rt] = insert(jobi, mid + 1, r, rs[rt]);
        }
    }
    return rt;
}

int query(int jobk, int l, int r, int u, int v) {
    if (l == r) {
        return l;
    }
    int lsiz = siz[ls[v]] - siz[ls[u]];
    int mid = (l + r) / 2;
    if (lsiz >= jobk) {
        return query(jobk, l, mid, ls[u], ls[v]);
    } else {
        return query(jobk - lsiz, mid + 1, r, rs[u], rs[v]);
    }
}

void prepare() {
    cnt = 0;
    for (int i = 1; i <= n; i++) {
        sorted[i] = arr[i];
    }
    sort(sorted + 1, sorted + n + 1);
    s = 1;
    for (int i = 2; i <= n; i++) {
        if (sorted[s] != sorted[i]) {
            sorted[++s] = sorted[i];
        }
    }
    root[0] = build(1, s);
    for (int i = 1, x; i <= n; i++) {
        x = kth(arr[i]);
        root[i] = insert(x, 1, s, root[i - 1]);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    prepare();
    for (int i = 1, l, r, k, rank; i <= m; i++) {
        cin >> l >> r >> k;
        rank = query(k, 1, s, root[l - 1], root[r]);
        cout << sorted[rank] << '\n';
    }
    return 0;
}
```

