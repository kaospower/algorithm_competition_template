# 1.根号分治

# 2.剥洋葱(常用于树上问题)

# 3.摩尔投票(使用常数空间查找众数)

# 4.刷表法(常用于动态规划)

# 5.最小表示法(解决字符串最大字典序后缀利器)

# 6.可持久化线段树

# 7.完美洗牌算法(Wiggle Sort)

# 8.诱导排序(常用于求后缀数组)

# 9.Morris遍历

# 10.非递归遍历树

# 11.线索二叉树

# 12.动态dp(ddp)

# 13.原地哈希

# 14.非递归版线段树

# 15.回滚莫队

# 16.快速选择(求第k大)

# 17.悬线法

# 18.循环节算法

该算法相当不常见,在扩展卢卡斯定理的实现过程中,用到了这一技巧

同时一般用kmp来寻找循环节

用到循环节优化的题:LC418(https://leetcode.cn/problems/sentence-screen-fitting/description/)

# 19.决策单调性

# 20.二分栈

# 21.多项式积分

# 22.三分查找

```c++
//类似二分法,不过每次是分成三段区间
while (r - l > eps) {
  mid = (l + r) / 2;
  lmid = mid - eps;
  rmid = mid + eps;
  if (f(lmid) < f(rmid))
    r = mid;
  else
    l = mid;
}
```

# 23.水塘抽样

# 24.凸包

# 25.半平面交

# 26.旋转卡壳

# 27.珂朵莉树

# 28.奈芙莲树

```c++
#include<bits/stdc++.h>
#define int long long
#define N 500005
#define M 20000005
using namespace std;
int read(){
   register int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
   return s*w;
}	
void print(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9)print(x/10);
    putchar(x%10+'0');
}	
int lowbit(int x){return x&(-x);}
int q,n,phi[M],pr[M>>3],id;
int t[N];char vis[M];
int query(int x){
	int s=0;//区间查询  
	while(x){
		s+=t[x];
		x-=lowbit(x);
	}return s;
}
struct node{//重载 [] 运算符
	int v[N],l[N];
	int&operator[](int x){
	if(l[x]!=id)l[x]=id,v[x]=query(x);
		return v[x];
	}
}a;
void add(int x,int c){
	id++;//区间修改 记录修改次数  
	while(x<=n){
		t[x]+=c;
		x+=lowbit(x);
	}
}
int ksm(int b,int p,int mod){
	int s=1;b%=mod;//底数先取模
	while(p){
		if(p&1)s=1ll*s*b%mod;
		b=b*b%mod;p>>=1;
	}return s;
}
void getphi(){//预处理 phi
	int cnt=0;phi[1]=1;
	for(int i=2;i<M;i++){
		if(!vis[i])pr[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&pr[j]*i<M;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j])phi[pr[j]*i]=phi[i]*(pr[j]-1);
			else phi[pr[j]*i]=phi[i]*pr[j];
			if(i%pr[j]==0)break;
		}
	}
}
void work1(int l,int r,int c){add(l,c);add(r+1,-c);}
int work2(int l,int r,int mod){
	if(a[l]%mod==0)return 0;
	else if(mod==1)return 1;
	else if(l==r){
		if(a[l]>=mod)return a[l]%mod+mod;
		else return a[l]%mod;
	}
    int len=min(l+5,r);
	for(int i=l+1;i<=len;i++)
		if(a[i]==1){//找 1
			len=i;
			break;
		}
	int g=0,last=a[len];
	for(int i=len-1;i>=l+1;i--){
		g=last,last=1;
		while(g--){
			last=last*a[i];
			if(last>phi[mod])
				return ksm(a[l],work2(l+1,r,phi[mod])+phi[mod],mod);
		}
	}
    return ksm(a[l],last,mod);
}
    main(){
	n=read();q=read();getphi();
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		add(i,a[i]-a[i-1]);//做差分 
	}
    for(int i=1;i<=q;i++){
		int op,l,r,c;
		op=read();l=read();r=read();c=read();
		if(op==1)work1(l,r,c);
		else print(work2(l,r,c)%c),putchar('\n');
	}
    return 0;
}
```

# 29.树链剖分

# 30.树上启发式合并

# 31.静态链分治

# 32.舞蹈链

# 33.动态dp(ddp)

# 34.欧拉回路树(ETT)

# 35.虚树

# 36.李超线段树

# 37.线段树分治

# 38.线段树合并与分裂

顾名思义，线段树合并是指建立一棵新的线段树，这棵线段树的每个节点都是两棵原线段树对应节点合并后的结果。它常常被用于维护树上或是图上的信息。

显然，我们不可能真的每次建满一颗新的线段树，因此我们需要使用上文的动态开点线段树。

线段树合并的过程本质上相当暴力：

假设两颗线段树为 A 和 B，我们从 1 号节点开始递归合并。

递归到某个节点时，如果 A 树或者 B 树上的对应节点为空，直接返回另一个树上对应节点，这里运用了动态开点线段树的特性。

如果递归到叶子节点，我们合并两棵树上的对应节点。

最后，根据子节点更新当前节点并且返回。

```c++
int merge(int a, int b, int l, int r) {
  if (!a) return b;
  if (!b) return a;
  if (l == r) {
    // do something...
    return a;
  }
  int mid = (l + r) >> 1;
  tr[a].l = merge(tr[a].l, tr[b].l, l, mid);
  tr[a].r = merge(tr[a].r, tr[b].r, mid + 1, r);
  pushup(a);
  return a;
}
```

线段树分裂实质上是线段树合并的逆过程。线段树分裂只适用于有序的序列，无序的序列是没有意义的，常用在动态开点的权值线段树。

注意当分裂和合并都存在时，我们在合并的时候必须回收节点，以避免分裂时会可能出现节点重复占用的问题。

从一颗区间为 [1,N] 的线段树中分裂出 [l,r]，建一颗新的树：

从 1 号结点开始递归分裂，当节点不存在或者代表的区间 [s,t] 与 [l,r] 没有交集时直接回溯。

当 [s,t] 与 [l,r] 有交集时需要开一个新结点。

当 [s,t] 包含于 [l,r] 时，需要将当前结点直接接到新的树下面，并把旧边断开。

```c++
void split(int &p, int &q, int s, int t, int l, int r) {
  if (t < l || r < s) return;
  if (!p) return;
  if (l <= s && t <= r) {
    q = p;
    p = 0;
    return;
  }
  if (!q) q = New();
  int m = s + t >> 1;
  if (l <= m) split(ls[p], ls[q], s, m, l, r);
  if (m < r) split(rs[p], rs[q], m + 1, t, l, r);
  push_up(p);
  push_up(q);
}
```

# 39.树套树

# 40.Top Tree

# 41.泰勒级数

# 42.FFT/NTT/FNTT

# 43.狄尔沃斯定理(Dilworth)

# 44.拉格朗日插值法

# 45.狄利克雷卷积

# 46.大步小步算法(BSGS)

# 47.快速莫比乌斯变换(FMT)

**用于快速计算位运算卷积**



**或卷积**

```c++
void FMT(int *f,int n,int op)//op=1为正变换，op=-1为逆变换
{
    for(int i=0;i<n;++i)
        for(int j=0;j<(1<<n);++j)
            if(j&(1<<i))f[j]+=f[j^(1<<i)]*op;
}
```

**与卷积**

```c++
void FMT(int *f,int n,int op)//op=1为正变换，op=-1为逆变换
{
    for(int i=0;i<n;++i)
        for(int j=0;j<(1<<n);++j)
            if(j&(1<<i))f[j^(1<<i)]+=f[j]*op;
}
```

# 48.尼姆博弈(Nim)

# 49.仙人掌

# 50.圆方树

# 51.启发式搜索

# 52.Minimax算法(极小化极大算法)

# 53.Alpha-Beta剪枝

# 54.模拟退火

# 55.爬山算法

# 56.欧拉降幂

# 57.分块

# 58.树的重心

# 59.Treap

# 60.FHQ Treap

# 61.Splay

# 62.点分治

# 63.可持久化并查集

# 64.莫队

# 65.树上差分

# 66.二分套二分

# 67.斜率优化dp

# 68.基环树dp

# 69.四边形不等式优化dp

# 70.分数规划

