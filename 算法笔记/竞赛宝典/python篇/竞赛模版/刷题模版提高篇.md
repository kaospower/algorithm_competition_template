[TOC]

# 1.动态规划

**注意dp有多种分类方法**

**dp分析五步走**

**1.从题目中给出的信息可以判断出该题是网格图dp,划分型dp,状态机dp,区间dp,状压dp,树型dp...等等**

**2.如果以上都不是,说明其就是普通线性dp,可以考虑一维dp,二维dp,多维dp...等等**

**3.定义状态,常见状态有两种,一种是以下标作为状态,一种是以值作为状态,下标作为状态较为常见,而以值作为状态,要么是值域范围较小,要么是离散后的值域范围较小**

**4.转移方程,常见的有两种,一种是从前往后转移,即前缀型dp,另一种是从后往前转移,即后缀型dp**

**5.转移来源,常见的是单来源,如果来源较多或者来源不易找到,则可以考虑刷表法,降低书写难度**

## 1.网格图dp

```mysql
模版题:941.下降路径最小和
(https://leetcode.cn/problems/minimum-falling-path-sum/description/)
网格图dp有两种思考方式,从起点出发到终点,从终点出发到起点,这两种思考方式有在代码实现难度方面有时会有不同,需要灵活选择
针对每种思考方式,有5种写法
1.利用@cache的记忆化搜索
2.手动实现dp表的记忆化搜索
3.dp
4.优化边界的dp
5.在4基础上空间压缩的dp
```

### 1.模版1a

**递归入口在终点,利用cache记忆化搜索,代码最少,速度最慢**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        @cache
        def f(i,j):
            if j<0 or j==n:
                return inf
            if i==0:
                return matrix[i][j]
            return min(f(i-1,j-1),f(i-1,j),f(i-1,j+1))+matrix[i][j]
        return min(f(n-1,j) for j in range(n))
```

### 2.模版1b

**递归入口在终点,手动实现记忆化搜索**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        #手写记忆化搜索时注意初始化应为inf,因为matrix中可能有负数
        dp=[[inf]*n for _ in range(n)] 
        def f(i,j):
            if j<0 or j==n:
                return inf
            if dp[i][j]!=inf:
                return dp[i][j]
            if i==0:
                ans=matrix[i][j]
            else:
                ans=min(f(i-1,j-1),f(i-1,j),f(i-1,j+1))+matrix[i][j]
            dp[i][j]=ans
            return ans 
        return min(f(n-1,j) for j in range(n))
```

### 3.模版1c

**从起点出发到终点,二维动态规划**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        #手写记忆化搜索时注意初始化应为inf,因为matrix中可能有负数
        dp=[[0]*n for _ in range(n)] 
        dp[0]=matrix[0]
        for i in range(1,n):
            for j in range(n):
                dp[i][j]=dp[i-1][j]
                if j-1>=0 and dp[i-1][j-1]<dp[i][j]:
                    dp[i][j]=dp[i-1][j-1]
                if j+1<n and dp[i-1][j+1]<dp[i][j]:
                    dp[i][j]=dp[i-1][j+1]
                dp[i][j]+=matrix[i][j]
        return min(dp[n-1])
```

### 4.模版1d

**从起点出发到终点,二维动态规划,边界优化,在dp表两侧各加一列减少对边界的讨论,现在1~n列为正常dp表,0和n+1列为边界**

```python
#这种写法可以极大缩短代码长度
#但是注意书写时,dp[i][j+1]对应matrix[i][j]
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        #手写记忆化搜索时注意初始化应为inf,因为matrix中可能有负数
        dp=[[inf]*(n+2) for _ in range(n)] 
        dp[0][1:n+1]=matrix[0]
        for i in range(1,n):
            for j in range(n):
                dp[i][j+1]=min(dp[i-1][j],dp[i-1][j+1],dp[i-1][j+2])+matrix[i][j]
        return min(dp[n-1])
```

### 5.模版1e

**从起点出发到终点,二维动态规划,写法4的空间压缩版**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        dp=[inf]+matrix[0]+[inf]
        #使用两个变量pre,tmp滚动更新dp[j],dp[j+1],python可以利用双变量赋值的性质减少一个变量
        for i in range(1,n):
            pre=dp[0]
            for j in range(n):
                #其他语言写法
                # tmp=dp[j+1]
                # dp[j+1]=min(pre,dp[j+1],dp[j+2])+matrix[i][j]
                # pre=tmp
                #python写法
                pre,dp[j+1]=dp[j+1],min(pre,dp[j+1],dp[j+2])+matrix[i][j]
        return min(dp)
```

### 6.模版2a

**递归入口在起点(表示从终点出发到起点,即反走),利用cache记忆化搜索,代码最少,速度最慢**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        @cache
        def f(i,j):
            if j<0 or j==n:
                return inf
            if i==n-1:
                return matrix[i][j]
            return min(f(i+1,j-1),f(i+1,j),f(i+1,j+1))+matrix[i][j]
        return min(f(0,j) for j in range(n))
```

### 7.模版2b

**从起点递归,手动实现记忆化搜索**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        dp=[[inf]*n for _ in range(n)] 
        def f(i,j):
            if j<0 or j==n:
                return inf
            if dp[i][j]!=inf:
                return dp[i][j]
            if i==n-1:
                ans=matrix[i][j]
            else:
                ans=min(f(i+1,j-1),f(i+1,j),f(i+1,j+1))+matrix[i][j]
            dp[i][j]=ans
            return ans 
        return min(f(0,j) for j in range(n))
```

### 8.模版2c

**从终点出发到起点,二维动态规划**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        dp=[[0]*n for _ in range(n)] 
        dp[-1]=matrix[-1]
        for i in range(n-2,-1,-1):
            for j in range(n):
                dp[i][j]=dp[i+1][j]
                if j-1>=0 and dp[i+1][j-1]<dp[i][j]:
                    dp[i][j]=dp[i+1][j-1]
                if j+1<n and dp[i+1][j+1]<dp[i][j]:
                    dp[i][j]=dp[i+1][j+1]
                dp[i][j]+=matrix[i][j]
        return min(dp[0])
```

### 9.模版2d

**从终点出发到起点,二维动态规划,边界优化,在dp表两侧各加一列减少对边界的讨论,现在1~n列为正常dp表,0和n+1列为边界**

```python
#这种写法可以极大缩短代码长度
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        dp=[[inf]*(n+2) for _ in range(n)] 
        dp[-1][1:n+1]=matrix[-1]
        for i in range(n-2,-1,-1):
            for j in range(n):
                dp[i][j+1]=min(dp[i+1][j],dp[i+1][j+1],dp[i+1][j+2])+matrix[i][j]
        return min(dp[0])
```

### 10.模版2e

**从终点出发到终点,二维动态规划,写法4的空间压缩版**

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n=len(matrix)
        dp=[inf]+matrix[-1]+[inf]
        for i in range(n-2,-1,-1):
            pre=dp[0]
            for j in range(n):
                #其他语言写法
                # tmp=dp[j+1]
                # dp[j+1]=min(pre,dp[j+1],dp[j+2])+matrix[i][j]
                # pre=tmp
                #python写法
                pre,dp[j+1]=dp[j+1],min(pre,dp[j+1],dp[j+2])+matrix[i][j]
        return min(dp)
```

## 2.背包问题

注意背包问题默认体积不为0,如果有体积为0的物品,需要提前预处理,否则会造成错误,转移方程陷入无限循环.

实际的背包问题往往不能直接套模版,需要进行优化才能通过.

常见的优化方式有:

位图优化逻辑运算型01背包

二进制分组/单调队列优化多重背包求最值,前缀和优化多重背包求方案数

### 1.01背包

```mysql
模版题:416.分割等和子集
(https://leetcode.cn/problems/partition-equal-subset-sum/description/)
leetcode上的01背包以逻辑运算型01背包为主,基本都可以用位图进行优化
位图优化逻辑和01背包正常书写刚好是反过来的,01背包是dp[j]=dp[j-v[i]],位图相当于是dp[j+v[i]]=dp[j],即f|=f<<num
位图将所有能取到的值都保存下来,某个二进制位i为1(True),说明这个下标值可以取到
```

**位图优化逻辑运算型01背包**

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums=0
        f=1 #将f数组压缩到一个数f中,用位图存储
        for num in nums:
            f|=f<<num
            sums+=num #顺带计算sum(nums)
        #左边判断sums是否为偶数,右边取出第m位,相当于求f[sums//2]
        return bool(~sums&1&(f>>(sums//2)))
```

### 2.完全背包

### 3.多重背包

最值型多重背包可以用二进制分组/单调队列优化

方案型多重背包可以用前缀和优化

```python
#模版题2902(https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/)
#前缀和优化多重背包求方案数模版
fmin=lambda x,y:x if x<y else y
mod=1_000_000_007
#arr_v代表物品体积数组,arr_c代表物品数量数组,V代表背包容量,C代表体积为0的物品数量,l,r代表体积上下界
def solve(arr_v,arr_c,V,C,l,r):
    f=[1+C]+[0]*V
    s=0
    for v,c in zip(arr_v,arr_c):
        s=fmin(s+v*c,V)
        for j in range(v,s+1):
            f[j]=(f[j]+f[j-v])%mod
        t=(c+1)*v
        for j in range(s,t-1,-1):
            f[j]=(f[j]-f[j-t])%mod
    return sum(f[l:])%mod
```

### 4.分组背包

### 5.有依赖的背包(树上背包)

### 6.背包问题求方案数

背包问题求方案数一般将数组初始化为f=[0]*m,f[0]=1,f[i]代表恰好装满体积i的方案数,注意背包问题求方案数时,必须按恰好装满考虑,这和求最值的模型有所不同.如果题目求<=m的方案数,返回sum(f[m:])即可

```python
#2518(https://leetcode.cn/problems/number-of-great-partitions/)
#此题求的是和为0~k的总方案数,因此最后要对f数组求和
mod=1_000_000_007
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        if sum(nums)<2*k:
            return 0
        n=len(nums)
        f=[0]*k
        f[0]=1
        for x in nums:
            for j in range(k-1,x-1,-1):
                f[j]=(f[j]+f[j-x])%mod
        return (pow(2,n,mod)-2*sum(f))%mod
```

### 7.背包问题及其变式

**天下难题自dp,天下dp自背包**

背包问题常见变式,**恰好**装满V,**至多**装V,**至少**装V时的**最大最小**价值(min,max模型)/**方案数**(加法模型)/其他变式

这几种变式的主要区别是初始化不同,例如:

最大模型是f=[0]+[-inf]*n

最小模型是f=[0]+[inf]*n

方案模型是f=[1]+[0]*n

背包型构造题,给出方案数,求物品体积可能取值

背包问题求指定体积V的方案数,有两种写法
$一种是f=[1]+[0]*V,这样f[j]表示恰好装满j的方案数$
$另一种是f=[1]*(V+1),这样f[j]表示至多装j的方案数$

## 4.LIS

### 1.最长严格递增子序列

```python
#300(https://leetcode.cn/problems/longest-increasing-subsequence/)
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        #g[i]表示长度为i+1的递增子序列的末尾元素的最小值
        g=[]
        for x in nums:
            j=bisect_left(g,x)
            if j==len(g):
                g.append(x)
            else:
                g[j]=x
        return len(g)
```

### 2.最长非严格递增子序列

```python
#2826(https://leetcode.cn/problems/sorting-three-groups/)
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        g=[]
        for x in nums:
            j=bisect_right(g,x)
            if j==len(g):
                g.append(x)
            else:
                g[j]=x
        return len(nums)-len(g) 
```

## 5.数位dp

**注意:所有数位dp模版的参数都必须是字符串,使用前需要先将整数转化成题目要求进制下的字符串**

**由于数位dp求出的结果经常要取模,这里给出的模版都是取模版本,实际应用时如果不需要取模进行修改即可**

### 1a.数位dp标准模版(注释版)

**带isLimit和isNum参数,这个模版常用于处理需要考虑前导0的问题**

**实际应用时根据题意在f中补充额外的参数**

**注意此模版不包含0,表示的是从1开始的结果**

```python
mod=1_000_000_007
def g(s):
    m=len(s)
    @cache
    #isLimit表示当前是否受到了n的约束,isNum 表示i前面的数位是否填了数字
    def f(i,isLimit,isNum):
        if i==m:
            return 1 if isNum else 0
        res=0
        #跳过当前数位
        if not isNum:
            res=f(i+1,False,False)
        #不跳过
        low=0 if isNum else 1
        up=int(s[i]) if isLimit else 9 #对于k进制,这里替换成k-1,常用的10进制这里就是9
        for d in range(low,up+1):
            res+=f(i+1,isLimit and d==up,True)
        return res%mod
    return f(0,True,False)
```
### 1b.数位dp标准模版(纯净版)

```python
mod=1_000_000_007
def g(s):
    m=len(s)
    @cache
    def f(i,isLimit,isNum):
        if i==m:
            return 1 if isNum else 0
        res=0
        if not isNum:
            res=f(i+1,False,False)
        low=0 if isNum else 1
        up=int(s[i]) if isLimit else 9
        for d in range(low,up+1):
            res+=f(i+1,isLimit and d==up,True)
        return res%mod
    return f(0,True,False)
```


```python
#上面模版的应用
#2376(https://leetcode.cn/problems/count-special-integers/description/)
class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        s=str(n)
        m=len(s)
        #mask 表示前面选过的数字集合,isLimit 表示当前是否受到了 n 的约束,isNum 表示 i 前面的数位是否填了数字
        @cache
        def f(i,mask,isLimit,isNum):
            if i==m:
                return 1 if isNum else 0
            res=0
            #跳过当前数位
            if not isNum:
                res=f(i+1,mask,False,False)
            #不跳过
            low=0 if isNum else 1
            up=int(s[i]) if isLimit else 9
            for d in range(low,up+1):
                #该数字必须没选过
                if mask>>d&1==0:
                    #注意此时只有d等于上界并且isLimit原来为True,新的isLimit才是True
                    res+=f(i+1,mask|1<<d,isLimit and d==up,True)
            return res
        return f(0,0,True,False)
```

### 2a.数位dp简化模版(注释版)

**只有isLimit参数,这个模版常用于处理可以忽略前导0的问题**

**由于可以忽略前导0的影响,我们可以用位运算优化部分操作**

**注意此模版不包含0,表示的是从1开始的结果**

```python
mod=1_000_000_007
m=len(s) #原始字符串的长度
#isLimit表示当前是否受到了n的约束
@cache
def f(i,isLimit):
    if i==m:
        return 1
    res=0
    up=int(s[i]) if isLimit else 9 #取出原串第i位,如果是二进制串就用位运算取
    for d in range(up+1):
        res+=f(i+1,isLimit and d==up)
    return res%mod
return f(0,True)
```

### 2b.数位dp简化模版(纯净版)

```python
mod=1_000_000_007
m=len(s)
@cache
def f(i,isLimit):
    if i==m:
        return 1
    res=0
    up=int(s[i]) if isLimit else 9
    for d in range(up+1):
        res+=f(i+1,isLimit and d==up)
    return res%mod
return f(0,True)
```



```python
#上面模版的应用
#600(https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/)
class Solution:
    def findIntegers(self, n: int) -> int:
        m=n.bit_length()
        #isLimit 表示当前是否受到了 n 的约束,isNum 表示 i 前面的数位是否填了数字
        @cache
        def f(i,isLimit,pre):
            if i==m:
                return 1
            res=0
            up=n>>m-1-i&1 if isLimit else 1 #利用位运算取出n从左往右数第i个二进制位
            for d in range(up+1):
                if pre and d: #如果前一位和当前位都是1,跳过
                    continue
                res+=f(i+1,isLimit and d==up,d)
            return res
        return f(0,True,0)
```

### 3a.上下界数位dp标准模版(注释版)

**带isLimit和isNum参数,这个模版常用于处理需要考虑前导0的问题**

```python
mod=1_000_000_007
#h输入的是整数类型,g会把整数转成字符串
def h(num1,num2):
    def g(num):
        m=len(num)
        #isLimit 表示当前是否受到了 n 的约束,isNum 表示 i 前面的数位是否填了数字
        @cache
        def f(i,isLimit,isNum):
            if i==m:
                return 1 if isNum else 0
            res=0
            #跳过当前数位
            if not isNum:
                res=f(i+1,False,False)
            #不跳过
            low=0 if isNum else 1
            up=int(num[i]) if isLimit else 9
            for d in range(low,up+1):
                #注意此时只有d等于上界并且isLimit原来为True,新的isLimit才是True
                res+=f(i+1,isLimit and d==up,True)
            return res%mod
        return f(0,True,False)
    return (g(num2)-g(str(int(num1)-1)))%mod
```
### 3b.上下界数位dp标准模版(纯净版)

```python
mod=1_000_000_007
def h(num1,num2):
    def g(num):
        m=len(num)
        @cache
        def f(i,isLimit,isNum):
            if i==m:
                return 1 if isNum else 0
            res=0
            if not isNum:
                res=f(i+1,False,False)
            low=0 if isNum else 1
            up=int(num[i]) if isLimit else 9
            for d in range(low,up+1):
                res+=f(i+1,isLimit and d==up,True)
            return res%mod
        return f(0,True,False)
    return (g(num2)-g(str(int(num1)-1)))%mod
```



```python
#上面模版的应用
#2719(https://leetcode.cn/problems/count-of-integers/)
mod=1_000_000_007
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        def g(num):
            m=len(num)
            #isLimit 表示当前是否受到了 n 的约束,isNum 表示 i 前面的数位是否填了数字
            @cache
            def f(i,isLimit,isNum,s):
                if s>max_sum: #可行性剪枝
                    return 0
                if i==m:
                    return 1 if isNum and s>=min_sum else 0
                res=0
                #跳过当前数位
                if not isNum:
                    res=f(i+1,False,False,s)
                #不跳过
                low=0 if isNum else 1
                up=int(num[i]) if isLimit else 9
                for d in range(low,up+1):
                    #注意此时只有d等于上界并且isLimit原来为True,新的isLimit才是True
                    res+=f(i+1,isLimit and d==up,True,s+d)
                return res%mod
            return f(0,True,False,0)
        return (g(num2)-g(str(int(num1)-1)))%mod
```

### 4a.上下界数位dp精简模版(注释版)

**带isLimit和isNum参数,这个模版常用于处理不需要考虑前导0的问题**

```python
#num1,num2分别代表下界和上界
mod=1_000_000_007
def g(num1,num2):
    n=len(num2)
    num1=num1.zfill(n) #补前导0
    @cache
    def f(i,limit_low,limit_high):
        if i==n:
            return 1

        lo=int(num1[i]) if limit_low else 0
        hi=int(num2[i]) if limit_high else 9 #k进制时换成k-1
        res=0
        for d in range(lo,hi+1):
            res+=f(i+1,limit_low and d==lo,limit_high and d==hi)
        return res%mod
    return f(0,True,True)
```
### 4b.上下界数位dp精简模版(纯净版)

```python
mod=1_000_000_007
def g(num1,num2):
    n=len(num2)
    num1=num1.zfill(n) 
    @cache
    def f(i,limit_low,limit_high):
        if i==n:
            return 1

        lo=int(num1[i]) if limit_low else 0
        hi=int(num2[i]) if limit_high else 9 
        res=0
        for d in range(lo,hi+1):
            res+=f(i+1,limit_low and d==lo,limit_high and d==hi)
        return res%mod
    return f(0,True,True)
```




```python
#上面模版的应用
#2719(https://leetcode.cn/problems/count-of-integers/description/)
mod=1_000_000_007
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        n=len(num2)
        num1=num1.zfill(n) #补前导0
        @cache
        def f(i,s,limit_low,limit_high):
            if s>max_sum: #可行性剪枝
                return 0
            if i==n:
                return s>=min_sum
            
            lo=int(num1[i]) if limit_low else 0
            hi=int(num2[i]) if limit_high else 9
            res=0
            for d in range(lo,hi+1):
                res+=f(i+1,s+d,limit_low and d==lo,limit_high and d==hi)
            return res%mod
        return f(0,0,True,True)
```

## 6.划分型dp

```python
划分型dp优化的两个技巧
#1.处理划分型dp时,左右各要留出空间,否则做的是无效枚举,即循环写成: for i in range(k*m-1,n-(K-k)*m)
#2.同时划分个数k的循环写在最外层,方便进一步优化

#详情见3473题

约束型划分dp常见时间复杂度是n^2k,某些时候可以用前缀和或者式子变形等方法将时间复杂度优化成nk
个别题需要引入额外参数,这个参数一般较小或者是一个定值,这时可以用选或不选的思路解决,如3117题和2209题

同时划分型dp实际有两种解法,一种是for循环枚举左端点,另一种是选或不选,两种方式可以互相转化,某些时候选或者不选的写法可以规避掉一些无效状态,效率更高.
```

### 1.最优划分

$这类划分型dp没有给出划分个数,时间复杂度一般为O(nk)$

比较复杂度的题目经常要使用前缀和等方式对dp进行优化

```python
#1043(https://leetcode.cn/problems/partition-array-for-maximum-sum/)
class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        n=len(arr)
        @cache
        def f(i):
            ans=maxv=0
            for j in range(i,max(i-k,-1),-1):
                maxv=max(maxv,arr[j])
                ans=max(ans,f(j-1)+maxv*(i-j+1))
            return ans
        return f(n-1)
```

### 2.约束划分个数

$这类划分型dp给出划分个数k,时间复杂度经过优化可到O(k(n-k)^2)$

**记忆化搜索模版**

```python
#模版题:3599(https://leetcode.cn/problems/partition-array-to-minimize-xor/description/)
fmax = lambda x, y: x if x > y else y
fmin = lambda x, y: x if x < y else y
def solve(nums, k):
    @cache
    def f(i, k):
        #当k==0时,如果i来到越界位置,返回0,否则返回inf代表不合法
        if k == 0:
            return 0 if i == -1 else inf
        s = 0
        ans = inf
        # j表示当前划分的开头位置
        # j左边必须留出k-1个位置给剩下k-1个划分,下标为0~k-2
        # 因此剩下划分的结尾位置为k-2,而j的最左下标刚好是k-2+1=k-1
        # 由于python是左闭右开区间,因此范围写成range(i,k-2,-1)
        # 当k>=1时,k-1>=0,j的下标不会越界
        # 注意到0~i总共有i+1个数,最多划分成i+1段
        # 如果k>i+1,即i<k-1时,range(i, k - 2, -1)为空区间,会返回ans默认值inf,即不合法
        for j in range(i, k - 2, -1):
            s ^= nums[j]
            ans = fmin(ans, fmax(s, f(j - 1, k - 1)))
        return ans

    ans = f(len(nums) - 1, k)
    f.cache_clear()
    return ans
```

**迭代模版**

```python
fmax = lambda x, y: x if x > y else y
fmin = lambda x, y: x if x < y else y
def solve(nums,K):
    n=len(nums)
    #k的范围为0~K,长度K+1
    #i的范围是0~n-1,但是为了避免边界讨论,用f[i+1]表示以i结尾的结果,即实际下标比真正下标偏移1
    #因此i的范围是0~n,长度n+1
    #由于k<=n,k的范围更小,因此写在外层
    #默认边界值是inf,代表不合法
    f=[[inf]*(n+1) for _ in range(K+1)]
    #f[0][0]对应记忆化搜索中的边界,即k=0,i=-1时的情况
    f[0][0]=0
    #k从1开始,因为k=0时,除了i=0,其他都不合法,为inf,i=0的情况已经特判完成
    for k in range(1,K+1):
        #i代表实际下标偏移1,i用+1下标是因为dp数组用的是偏移后的下标,因此提前在循环中加上偏移的1
        #左边要留出k-1个位置,因此左边界为k-1,右边要留出已经划分完的K-k个位置,因此右边界为n-(K-k)-1
        #由于python循环上界是开区间,因此右边界是n-(K-k)
        #由于i实际下标比真正下标要偏移1,因此这里直接在循环中加上1,因此上下界变成k,n-(K-k)+1
        #所以循环中写成range(k,n-(K-k)+1)
        for i in range(k,n-(K-k)+1):
            s=0 #s从右往左算数组异或和
            ans=inf #ans记录最值
            #j代表实际下标,即不加1,因为i加了1,因此j的上界为i-1,即将偏移量减去
            #j用实际下标是因为计算数组异或和要用实际下标,因此提前在循环中减掉偏移的1
            #j左边必须留出k-1个位置给剩下k-1个划分,下标为0~k-2
            #因此剩下划分的结尾位置为k-2,而j的最左下标刚好是k-2+1=k-1
            #由于python循环是左闭右开区间,因此范围写成range(i-1,k-2,-1)
            for j in range(i-1,k-2,-1):
                s^=nums[j]
                #j代表当前划分的开头,j左边即是下一个划分的结尾位置,即要转移到的地方,同时k-1
                ans=fmin(ans,fmax(s,f[k-1][j]))
            #注意i在上面已经加完1了
            f[k][i]=ans
    return f[-1][-1]
```

## 7.状态机dp

### 1.单序列

```python
#276(https://leetcode.cn/problems/paint-fence/)
class Solution:
    def numWays(self, n: int, k: int) -> int:
        #f0表示连续1个栅栏颜色相同,f1表示连续两个栅栏颜色相同
        f0,f1=k,0
        #对于f0,只要和i-1位置颜色不同就行,i-1位置是一个连续或者两个连续都可以,因此f0=(f0+f1)*(k-1)
        #对于f1,只能和i-1位置颜色一样,且只能有两个连续,因此f1=f0
        for i in range(1,n):
            f0,f1=(f0+f1)*(k-1),f0
        return f0+f1
```

### 2.双序列

```python
#2361(https://leetcode.cn/problems/minimum-costs-using-the-train-line/)
class Solution:
    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        n=len(regular)
        ans=[]
        f0,f1=0,expressCost
        #f0表示到当前位置常规线的最小费用,f1表示到当前位置特快线的最小费用
        for x,y in zip(regular,express):
            f0,f1=min(f0+x,f1+y),min(f1+y,f0+x+expressCost)
            ans.append(min(f0,f1))
        return ans
```

## 8.序列dp

**序列dp往往与数值相关,因此往往和值域dp相结合(即状态表示的是数值而不是下标),当值域较大时,需要离散化,这时往往用哈希表代替普通的数组当作缓存表**

### 1.值域dp

```python
#1218(https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/)
class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        f=defaultdict(int)
        ans=0
        for x in arr:
            f[x]=max(f[x],f[x-difference]+1)
            ans=max(ans,f[x])
        return ans
```

### 2.类值域dp

**第一维是下标,第二维是数值**

```python
#446(https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/)
#其第一维用的是下标,第二维用的是值域,由于第二维是离散的,因此第二维用哈希表保存状态
#此题类似1027题,不过变成了求方案数,同时值域范围极大
#状态定义方式类似873题
#第一维度为什么用下标而不是值域,因为本题是求方案数,对于重复元素如果第二维度用值域很难处理,用下标就可以解决这个问题
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        ans=0
        #f[i][j]表示以nums[i]结尾公差为j的等差序列数量
        f=[defaultdict(int) for _ in nums]
        for i,x in enumerate(nums):
            for j in range(i):
                d=x-nums[j]
                #ans在f[i][d]之前更新,这保证了ans不会计入长度为2的等差数列
                #因为第i轮更新的f[i][d]至少要在k>=i+1轮才会被使用,这时这个数列因为加上了nums[k],长度一定>=3,满足题意
                ans+=f[j][d]
                #以nums[i]为结尾的等差数列由两部分构成
                    #1.以nums[j]结尾的等差数列拼上nums[i],这部分数量即为f[j][d]
                    #2.nums[j]和nums[i]这个长度为2的数列,这部分数量为1(注意这部分除了在i>0时一定存在,因为任意长度为2的序列都可以看作等差数列)
                f[i][d]+=f[j][d]+1
        return ans
```

## 9.区间dp

### 1.区间dp改迭代模版

```python
#3277(https://leetcode.cn/problems/maximum-xor-score-subarray-queries/)
class Solution:
    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n=len(nums)
        g=[[0]*n for _ in range(n)]
        #左端点对应变量倒序枚举,右端点对应变量正序从i+1枚举
        #i=j的情况进行特判
        for i in range(n-1,-1,-1):
            g[i][i]=nums[i]
            for j in range(i+1,n):
                g[i][j]=g[i][j-1]^g[i+1][j]
        f=[[0]*n for _ in range(n)]
        for i in range(n-1,-1,-1):
            f[i][i]=nums[i]
            for j in range(i+1,n):
                f[i][j]=max(f[i+1][j],f[i][j-1],g[i][j])
        return [f[i][j] for i,j in queries]
```

## 10.状压dp

### 1.排列型,相邻无关

**这种是最简单最常见的状压dp,时间复杂度为$O(n2^n)$**

**这种dp一般也可以用二分图匹配/二分图带权匹配(KM算法,匈牙利算法升级版)或者网络流算法(最大流/费用流)解决**

```python
#状压dp
class Solution:
    def countArrangement(self, n: int) -> int:
        u=(1<<n)-1
        @cache
        def f(s):
            if s==u:
                return 1
            i=s.bit_count()+1
            ans=0
            for j in range(1,n+1):
                if s>>(j-1)&1==0 and (j%i==0 or i%j==0):
                    ans+=f(s|1<<(j-1))
            return ans
        return f(0)
```

### 2.排列型,相邻相关

**在上面基础上多一个参数记录相邻位置信息,时间复杂度为$O(n^22^n)$**

### 3.子集状压dp

**时间复杂度$O(3^n)$**

#### 1.子集状压模版(注释版)

```python
#2305(https://leetcode.cn/problems/fair-distribution-of-cookies/)
max=lambda x,y:x if x>y else y
min=lambda x,y:x if x<y else y
class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        n=len(cookies)
        m=(1<<n)-1
        p=[0]*(m+1)
        #递推预处理子集和部分
        for i,x in enumerate(cookies):
            bit=1<<i
            for j in range(bit):
                p[bit|j]=p[j]+x
        #状压dp部分
        @cache
        def f(k,s):
            if k==0:
                return 0 if s==0 else inf
            ans=inf
            sub=s
            while sub:
                x=p[sub]
                ans=min(ans,max(x,f(k-1,s^sub)))
                sub=(sub-1)&s
            return ans
        return f(k,m)
```

#### 2.模版(纯净版)

```python
class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        n=len(cookies)
        m=(1<<n)-1
        p=[0]*(m+1)
        for i,x in enumerate(cookies):
            bit=1<<i
            for j in range(bit):
                p[bit|j]=p[j]+x
        @cache
        def f(k,s):
            if k==0:
                return 0 if s==0 else inf
            ans=inf
            sub=s
            while sub:
                x=p[sub]
                ans=min(ans,max(x,f(k-1,s^sub)))
                sub=(sub-1)&s
            return ans
        return f(k,m)
```

#### 3.预处理子集和

```python
t=len(quantity)
m=(1<<t)-1
p=[0]*(m+1)
for i,x in enumerate(quantity):
    bit=1<<i
    for j in range(bit):
        p[bit|j]=p[j]+x
```

#### 4.预处理子集的子集

**注意N较大时不要预处理子集的子集,可能爆空间**

```python
N=10
u=1<<N
subs=[[] for _ in range(u)]
for s in range(u):
    sub=s
    while sub:
        subs[s].append(sub)
        sub=(sub-1)&s
```

### 4.三进制状压dp

**当每个位置有三个状态时,需要使用三进制数,即每个位置有0,1,2三种状态,三进制数处理方式类似十进制数**

```python
#1931(https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/)
mod=1_000_000_007
class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        #预处理3的幂,因为3进制没有像2进制那样有位运算
        p=[3**i for i in range(m)]

        #sub记录有效的列的集合(即相邻上下颜色不能相同)
        subs=[]
        u=3**m #u-1为全集
        for sub in range(u):
            for i in range(1,m):
                #相邻颜色相同,break
                if sub//p[i]%3==sub//p[i-1]%3:
                    break
            else:
                #没有break就是合法的列
                subs.append(sub)
        nl=len(subs)
        ne=[[] for _ in range(nl)] #ne记录当前列的下一列可以取的状态,也是遵循相邻颜色(左右)不同
        for i,x in enumerate(subs):
            for j,y in enumerate(subs):
                for t in p:
                    if x//t%3==y//t%3:
                        break
                else:
                    ne[i].append(j)
        #f(i,s)表示第i+1列颜色状态是s的方案数
        @cache
        def f(i,j):
            if i==0:
                return 1
            return sum(f(i-1,k) for k in ne[j])%mod
        return sum(f(n-1,j) for j in range(nl))%mod
```

### 5.tuple型状压/分组值域状压

**对于python,这类题两种方法均可行,其他语言第一种需要自己实现tuple的哈希函数(比较繁琐),通常只能使用后者**

**tuple型状压**

```python
#1815(https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/)
class Solution:
    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:
        ans=0
        cnt=[0]*batchSize
        for x in groups:
            x%=batchSize
            if x==0:
                ans+=1
            #利用python负数下标消消乐
            elif cnt[-x]:
                cnt[-x]-=1
                ans+=1
            else:
                cnt[x]+=1
        @cache
        def f(pre,cnt):
            cnt=list(cnt)
            ans=0
            for j,x in enumerate(cnt):
                if x:
                    cnt[j]-=1
                    ans=max(ans,f((pre+(j+1))%batchSize,tuple(cnt))+(pre==0))
                    cnt[j]+=1
            return ans
        return f(0,tuple(cnt[1:]))+ans
```

**分组值域状压**

```python
class Solution:
    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:
        ans=0
        cnt=[0]*batchSize
        for x in groups:
            x%=batchSize
            if x==0:
                ans+=1
            elif cnt[-x]:
                cnt[-x]-=1
                ans+=1
            else:
                cnt[x]+=1
        v=[]
        s=0 #s即24位二进制数
        for i in range(1,batchSize):
            if cnt[i]:
                v.append(i)
                s=s<<5|cnt[i]
        v.reverse() #原地反转v,因为v和s顺序相反
        n=len(v)

        @cache
        def f(s):
            pre=s>>20
            s=s&((1<<20)-1)
            ans=j=0
            for i in range(n):
                if s>>j&31:
                    ans=max(ans,(pre==0)+f((pre+v[i])%batchSize<<20|s-(1<<j)))
                j+=5
            return ans
        return f(s)+ans
```



## 11.前缀和优化dp

### 1.列的前缀和

```python
#2478(https://leetcode.cn/problems/number-of-beautiful-partitions/)
#本题的前缀和更新方式较为特殊,表示的是列的前缀和,因此需要在一行更新结束后,同步更新每一列的前缀和
#如果为了方便,也可以将维度对调,用行表示约束个数k,用列表示遍历到字符的下标,这样更新的就是行的前缀和,更容易理解
mod=1_000_000_007
class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        #开头不是质数,直接返回0
        if s[0] not in '2357':
            return 0
        n=len(s)
        f=[[0]*(k+1) for _ in range(n+1)] #f[i+1][j]表示0...i范围划分成j个子段的方案数
        g=[[0]*(k+1) for _ in range(n+1)] #用g记录前缀和
        f[0][0]=g[0][0]=1
        for i in range(n):
            #每一个字段的最后一个元素必须不是质数且其下一个数字(即下一个字段的开头)必须是质数,同时特判结尾位置n-1
            if i-minLength+1>=0 and s[i] not in '2357' and (i==n-1 or s[i+1] in '2357'):
                for j in range(1,k+1):
                    f[i+1][j]=g[i-minLength+1][j-1]
            for j in range(k+1):
                g[i+1][j]=(g[i][j]+f[i+1][j])%mod
        return f[-1][-1]
```

### 2.式子变形

**此题本质是划分型dp+式子变形+前缀和优化dp**

````python
#3473(https://leetcode.cn/problems/sum-of-k-subarrays-with-length-at-least-m/)
class Solution:
    def maxSum(self, nums: List[int], K: int, m: int) -> int:
        n=len(nums)
        s=list(accumulate(nums,initial=0))
        f=[[-inf]*(n+1) for _ in range(K+1)]
        f[0]=[0]*(n+1)
        for k in range(1,K+1):
            # for i in range(k*m-1,n-(K-k)*m):
            #     mx=-inf
            #     for j in range((k-1)*m-1,i-m+1):
            #         mx=max(mx,f[k-1][j+1]+s[i+1]-s[j+1])
            #     f[k][i+1]=max(f[k][i],mx)

            #优化过程:本质是将第三重循环求max的过程预处理出来
            #f[k][i+1]=max(f[k][i],mx)
            #mx=max(f[k-1][j+1]-s[j+1])+s[i+1],(k-1)*m-1<=j<=i-m
            #而k*m-1<=i<=n-(K-k)*m-1
            #可以发现i的开头位置减去m = j的开头位置 = j的结束位置
            #由于mx开头位置固定,只有结尾位置变化,而结尾位置又和i的下标以差为m同步增长
            #因此可以在遍历i的同时,更新f[k][i+1-m]-s[i+1-m],即mx,这样更新下一行的k时,就不用第三重循环,直接调用mx即可
            mx=-inf
            for i in range(k*m-1,n-(K-k)*m):
                mx=max(mx,f[k-1][i-m+1]-s[i-m+1])
                f[k][i+1]=max(f[k][i],mx+s[i+1])
        return f[-1][-1]
````



```python
#3077(https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/)
class Solution:
    def maximumStrength(self, nums: List[int], K: int) -> int:
        pre=list(accumulate(nums,initial=0))
        n=len(nums)
        f=[[-inf]*(n+1) for _ in range(K+1)]
        f[0]=[0]*(n+1)
        for k in range(1,K+1):
            mx=-inf
            t=(K-k+1)*(1 if k&1 else -1)
            for i in range(k-1,n-(K-k)):
                mx=max(mx,f[k-1][i]-t*pre[i])
                f[k][i+1]=max(f[k][i],mx+t*pre[i+1])
        return f[-1][-1]
```

## 12.后缀优化dp

**后缀最大值优化dp,逻辑和前缀和优化dp类似**

```python
#3409(https://leetcode.cn/problems/longest-subsequence-with-decreasing-adjacent-difference/)
#二维值域dp+后缀最大值优化,第一维度第二维度均用值域定义
#用>=j代替具体的j,从而减少一层维度
MX=lambda x,y:x if x>y else y
class Solution:
    def longestSubsequence(self, nums: List[int]) -> int:
        mx,mn=max(nums),min(nums)
        n=mx-mn
        #f[i][j]表示以i结尾,后两个数的绝对差>=j的最长子序列的长度
        f=[[0]*(n+1) for _ in range(mx+1)]
        ans=0
        for x in nums:
            suf=1
            #倒序枚举,因为>=n是>=0的子集,相当于f[x][j]表示f[x]的[j...n]范围的最大值,即后缀最大值
            for j in range(n,-1,-1):
                #分倒数第二个数比倒数第一个数大j和小j两种情况考虑
                if x+j<=mx:
                    suf=MX(suf,f[x+j][j]+1)
                if x-j>=0:
                    suf=MX(suf,f[x-j][j]+1)
                ans=MX(ans,suf)
                f[x][j]=suf
        return ans
```

## 13.数学优化dp

**有些dp表面上看起来时间复杂度会超标,但是如果利用数学性质收缩其上界或者进行一定剪枝的话,就可以通过**

```python
#2188(https://leetcode.cn/problems/minimum-time-to-finish-the-race/description/)
#预处理+数学+dp
class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        #一个轮胎的最多使用次数t=log(changeTime+1)+1
        #changeTime最大为1e5,带入求出t最多为17,即一个轮胎最多使用17圈

        #预处理跑x圈的最少时间,通过遍历所有轮胎求出
        mn=[inf]*18
        for f,r in tires:
            x,t,s=1,f,0 #x代表当前是第几圈(x从1开始),t代表当前圈时间,s代表总时间
            while t<=changeTime+f:
                s+=t
                mn[x]=min(mn[x],s)
                t*=r
                x+=1
        #f[i]表示跑i圈需要的最短时间
        f=[0]*(numLaps+1)
        f[0]=-changeTime #f[0]初始化成这个,因为第一圈不需要换轮胎的时间
        for i in range(1,numLaps+1):
            #f[i]等于f[i-j]加上一个轮胎连续跑了j圈的时间+换轮胎时间changeTime
            f[i]=changeTime+min(f[i-j]+mn[j] for j in range(1,min(i+1,18)))
        return f[-1]      
```

## 14.矩阵快速幂优化dp

$k\times k的矩阵利用矩阵快速幂计算其N次幂的时间复杂度是O(k^3logN)$

$因为矩阵中总共有k^2个数,而矩阵乘法计算出每个数的时间复杂度是k,合计k^3,快速幂的时间复杂度是logN$

**矩阵快速幂有两种写法:**

**1.一种是初始矩阵为行向量,不断右乘关系矩阵,转移方程系数对应关系矩阵的列**

**2.另一种是初始矩阵为列向量,不断左乘关系矩阵,转移方程系数对应关系矩阵的行**

**注意:如果没有特殊说明,我们默认均使用行向量**

### 1.矩阵快速幂模版

#### 1a.矩阵快速幂手写矩阵乘法模版(注释版)

```python
#矩阵乘法,计算矩阵a和b的乘积
def multiply(a,b):
    #模拟矩阵乘法
    return [[sum(x*y for x,y in zip(row,col)) for col in zip(*b)] for row in a]
#矩阵快速幂:求矩阵a的p次幂,a是nxn方阵,原理和乘法快速幂类似,res是初始项矩阵
def power(a,p,res):
    while p:
        if p&1:
            res=multiply(res,a)
        a=multiply(a,a)
        p>>=1
    return res

#用法,已知第1项和第0项,求第n项
base=[[1,1],[1,0]]
return power(base,n-1,[[1,1]])[0][0]
```

#### 1b.矩阵快速幂手写矩阵乘法模版(纯净版)

```python
def multiply(a,b):
    return [[sum(x*y for x,y in zip(row,col)) for col in zip(*b)] for row in a]
def power(a,p,res):
    while p:
        if p&1:
            res=multiply(res,a)
        a=multiply(a,a)
        p>>=1
    return res

base=[[1,1],[1,0]]
return power(base,n-1,[[1,1]])[0][0]
```

#### 1c.矩阵快速幂手写矩阵乘法取模模版(纯净版)

**这个模版就是在1b的基础上,在计算矩阵乘法时加一个取模操作**

```python
def multiply(a,b):
    return [[sum(x*y for x,y in zip(row,col))%mod for col in zip(*b)] for row in a]
def power(a,p,res):
    while p:
        if p&1:
            res=multiply(res,a)
        a=multiply(a,a)
        p>>=1
    return res

base=[[1,1],[1,0]]
return power(base,n-1,[[1,1]])[0][0]
```

#### 2a.矩阵快速幂+numpy模版(注释版)

```python
import numpy as np
#res表示初始项矩阵
def power(a,p,res):
    while p:
        if p&1:
            #@表示numpy中矩阵乘法
            res=res@a
        a=a@a
        p>>=1
    return res

#用法
#需要创建numpy矩阵,注意关系矩阵书写是一行一行的
base=np.array([[1,1],[1,0]],dtype=object)
return (power(base,n-1,np.array([[1,1]],dtype=object)))[0][0]
```

#### 2b.矩阵快速幂+numpy模版(纯净版)

```python
import numpy as np
def power(a,p,res):
    while p:
        if p&1:
            res=res@a
        a=a@a
        p>>=1
    return res

base=np.array([[1,1],[1,0]],dtype=object)
return (power(base,n-1,np.array([[1,1]],dtype=object)))[0][0]
```

#### 2c.矩阵快速幂+numpy取模模版(纯净版)

```py
import numpy as np
def power(a,p,res):
    while p:
        if p&1:
            res=res@a%mod
        a=a@a%mod
        p>>=1
    return res

base=np.array([[1,1],[1,0]],dtype=object)
return (power(base,n-1,np.array([[1,1]],dtype=object)))[0][0]
```

### 2.固定关系的1维k阶递推表达式

对于形如$a_{n+1}=c_{k-1}a_n+c_{k-2}a_{n-1}+...+c_0a_{n-k+1}的递推式$

如果$S_n=[a_n,a_{n-1},...,a_{n-k+1}],则必有S_{n+1}=S_nT$

![avatar](/Users/kaosdragon/Documents/算法/pictures/matrix.png)

对于斐波那契数列,有$[a_1,a_0]*[[1,1],[1,0]]=[a_2,a_1]...后面以此类推$

```python
#模版题1137(https://leetcode.cn/problems/n-th-tribonacci-number/)
#对应即为1维3阶递推表达式
import numpy as np
def power(a,p,res):
    while p:
        if p&1:
            res=res@a
        a=a@a
        p>>=1
    return res
class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:
            return 0
        elif n==1:
            return 1
        base=np.array([[1,1,0],[1,0,1],[1,0,0]],dtype=object)
        return (power(base,n-2,np.array([[1,1,0]],dtype=object)))[0][0]
```

### 3.固定关系的k维1阶递推表达式

即有k个方程,同时等式右边有k个参数,关系矩阵的每一列即为每个方程对应的系数

比如对于方程组:a,e,i,o,u=e+i+u,a+i,e+o,i,i+o,矩阵的第一列为0,1,1,0,1,第二列为1,0,1,0,0,...以此类推

```python
#模版题1220(https://leetcode.cn/problems/count-vowels-permutation/)
mod=1_000_000_007
import numpy as np
def power(a,p,res):
    while p:
        if p&1:
            res=res@a%mod
        a=a@a%mod
        p>>=1
    return res
class Solution:
    def countVowelPermutation(self, n: int) -> int:
        a=e=i=o=u=1
        #2～n进行递推
        #根据上面的方法,我们有 a,e,i,o,u=e+i+u,a+i,e+o,i,i+o
        #可得到关系矩阵
        base=np.array([[0,1,0,0,0],[1,0,1,0,0],[1,1,0,1,1],[0,0,1,0,1],[1,0,0,0,0]],dtype=object)
        #调用矩阵快速幂,将结果求和取模即可
        return np.sum((power(base,n-1,np.array([[1,1,1,1,1]],dtype=object)))[0])%mod
```

### 4.特殊初始化情况

**对于k维一阶递推式,如果初始状态有权值,即某个状态有多个数,那么有以下两种初始化方法**

#### 1.无权初始化

**无权初始化时,初始矩阵为全1,关系矩阵的每一列对应转移方程的系数**

```python
#3337(https://leetcode.cn/problems/total-characters-in-string-after-transformations-ii/)
#写法1:无权初始化
#计算每种字母转化次后的长度,最后根据s中每种字母的数量(即权值)计算出答案
mod=1_000_000_007
import numpy as np
def power(a,p,res):
    while p:
        if p&1:
            res=res@a%mod
        a=a@a%mod
        p>>=1
    return res
class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
        base=[[0]*26 for _ in range(26)]
        for i,x in enumerate(nums):
            for j in range(i+1,i+x+1):
                base[j%26][i]=1
        base=np.array(base,dtype=object)
        #res[i]表示字母i经过t次处理后的长度
        #最后答案即为sum(res[c]*cnt[c]),c为s中的字母
        res=(power(base,t,np.array([[1]*26],dtype=object)))[0]
        return sum(res[ord(x)-ord('a')]*y for x,y in Counter(s).items())%mod
```

#### 2.带权初始化

**带权初始化时,初始矩阵为每个状态的权值(个数),关系矩阵的每一行对应转移方程的系数**

内在原理:

在下面的题目中,我们在关系矩阵base的第i行记录第i个字母替换后可能变成的字母,base\[i]\[j]=1表示字母i可以转移到字母j,设原始的行向量为S,令$S\times base=T$,那么T也必然是行向量,T[i]表示26个字母所能转化成的所有字母i的数量之和.换句话说是多个状态的汇总,即$T[i]=\displaystyle\sum_{j=0}^{25}c[j][i]$

也可以从另一个角度理解,这个base的第i列也表示了哪些字母可以转移到i

带权初始化,本质是从过去到当前的过程,即填表法

与之相对的,无权初始化,代表的是从当前到未来的过程,即刷表法

同时本题中必须把向量整体作为一个变量看待

```python
#3337(https://leetcode.cn/problems/total-characters-in-string-after-transformations-ii/)
#写法2,带权初始化
mod=1_000_000_007
import numpy as np
def power(a,p,res):
    while p:
        if p&1:
            res=res@a%mod
        a=a@a%mod
        p>>=1
    return res
class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
        base=[[0]*26 for _ in range(26)]
        for i,x in enumerate(nums):
            for j in range(i+1,i+x+1):
                base[i][j%26]=1
        base=np.array(base,dtype=object)
        cnt=Counter(s)
        arr=np.array([[cnt[c] for c in ascii_lowercase]],dtype=object)
        return np.sum(power(base,t,arr))%mod
```

## 15.状态转化dp

**某些时候参数j的值域范围可能较大,而且还不好离散化,将其作为dp参数会超时,这时可以将j作为返回值,另一个参数替换成一个可枚举同时范围较小的参数,同时一旦发现答案就立刻返回,有点像最优性剪枝**

**这类dp也常常表现为显示地枚举所有状态求最值**

**示例1**

```py
#887(https://leetcode.cn/problems/super-egg-drop/)
#多维dp+逆向思维,反向定义状态
#这种解法严格来说是数学优化dp
#有i次机会,k枚鸡蛋的情况下可以确定的建筑物的最大高度
@cache
def f(i,k):
    if i==0 or k==0:
        return 0
    return f(i-1,k-1)+f(i-1,k)+1
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        for i in count(1): #返回从1开始的无限迭代器
            if f(i,k)>=n:
                return i
```

**示例2**

```python
#1883(https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/)
#多维dp
#状态定义类似887高楼扔鸡蛋,同时还要用手法处理浮点数除法精度问题

#本题有以下几个难点
#1.如果在记忆化搜索中用dist下标i和累积消耗时间t作为参数的话,t范围过大会超时
#2.因此需要用跳过次数j做参数,求出不同j下的最少时间t,然后从0开始枚举j,找出最小的j使得t<hoursBefore
#3.但是因为本题用到浮点数除法,存在精度问题,为了规避这一点,可以转为求t*speed,即最小时间对应的距离,规避精度问题
min=lambda x,y:x if x<y else y
class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        #可行性剪枝,如果总距离>时间*速度,返回-1
        if sum(dist)>hoursBefore*speed:
            return -1
        n=len(dist)
        #0...i跳过j次所需的最短时间*速度
        @cache
        def f(i,j):
            #边界
            if i==-1:
                return 0
            #不跳过i,用(0~i-1位置的距离+当前距离)/speed向上取整,再乘上speed
            ans=(f(i-1,j)+dist[i]+speed-1)//speed*speed
            #如果剩余跳过次数j>0,就跳过,直接用0~i-1距离加上当前距离dist[i]
            if j:
                ans=min(ans,f(i-1,j-1)+dist[i])
            return ans
        #从0开始枚举,由于开头已经进行剪枝,因此最多跳过n-1次(最后一次不需要跳过)
        for j in count(0):
            #由于第n-1之后不需要再走了,因此最后一个位置不需要跳过,直接用f(n-2,j)+dist[-1]和总距离比较
            if f(n-2,j)+dist[-1]<=hoursBefore*speed:
                return j
```

**示例3**

```python
#3018(https://leetcode.cn/problems/maximum-number-of-removal-queries-that-can-be-processed-i/)
#区间dp
#本题必须使用迭代,记忆化搜索会爆空间
#常规区间dp是由内到外递推,即l从n-1到0,r从l到n-1
#而本题是由外到内递推,即l从0到n-1,r从n-1到l,正好和常规区间dp递推顺序相反
max=lambda x,y:x if x>y else y
class Solution:
    def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -> int:
        n=len(nums)
        m=len(queries)
        #状态定义采用左闭右开区间,因为如果用闭区间的话无法表示空区间的情况
        #f[l][r]表示将nums变成[l,r)的最多次数
        #初始时刻f[0][n]=0,因为将nums变成[0,n)(即nums自身)的次数只能是0
        f=[[0]*(n+1) for _ in range(n)]
        ans=0 #ans记录全局最大值,当最大值等于m时直接返回
        for l in range(n):
            for r in range(n,l-1,-1):
                if l:
                    i=f[l-1][r]#通过f[l-1][r]得知当前quries遍历到哪个下标
                    #去除左边,如果>=queries[i]就次数+1,否则将其算入最开始子序列替换
                    f[l][r]=max(f[l][r],i+(1 if nums[l-1]>=queries[i] else 0))
                if r<n:
                    i=f[l][r+1]
                    #去除右边,和上面同理
                    f[l][r]=max(f[l][r],i+(1 if nums[r]>=queries[i] else 0))
                ans=max(ans,f[l][r])
                #最优性剪枝,因为ans不可能比m还大
                if ans==m:
                    return ans
        return ans
```



## 16.特殊定义dp

### 1.游离型dp

```py
#3469(https://leetcode.cn/problems/find-minimum-cost-to-remove-array-elements/)
#本题最巧妙的地方在于初始化从1开始,这样游离下标就是0,可以减少很多边界讨论
max=lambda x,y:x if x>y else y
class Solution:
    def minCost(self, nums: List[int]) -> int:
        n=len(nums)
        #pre记录游离元素的下标
        @cache
        def f(pre,i):
            if i==n-1:
                return max(nums[pre],nums[i])
            if i==n:
                return nums[pre]
            #考虑三种情况(最外面的括号用来续行)
            return (min(f(i+1,i+2)+max(nums[pre],nums[i]),#移除pre和i,游离i+1
                       f(i,i+2)+max(nums[pre],nums[i+1]),#移除pre和i+1,游离i
                       f(pre,i+2)+max(nums[i],nums[i+1])))#移除i和i+1,游离pre
        ans=f(0,1)
        f.cache_clear()
        return ans
```



```python
#546(https://leetcode.cn/problems/remove-boxes/)
class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        #f(l,r,k)代表l,r范围加上右边等于boxes[r]的k个元素组成的序列的最大积分
        @cache
        def f(l,r,k):
            if l>r:
                return 0
            #结算右边离散部分
            ans=f(l,r-1,0)+(k+1)*(k+1)
            #不接算,寻求增加右边离散部分长度
            for i in range(l,r):
                if boxes[i]==boxes[r]:
                    ans=max(ans,f(l,i,k+1)+f(i+1,r-1,0))
            return ans
        return f(0,len(boxes)-1,0)
```



# 2.字典树/前缀树(Trie)

## 1.普通字典树

### 1.模版1a

```python
#基于defaultdict实现,这种写法最简洁
trie=lambda:defaultdict(trie) 
class Trie:
    def __init__(self):
        self.root=trie()

    def insert(self,word):
        p=self.root
        for c in word:
            p=p[c]
        p['#']=True

    def search(self, word: str) -> bool:
        p=self.root
        for c in word:
            if c not in p:
                return False
            p=p[c]
        return p.get('#')
```

### 2.模版1b

```python
#基于结构体+defaultdict实现,可以适应一些特殊情况
class Trie:
    __slots__='son','end'

    def __init__(self):
        self.son=defaultdict(Trie)
        self.end=False
    def insert(self,word):
        p=self
        for c in word:
            p=p.son[c]
        p.end=True
    def search(self,word):
        p=self
        for c in word:
            if c not in p.son:
                return False
            p=p.son[c]
        return p.end
```

### 3.模版1c

```python
#基于结构体+哈希表实现,这种可以在结构体中记录额外信息,更灵活
class Node:
    __slots__='son','end'

    def __init__(self):
        self.son={}
        self.end=False

class Trie:
    def __init__(self):
        self.root=Node()

    def insert(self,word):
        p=self.root
        for c in word:
            if c not in p.son:
                p.son[c]=Node()
            p=p.son[c]
        p.end=True
        
    def search(self,word):
        p=self.root
        for c in word:
            p=p.son[c]
            if not p.end:
                return False
        return p.end
```

### 4.模版2

```python
#基于数组实现,这种构建的字典树原始就满足字典序,处理字典序相关题目,更简单
class Node:
    __slots__='son','end'

    def __init__(self):
        self.son=[None] * 26
        self.end=False

class Trie:
    def __init__(self):
        self.root = Node()

    def insert(self,word):
        p=self.root
        for c in word:
            c=ord(c)-ord('a')
            if not p.son[c]:
                p.son[c]=Node()
            p=p.son[c]
        p.end=True

    def search(self,word):
        p=self.root
        for c in word:
            p=p.son[ord(c)-ord('a')]
            if not p.end:
                return False
        return True
```



```python
#模版题:208(https://leetcode.cn/problems/implement-trie-prefix-tree/description/)
trie=lambda:defaultdict(trie) 
class Trie:
    def __init__(self):
        self.root=trie()
    
    def insert(self, word: str) -> None:
        p=self.root
        for c in word:
            p=p[c]
        p['#']=True

    def search(self, word: str) -> bool:
        p=self.root
        for c in word:
            if c not in p:
                return False
            p=p[c]
        return True if p['#'] else False

    def startsWith(self, prefix: str) -> bool:
        p=self.root
        for c in prefix:
            if c not in p:
                return False
            p=p[c]
        return True
```



```python
#应用:2416(https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/)
class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        #字典树本质是26叉树
        trie=lambda:defaultdict(trie) #递归建树,无参lambda函数
        root=trie()
        for word in words:
            p=root #p每次从树根开始
            for c in word:
                p=p[c] #递归建树
                p['#']=p.get('#',0)+1 #用'#'标记以某个前缀结尾的字符串的数量
        ans=[]
        for word in words:
            p,score=root,0 #cnt记录分数
            for c in word:
                p=p[c]
                score+=p['#']
            ans.append(score)
        return ans
```



```python
#应用:字典树求最大深度解决最长公共前缀问题
#14(https://leetcode.cn/problems/longest-common-prefix/description/)
#字典树+树型dp求最大深度
trie=lambda:defaultdict(trie) 
class Trie:
    def __init__(self):
        self.root=trie()
        
    def insert(self, word: str):
        p=self.root
        for c in word:
            p=p[c]
        p['#']=True
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        t=Trie()
        for word in strs:
            t.insert(word)  
        def f(root,depth):
            if len(root)>1 or '#' in root:
                return depth
            return max(f(root[x],depth+1) for x in root)
        return strs[0][:f(t.root,0)]
```



```python
#应用:677(https://leetcode.cn/problems/map-sum-pairs/)
#字典树求前缀
class MapSum:

    def __init__(self):
        self.t=Trie()

    def insert(self, key: str, val: int) -> None:
        self.t.insert(key,val)

    def sum(self, prefix: str) -> int:
        n=len(prefix)
        def f(root,i):
            if i<n:
                return 0 if prefix[i] not in root else f(root[prefix[i]],i+1)
            return sum(root[x] if x=='#' else f(root[x],i+1) for x in root)
        return f(self.t.root,0)

#字典树
trie=lambda:defaultdict(trie) 
class Trie:
    def __init__(self):
        self.root=trie()
        
    def insert(self,word,val):
        p=self.root
        for c in word:
            p=p[c]
        p['#']=val
```



```python
#此题另一种类似结构体的写法
class MapSum:
    def __init__(self):
        self.t=Trie()
        self.d={}
    def insert(self, key: str, val: int) -> None:
        diff=val
        if key in self.d:
            diff-=self.d[key]
        self.d[key]=val
        self.t.insert(key,diff)
    def sum(self, prefix: str) -> int:
        p=self.t.root
        for c in prefix:
            if c not in p.son:
                return 0
            p=p.son[c]
        return p.val

class Node:
    __slots__ = 'val','son'

    def __init__(self):
        self.val=0
        self.son={}

class Trie:
    def __init__(self):
        self.root=Node()
        self.d={}
    def insert(self,word,val):
        p=self.root
        for c in word:
            if c not in p.son:
                p.son[c]=Node()
            p=p.son[c]
            p.val+=val
```

## 2.字典序处理

### 1.模版1

**有序字典树**

```python
#有序字典树,结构体+SortedDict
class Node:
    __slots__='son','end'

    def __init__(self,end=False):
        self.son=SortedDict()
        self.end=end

class Trie:
    def __init__(self):
        self.root=Node(True) #为了简化处理,需要将根节点的end置为True

    def insert(self,word):
        p=self.root
        for c in word:
            if c not in p.son:
                p.son[c]=Node()
            p=p.son[c]
        p.end=True
```

### 2.模版2

**数组字典树(自带有序)**

```python
#数组字典树,比上面的写法更快
class Node:
    __slots__='son','end'

    def __init__(self):
        self.son=[None] * 26
        self.end=False

class Trie:
    def __init__(self):
        self.root = Node()
        self.root.end=True

    def insert(self,word):
        p=self.root
        for c in word:
            c=ord(c)-ord('a')
            if not p.son[c]:
                p.son[c]=Node()
            p=p.son[c]
        p.end=True
```

## 3.01字典树

```python
class Node:
    __slots__='children','cnt'
    
    def __init__(self):
        self.children=[None,None]
        self.cnt=0
class Trie:
    HIGH_BIT=19
    def __init__(self):
        self.root=Node()
    def insert(self,val):
        cur=self.root
        for i in range(Trie.HIGH_BIT,-1,-1):
            bit=(val>>i)&1
            if cur.children[bit] is None:
                cur.children[bit]=Node()
            cur=cur.children[bit]
            cur.cnt+=1
        return cur
    def remove(self,val):
        cur=self.root
        for i in range(Trie.HIGH_BIT,-1,-1):
            cur=cur.children[(val>>i)&1]
            cur.cnt-=1
        return cur
    def max_xor(self,val):
        cur=self.root
        ans=0
        for i in range(Trie.HIGH_BIT,-1,-1):
            bit=(val>>i)&1
            #是0查1,是1查0
            if cur.children[bit^1] and cur.children[bit^1].cnt:
                ans|=1<<i
                bit^=1
            cur=cur.children[bit]
        return ans
```



# 3.并查集

## 1.普通并查集

### 1.标准并查集

```python
# 带标签和返回值的并查集,存储形式为数组
class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.cc = n

    def separate(self, x, y):
        self.father[x], self.father[y] = x, y
        self.cc += 1
```

```python
#separate操作应用示例
#2092(https://leetcode.cn/problems/find-all-people-with-secret/)
#将同一时刻的专家进行合并,然后如果发现某个会议的专家所在集合的代表元和0号专家的不一致,就撤销合并操作
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        d=defaultdict(list)
        for x,y,z in meetings:
            d[z].append((x,y))
        arr=sorted(d.items())
        u=UnionFind(n)
        u.union(0,firstPerson)
        for t,x in arr:
            for a,b in x:
                u.union(a,b)
            for a,b in x:
                if u.find(a)!=u.find(0):
                    u.separate(a,b)
        return [i for i in range(n) if u.find(i)==u.find(0)]
        

# 带标签和返回值的并查集,存储形式为数组
class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.cc = n

    def separate(self, x, y):
        self.father[x], self.father[y] = x, y
        self.cc += 1
```

### 2.按秩合并并查集(递归实现)

```python
# 按秩合并,带标签和返回值的并查集,存储形式为数组,find函数用递归实现
class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.size = [1] * n
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        if self.size[fx] >= self.size[fy]:
            self.size[fx] += self.size[fy]
            self.father[fy] = fx
        else:
            self.size[fy] += self.size[fx]
            self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.size = [1] * n
        self.cc = n
```

### 3.字符并查集(用于处理字符类型)

```python
# 字符并查集
from string import ascii_lowercase

class UnionFind:
    def __init__(self):
        self.father = {x: x for x in ascii_lowercase}

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        return True

```

### 4.哈希并查集(用于处理字符串)

```python
#哈希并查集
#哈希并查集初始化方法见下面示例
class UnionFind:
    def __init__(self):
        self.father = {}

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        return True


# 哈希并查集初始化方法,可以边插入边合并,不过需要判断key是否在哈希表中
similarPairs=[]
u = UnionFind()
for x, y in similarPairs:
    if x not in u.father:
        u.father[x] = x
    if y not in u.father:
        u.father[y] = y
    u.union(x, y)
```

### 5.字典序并查集

```python
# 字典序并查集(按秩合并时把字典序充当秩)
# 按秩合并时把字典序充当秩
from string import ascii_lowercase

class UnionFind:
    def __init__(self):
        self.father = {x: x for x in ascii_lowercase}

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        if fx > fy:
            self.father[fx] = fy
        else:
            self.father[fy] = fx
        return True
```

```python
#应用:1061(https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/)
#并查集+按秩合并
class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        u=UnionFind()
        for x,y in zip(s1,s2):
            u.union(x,y)
        return ''.join([u.find(x) for x in baseStr])


class UnionFind:
    def __init__(self):
        self.father={x:x for x in ascii_lowercase}
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
    #利用标准并查集模版按秩合并思想,此题中的秩不再是集合大小,而是集合代表元的字典序大小
    #总是选取字典序小的字母充当合并后集合的代表元
    def union(self,x,y):
        fx,fy=self.find(x),self.find(y)
        if fx>fy:
            self.father[fx]=fy
        else:
            self.father[fy]=fx
```

## 2.数组上的并查集

```python
#应用:2382(https://leetcode.cn/problems/maximum-segment-sum-after-removals/)
#数组上的并查集
max=lambda x,y:x if x>y else y
class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n=len(nums)
        u=UnionFind(n+1)
        sums=[0]*(n+1)
        ans=[0]*n
        for i in range(n-1,0,-1):
            x=removeQueries[i]
            fx=u.find(x+1) #由于数组的链式性质,新遍历到的x的代表元一定是它自己,因此合并时只需要查找x+1的代表元
            u.father[x]=fx
            sums[fx]+=sums[x]+nums[x]
            ans[i-1]=max(ans[i],sums[fx])
        return ans
        
class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
```

# 4.栈
## 1.单调栈

单调递增栈有两种写法,横看成岭侧成峰

口诀:及时去掉无用数据,保证栈中元素有序.

这里拿单调递增栈举例:

正向遍历是将没有找到更大的数存在栈里面,然后遇到一个比栈顶元素大的数,就把栈中比它小的数弹出,同时更新这些数的答案.

反向遍历是将更大的数存在栈里面,然后遇到>=栈顶元素的数,就对栈进行弹出,直到栈顶元素大于这个数,弹出操作结束后,如果栈不为空,那么栈顶元素就是当前数右侧最近最大的数.

使用时不要照抄照搬,应该根据题目要求灵活修改,因为比较复杂的题目,都是要在基础的单调栈模版基础上进行一定变换或者修改,照搬模版是行不通的,理解原理才是更重要的.

### 1a.单调递增栈(右侧最近大于当前数的位置)

**写法1,正向遍历(注释版)**

```python
#模版题:739(https://leetcode.cn/problems/daily-temperatures/)
#单调递增栈,正向遍历
#弹出时更新答案
def monotonic_stack(arr):
    n=len(arr)
    #right[i]表示下标i右侧最近最大的数的下标,如果为默认值-1说明右侧不存在这样的数
    right=[-1]*n
    st=[] #单调递增栈(从栈顶到栈底单调递增),栈中存放的是元素下标
    for i,t in enumerate(arr):
        #如果当前遍历的值大于栈顶的值,将栈顶元素j弹出,同时更新right[j]=i
        while st and t>arr[st[-1]]:
            right[st.pop()]=i
        st.append(i)
    return right #最后返回right数组
```

**写法1,正向遍历(纯净版)**

```python
def monotonic_stack(arr):
    n=len(arr)
    right=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t>arr[st[-1]]:
            right[st.pop()]=i
        st.append(i)
    return right
```

**写法2,反向遍历(注释版)**

```python
#单调递增栈,反向遍历
#弹出结束后更新答案
def monotonic_stack(arr):
    n=len(arr)
    #right[i]表示下标i右侧最近最大的数的下标,如果为默认值-1说明右侧不存在这样的数
    right=[-1]*n
    st=[]#单调递增栈(从栈顶到栈底单调递增),栈中存放的是元素下标
    #倒序遍历
    for i in range(n-1,-1,-1):
        #如果当前遍历的值>=栈顶元素值,栈顶元素弹出
        while st and arr[i]>=temperatures[st[-1]]:
            st.pop()
        #如果此时栈不为空,更新right[i]为栈顶元素下标
        if st:
            right[i]=st[-1]
        st.append(i)
    return right
```

**写法2,反向遍历(纯净版)**

```python
def monotonic_stack(arr):
    n=len(arr)
    right=[-1]*n
    st=[]
    for i in range(n-1,-1,-1):
        while st and arr[i]>=temperatures[st[-1]]:
            st.pop()
        if st:
            right[i]=st[-1]
        st.append(i)
    return right
```

### 1b.单调递增栈(右侧最近大于等于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    right=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t>=arr[st[-1]]:
            right[st.pop()]=i
        st.append(i)
    return right
```

### 1c.单调递增栈(左侧最近大于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    left=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t>=arr[st[-1]]:
            st.pop()
        if st:
            left[i]=st[-1]
        st.append(i)
    return left
```

### 1d.单调递增栈(左侧最近大于等于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    left=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t>arr[st[-1]]:
            st.pop()
        if st:
            left[i]=st[-1]
        st.append(i)
    return left
```

### 2a.单调递减栈(右侧最近小于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    right=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t<arr[st[-1]]:
            right[st.pop()]=i
        st.append(i)
    return right
```

### 2b.单调递减栈(右侧最近小于等于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    right=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t<=arr[st[-1]]:
            right[st.pop()]=i
        st.append(i)
    return right
```

### 2c.单调递减栈(左侧最近小于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    left=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t<=arr[st[-1]]:
        	st.pop()
        if st:
            left[i]=st[-1]
        st.append(i)
    return left
```

### 2d.单调递减栈(左侧最近小于等于当前数的位置)

```python
def monotonic_stack(arr):
    n=len(arr)
    left=[-1]*n
    st=[]
    for i,t in enumerate(arr):
        while st and t<arr[st[-1]]:
        	st.pop()
        if st:
            left[i]=st[-1]
        st.append(i)
    return left
```

## 2.对顶栈

# 5.单调队列

## 1a.单调递减队列(队头维护滑动窗口最大值)

**单调队列=滑动窗口+单调栈**

单调队列的维护由三步构成:

1.维护队列单调性,将小于等于/大于等于当前元素的队列元素从队尾弹出,之后将当前元素加入队列

2.根据滑动窗口更新条件弹出队首元素

3.更新答案

可以看出单调队列和滑动窗口高度相关,每道题滑动窗口的更新情况不尽相同,因此这里不做深度封装

**1.注释版**

```python
#模版题:239(https://leetcode.cn/problems/sliding-window-maximum/description/)
ans=[]
q=deque()
for r,x in enumerate(nums):
    #维护单调递减队列
    while q and nums[q[-1]]<=x:
        q.pop()
    #加入当前元素
    q.append(r)
    #根据滑动窗口更新条件弹出队首元素
    if r-q[0]==k:
        q.popleft()
    #更新答案
    if r>=k-1:
        ans.append(nums[q[0]])
```

**2.纯净版**

```python
ans=[]
q=deque()
for r,x in enumerate(nums):
    while q and nums[q[-1]]<=x:
        q.pop()
    q.append(r)
    if r-q[0]==k:
        q.popleft()
    if r>=k-1:
        ans.append(nums[q[0]])
```

# 6.堆

## 1.懒删除堆

```python
class Heap:
    def __init__(self):
        self.heap=[]
        self.cnt=defaultdict(int)
        self.size=0
    def apply_remove(self):
        while self.heap and self.cnt[self.heap[0]]>0:
            self.cnt[self.heap[0]]-=1
            heappop(self.heap)
    def remove(self,x):
        self.cnt[x]+=1
        self.size-=1
    def push(self,x):
        if self.cnt[x]>0:
            self.cnt[x]-=1
        else:
            heappush(self.heap,x)
        self.size+=1
    def pop(self):
        self.apply_remove()
        self.size-=1
        return heappop(self.heap)
    def top(self):
        self.apply_remove()
        return self.heap[0]
    def pushpop(self,x):
        self.apply_remove()
        return heappushpop(self.heap,x)
```

## 2.对顶堆



# 7.树状数组

## 1.经典树状数组

**注意,有些时候可以用名次树SortedList代替树状数组**

```python
#线段树的思想是:把区间表示成若干区间的并集
#树状数组的思想是:把区间表示成两个前缀区间的差集
#前缀区间又可以表示成若干个区间的并集
#树状数组不好处理max问题
#通过不断加lowbit可以更新父节点
```

### 1a.模版(注释版)

```python
#动态维护arr的前缀和
#树状数组下标从1开始
class BIT:
    def __init__(self,n):
        self.tree=[0]*(n+1)
        self.n=n
    def add(self,i,val):
        while i<self.n+1:
            self.tree[i]+=val
            i+=i&-i
    #返回树状数组下标1~i范围内累加和
    def pre(self,i):
        res=0
        while i:
            res+=self.tree[i]
            i&=i-1
        return res
	#返回树状数组下标l~r范围内累加和
    def query(self,l,r):
        if r<l:
            return 0
        return self.pre(r)-self.pre(l-1)
```

### 1b.模版(纯净版)

```py
class BIT:
    def __init__(self,n):
        self.tree=[0]*(n+1)
        self.n=n
    def add(self,i,val):
        while i<self.n+1:
            self.tree[i]+=val
            i+=i&-i
    def pre(self,i):
        res=0
        while i:
            res+=self.tree[i]
            i&=i-1
        return res
    def query(self,l,r):
        if r<l:
            return 0
        return self.pre(r)-self.pre(l-1)
```

```python
#应用:307(https://leetcode.cn/problems/range-sum-query-mutable/)
#树状数组解法
class NumArray:
    def __init__(self, nums: List[int]):
        self.bit=BIT(nums)
    def update(self, index: int, val: int) -> None:
        self.bit.add(index,val)
    def sumRange(self, left: int, right: int) -> int:
        return self.bit.query(right+1)-self.bit.query(left)

#树状数组
class BIT:
    def __init__(self,n):
        self.nums=[0]*n
        self.tree=[0]*(n+1)
        self.n=n
        for i,x in enumerate(nums):
            self.add(i,x)
    def add(self,i,val):
        diff=val-self.nums[i]
        self.nums[i]=val
        i+=1
        while i<self.n+1:
            self.tree[i]+=diff
            i+=i&-i
    def query(self,i):
        s=0
        while i:
            s+=self.tree[i]
            i&=i-1
        return s
```



## 2.权值树状数组

## 3.树状数组维护不可差分信息



# 8.线段树

## 1.普通线段树(单点修改线段树)

### 1a.包含建树,将某个点的值修改,维护累加和信息(注释版)

```python
# 单点修改范围查询线段树,包含建树,维护的信息是区间累加和
class SegmentTree:
    # 初始化线段树,nums为输入数组,线段树下标从1开始,nums下标从0开始
    # 如果原数组有n个元素,那么线段树需要容纳4n-1个元素,因为线段树下标从1开始,因此开长度为4n的数组刚好够
    def __init__(self, nums):
        self.n = len(nums)
        self._tree = [0] * (self.n << 2)  # 4n空间
        self._build(1, self.n, 1, nums)

    # 单点修改时的情况,常见的有=(直接修改),+=(增量修改),max/min(和原来值比较求最大/最小),也可能是更复杂的逻辑,需要根据实际情况修改
    def _alter(self, o, val):
        self._tree[o] = val

    # 合并答案,常见的有+,-,max,min,也可能是更复杂的逻辑,需要根据实际情况修改
    def _merge(self, a, b):
        return a + b

    # 合并左右子树
    def _maintain(self, o):
        self._tree[o] = self._merge(self._tree[o << 1], self._tree[o << 1 | 1])

    # 建树,o代表线段树节点编号
    def _build(self, l, r, o, nums):
        if l == r:
            self._tree[o] = nums[l - 1]  # nums下标从0开始,所以要减1
            return
        mid = (l + r) >> 1
        self._build(l, mid, o << 1, nums)
        self._build(mid + 1, r, o << 1 | 1, nums)
        self._maintain(o)

    # 单点修改函数,将下标为idx的元素的值修改为val
    def _update(self, l, r, o, idx, val):  # o表示当前节点
        # 递归边界
        if l == r:
            self._alter(o, val)
            return
        mid = (l + r) >> 1
        if idx <= mid:
            # 在左子树
            self._update(l, mid, o << 1, idx, val)  # o<<1表示左孩子
        else:
            # 在右子树
            self._update(mid + 1, r, o << 1 | 1, idx, val)
        self._maintain(o)

    # 区间查询函数,L,R为待查询区间,l,r为当前区间
    def _query(self, l, r, o, L, R):
        # 区间越界的情况,如果
        if R < L:
            return 0
        # 待查询区间全包含当前区间,即当前区间[l,r]是待查询区间[l,r]的子集
        if L <= l and r <= R:
            return self._tree[o]

        mid = (l + r) >> 1

        # 三分支写法,注意和下面双分支写法的区别,为了方便维护,推荐使用三分支写法

        # 中点在待查询区间右侧,待查询区间落在左子树
        if mid >= R:
            return self._query(l, mid, o << 1, L, R)
        # 中点在待查询区间左侧, 待查询区间落在右子树
        if mid < L:
            return self._query(mid + 1, r, o << 1 | 1, L, R)
        l_res = self._query(l, mid, o << 1, L, R)
        r_res = self._query(mid + 1, r, o << 1 | 1, L, R)
        return self._merge(l_res, r_res)

        # 双分支写法
        # s = 0
        # if mid >= L:
        #     s += self._query(l, mid, o << 1, L, R)
        # if mid < R:
        #     s += self._query(mid + 1, r, o << 1 | 1, L, R)
        # return s

    # 真正的范围修改函数,减少参数
    def update(self, idx, val):
        return self._update(1, self.n, 1, idx, val)

    # 真正的范围查询函数,减少参数
    def query(self, L, R):
        return self._query(1, self.n, 1, L, R)

    # 真正的单点查询函数,减少参数
    def get(self, i):
        return self._query(1, self.n, 1, i, i)
```

### 1b.包含建树,将某个点的值修改,维护累加和信息(纯净版)

```python
class SegmentTree:
    def __init__(self, nums):
        self.n = len(nums)
        self._tree = [0] * (self.n << 2)
        self._build(1, self.n, 1, nums)

    def _alter(self, o, val):
        self._tree[o] = val

    def _merge(self, a, b):
        return a + b

    def _maintain(self, o):
        self._tree[o] = self._merge(self._tree[o << 1], self._tree[o << 1 | 1])

    def _build(self, l, r, o, nums):
        if l == r:
            self._tree[o] = nums[l - 1]
            return
        mid = (l + r) >> 1
        self._build(l, mid, o << 1, nums)
        self._build(mid + 1, r, o << 1 | 1, nums)
        self._maintain(o)

    def _update(self, l, r, o, idx, val):
        if l == r:
            self._alter(o, val)
            return
        mid = (l + r) >> 1
        if idx <= mid:
            self._update(l, mid, o << 1, idx, val)
        else:
            self._update(mid + 1, r, o << 1 | 1, idx, val)
        self._maintain(o)

    def _query(self, l, r, o, L, R):
        if R < L:
            return 0
        if L <= l and r <= R:
            return self._tree[o]

        mid = (l + r) >> 1

        if mid >= R:
            return self._query(l, mid, o << 1, L, R)

        if mid < L:
            return self._query(mid + 1, r, o << 1 | 1, L, R)
        l_res = self._query(l, mid, o << 1, L, R)
        r_res = self._query(mid + 1, r, o << 1 | 1, L, R)
        return self._merge(l_res, r_res)

    def update(self, idx, val):
        return self._update(1, self.n, 1, idx, val)

    def query(self, L, R):
        return self._query(1, self.n, 1, L, R)

    def get(self, i):
        return self._query(1, self.n, 1, i, i)
```

### 2a.不包含建树,将某个点的值增加(纯净版)

```python
class SegmentTree:
    def __init__(self, n):
        self.n = n
        self._tree = [0] * (self.n << 2)

    def _alter(self , o ,val):
        self._tree[o] = val
    def _merge(self, a, b):
        return a + b

    def _maintain(self, o):
        self._tree[o] = self._merge(self._tree[o << 1], self._tree[o << 1 | 1])

    def _update(self, l, r, o, idx, val):
        if l == r:
            self._alter(o, val)
            return
        mid = (l + r) >> 1
        if idx <= mid:
            self._update(l, mid, o << 1, idx, val)
        else:
            self._update(mid + 1, r, o << 1 | 1, idx, val)
        self._maintain(o)

    def _query(self, l, r, o, L, R):
        if R < L:
            return 0
        if L <= l and r <= R:
            return self._tree[o]
        mid = (l + r) >> 1
        if mid >= R:
            return self._query(l, mid, o << 1, L, R)
        if mid < L:
            return self._query(mid + 1, r, o << 1 | 1, L, R)
        l_res = self._query(l, mid, o << 1, L, R)
        r_res = self._query(mid + 1, r, o << 1 | 1, L, R)
        return self._merge(l_res, r_res)

    def update(self, idx, val):
        return self._update(1, self.n, 1, idx, val)

    def query(self, L, R):
        return self._query(1, self.n, 1, L, R)

    def get(self, i):
        return self._query(1, self.n, 1, i, i)

```

## 2.区间修改线段树(Lazy线段树)

### 1a.区间修改(注释版)

```python
class LazySegmentTree:
    #初始化
    def __init__(self,nums):
        self.n=len(nums)
        self.cnt1=[0]*(self.n<<2)
        self.todo=[False]*(self.n<<2)
        self.build(1,self.n,1,nums)
    #建树
    def build(self,l,r,o,nums):
        if l==r:
            self.cnt1[o]=nums[l-1]
            return 
        mid=(l+r)>>1
        self.build(l,mid,o<<1,nums)
        self.build(mid+1,r,o<<1|1,nums)
        self.cnt1[o]=self.cnt1[o<<1]+self.cnt1[o<<1|1]
    #lazy标记
    def do(self,l,r,o): #操作1
        self.cnt1[o]=r-l+1-self.cnt1[o] 
        self.todo[o]=not self.todo[o]
    #区间修改
    def update(self,l,r,o,L,R):
        if l>=L and r<=R:
            self.do(l,r,o)
            return 
        mid=(l+r)>>1
        #懒标记
        if self.todo[o]:
            self.do(l,mid,o<<1)
            self.do(mid+1,r,o<<1|1)
            self.todo[o]=False
        if mid>=L:
            self.update(l,mid,o<<1,L,R)
        if mid<R:
            self.update(mid+1,r,o<<1|1,L,R)
        self.cnt1[o]=self.cnt1[o<<1]+self.cnt1[o<<1|1]
```

### 1b.区间修改(纯净版)

```python
class LazySegmentTree:
    def __init__(self,nums):
        self.n=len(nums)
        self.cnt1=[0]*(self.n<<2)
        self.todo=[False]*(self.n<<2)
        self.build(1,self.n,1,nums)
    def build(self,l,r,o,nums):
        if l==r:
            self.cnt1[o]=nums[l-1]
            return 
        mid=(l+r)>>1
        self.build(l,mid,o<<1,nums)
        self.build(mid+1,r,o<<1|1,nums)
        self.cnt1[o]=self.cnt1[o<<1]+self.cnt1[o<<1|1]
    def do(self,l,r,o):
        self.cnt1[o]=r-l+1-self.cnt1[o] 
        self.todo[o]=not self.todo[o]
    def update(self,l,r,o,L,R):
        if l>=L and r<=R:
            self.do(l,r,o)
            return 
        mid=(l+r)>>1
        if self.todo[o]:
            self.do(l,mid,o<<1)
            self.do(mid+1,r,o<<1|1)
            self.todo[o]=False
        if mid>=L:
            self.update(l,mid,o<<1,L,R)
        if mid<R:
            self.update(mid+1,r,o<<1|1,L,R)
        self.cnt1[o]=self.cnt1[o<<1]+self.cnt1[o<<1|1]
```



```python
#模版题:2569(https://leetcode.cn/problems/handling-sum-queries-after-update/)
#本题只需要查询1~n范围的和,因此无需要写区间查询query函数,直接调用cnt[1]即可,代表1~n范围
class LazySegmentTree:
    #初始化
    def __init__(self,nums):
        self.n=len(nums)
        self.cnt1=[0]*(self.n<<2)
        self.todo=[False]*(self.n<<2)
        self.build(1,self.n,1,nums)
    #建树
    def build(self,l,r,o,nums):
        if l==r:
            self.cnt1[o]=nums[l-1]
            return 
        mid=(l+r)>>1
        self.build(l,mid,o<<1,nums)
        self.build(mid+1,r,o<<1|1,nums)
        self.cnt1[o]=self.cnt1[o<<1]+self.cnt1[o<<1|1]
    #lazy标记
    def do(self,l,r,o): #操作1
        self.cnt1[o]=r-l+1-self.cnt1[o] 
        self.todo[o]=not self.todo[o]
    #区间修改
    def update(self,l,r,o,L,R):
        if l>=L and r<=R:
            self.do(l,r,o)
            return 
        mid=(l+r)>>1
        #懒标记
        if self.todo[o]:
            self.do(l,mid,o<<1)
            self.do(mid+1,r,o<<1|1)
            self.todo[o]=False
        if mid>=L:
            self.update(l,mid,o<<1,L,R)
        if mid<R:
            self.update(mid+1,r,o<<1|1,L,R)
        self.cnt1[o]=self.cnt1[o<<1]+self.cnt1[o<<1|1]
class Solution:
    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        sg=LazySegmentTree(nums1)
        ans=[]
        s=sum(nums2)
        for op,l,r in queries:
            if op==1:
                sg.update(1,sg.n,1,l+1,r+1)
            elif op==2:
                s+=l*sg.cnt1[1]
            else:
                ans.append(s)
        return ans
```

### 2a.区间修改+区间查询(注释版)

```python
class LazySegmentTree:
    #初始化
    def __init__(self,n):
        self.n=n
        self.cnt=[0]*(self.n<<2)
        self.todo=[0]*(self.n<<2)

    #lazy标记
    def do(self,o,v): #操作1
        self.cnt[o]+=v
        self.todo[o]+=v
    def spread(self,o):
        v=self.todo[o]
        if v:
            self.do(o<<1,v)
            self.do(o<<1|1,v)
            self.todo[o]=0
    #区间修改
    def update(self,l,r,o,L,R,v):
        if l>=L and r<=R:
            self.do(o,v)
            return 
        self.spread(o)
        mid=(l+r)>>1
        if mid>=L:
            self.update(l,mid,o<<1,L,R,v)
        if mid<R:
            self.update(mid+1,r,o<<1|1,L,R,v)
        self.cnt[o]=min(self.cnt[o<<1],self.cnt[o<<1|1])
    def query(self,l,r,o,L,R):
        if l>=L and r<=R:
            return self.cnt[o]
        self.spread(o)
        mid=(l+r)>>1

        # #三分支写法
        # if mid>=R:
        #     return self.query(l,mid,o<<1,L,R)
        # if mid<L:
        #     return self.query(mid+1,r,o<<1|1,L,R)
        # return min(self.query(l,mid,o<<1,L,R),self.query(mid+1,r,o<<1|1,L,R))

        #双分支写法
        mn=inf
        if mid>=L:
            mn=self.query(l,mid,o<<1,L,R)
        if mid<R:
            mn=min(mn,self.query(mid+1,r,o<<1|1,L,R))
        return mn
```

### 2b.区间修改+区间查询(纯净版)

```python
class LazySegmentTree:
    def __init__(self,n):
        self.n=n
        self.cnt=[0]*(self.n<<2)
        self.todo=[0]*(self.n<<2)
    def do(self,o,v): 
        self.cnt[o]+=v
        self.todo[o]+=v
    def spread(self,o):
        v=self.todo[o]
        if v:
            self.do(o<<1,v)
            self.do(o<<1|1,v)
            self.todo[o]=0
    def update(self,l,r,o,L,R,v):
        if l>=L and r<=R:
            self.do(o,v)
            return 
        self.spread(o)
        mid=(l+r)>>1
        if mid>=L:
            self.update(l,mid,o<<1,L,R,v)
        if mid<R:
            self.update(mid+1,r,o<<1|1,L,R,v)
        self.cnt[o]=min(self.cnt[o<<1],self.cnt[o<<1|1])
    def query(self,l,r,o,L,R):
        if l>=L and r<=R:
            return self.cnt[o]
        self.spread(o)
        mid=(l+r)>>1

        if mid>=R:
            return self.query(l,mid,o<<1,L,R)
        if mid<L:
            return self.query(mid+1,r,o<<1|1,L,R)
        return min(self.query(l,mid,o<<1,L,R),self.query(mid+1,r,o<<1|1,L,R))
```



```python
#区间修改+区间查询
#模版题2547(https://leetcode.cn/problems/minimum-cost-to-split-an-array/)
class Solution:
    def minCost(self, nums: List[int], k: int) -> int:
        n=len(nums)
        ans=0
        last=[0]*n
        last2=[0]*n
        sg=LazySegmentTree(n)
        for i,x in enumerate(nums,1):
            sg.update(1,sg.n,1,i,i,ans)
            sg.update(1,sg.n,1,last[x]+1,i,-1)
            if last[x]:
                sg.update(1,sg.n,1,last2[x]+1,last[x],1)
            ans=k+sg.query(1,sg.n,1,1,i)
            last2[x]=last[x]
            last[x]=i
        return ans+n

class LazySegmentTree:
    #初始化
    def __init__(self,n):
        self.n=n
        self.cnt=[0]*(self.n<<2)
        self.todo=[0]*(self.n<<2)

    #lazy标记
    def do(self,o,v): #操作1
        self.cnt[o]+=v
        self.todo[o]+=v
    def spread(self,o):
        v=self.todo[o]
        if v:
            self.do(o<<1,v)
            self.do(o<<1|1,v)
            self.todo[o]=0
    #区间修改
    def update(self,l,r,o,L,R,v):
        if l>=L and r<=R:
            self.do(o,v)
            return 
        self.spread(o)
        mid=(l+r)>>1
        if mid>=L:
            self.update(l,mid,o<<1,L,R,v)
        if mid<R:
            self.update(mid+1,r,o<<1|1,L,R,v)
        self.cnt[o]=min(self.cnt[o<<1],self.cnt[o<<1|1])
    def query(self,l,r,o,L,R):
        if l>=L and r<=R:
            return self.cnt[o]
        self.spread(o)
        mid=(l+r)>>1

        # #三分支写法
        # if mid>=R:
        #     return self.query(l,mid,o<<1,L,R)
        # if mid<L:
        #     return self.query(mid+1,r,o<<1|1,L,R)
        # return min(self.query(l,mid,o<<1,L,R),self.query(mid+1,r,o<<1|1,L,R))

        #双分支写法
        mn=inf
        if mid>=L:
            mn=self.query(l,mid,o<<1,L,R)
        if mid<R:
            mn=min(mn,self.query(mid+1,r,o<<1|1,L,R))
        return mn
```

## 3.线段树二分

```python
#模版题:2286(https://leetcode.cn/problems/booking-concert-tickets-in-groups/)
min=lambda x,y:x if x<y else y
#线段树二分
class BookMyShow:
    #初始化线段树
    def __init__(self, n: int, m: int):
        self.n=n
        self.m=m
        self.sum=[0]*(n<<2)
        self.min=[0]*(n<<2)

    #线段树单点修改函数
    #单点修改,每个点表示一排
    def update(self,l,r,o,idx,val): #o表示当前节点
        if l==r:
            self.sum[o]+=val
            self.min[o]+=val
            return 
        mid=(l+r)>>1
        if idx<=mid:
            self.update(l,mid,o<<1,idx,val) #o<<1表示左孩子
        else:
            self.update(mid+1,r,o<<1|1,idx,val)
        self.sum[o]=self.sum[o<<1]+self.sum[o<<1|1] #o<<1|1表示右孩子
        self.min[o]=min(self.min[o<<1],self.min[o<<1|1])

    #线段树区间查询函数
    #区间查询,当L==R时,查询的就是某一排坐的人数(线段树叶子节点的sum值)
    def query(self,l,r,o,L,R): #L,R为待查询区间,l,r为当前区间
        if l>=L and r<=R:#待查询区间包含了当前区间
            return self.sum[o]
        sum=0
        mid=(l+r)>>1
        if mid>=L:
            sum+=self.query(l,mid,o<<1,L,R)
        if mid<R:
            sum+=self.query(mid+1,r,o<<1|1,L,R)
        return sum


    #线段树二分查找函数
    #返回[1,R]范围内<=val的最小下标,不存在就返回0,用于寻找第一个可用的排(线段树叶子节点)
    def find(self,l,r,o,R,val):
        if self.min[o]>val:
            return 0
        if l==r:
            return l
        mid=(l+r)>>1
        if self.min[o<<1]<=val:
            return self.find(l,mid,o<<1,R,val)
        if R>mid:
            return self.find(mid+1,r,o<<1|1,R,val)
        return 0

    def gather(self, k: int, maxRow: int) -> List[int]:
        i=self.find(1,self.n,1,maxRow+1,self.m-k)
        if i==0:
            return []
        seats=self.query(1,self.n,1,i,i)
        self.update(1,self.n,1,i,k) #如果某一排能容纳k个人,将该点值增加k
        return [i-1,seats]

    def scatter(self, k: int, maxRow: int) -> bool:
        #空座位数
        remains=(maxRow+1)*self.m-self.query(1,self.n,1,1,maxRow+1)
        if k>remains:
            return False
        i=self.find(1,self.n,1,maxRow+1,self.m-1) #坐的人<=self.m-1,即还有至少1个空座的排
        while k:
            left_seats=min(self.m-self.query(1,self.n,1,i,i),k) #该排剩余的座位数,和k取min防止超出容量m
            self.update(1,self.n,1,i,left_seats)
            k-=left_seats #需要安排的人数减少left_seats
            i+=1 #到下一排查看
        return True
```

# 9.最短路

## 1.朴素Dijkstra算法

**单源正权最短路**

```python
#朴素Dijkstra算法,时间复杂度O(n^2)
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        distance=[inf]*(n+1)
        graph=[[inf]*(n+1) for _ in range(n+1)]
        visited=[False]*(n+1)
        for x,y,z in times:
            graph[x][y]=z
        distance[k]=0
        for i in range(n-1):
            t=-1
            for j in range(1,n+1):
                if not visited[j] and (t==-1 or distance[j]<distance[t]):
                    t=j
            visited[t]=True
            for j in range(1,n+1):
                if (cur:=distance[t]+graph[t][j])<distance[j]:
                    distance[j]=cur
                # distance[j]=min(distance[j],distance[t]+graph[t][j])
        ans=0
        for x in distance[1:]:
            if x==inf:
                return -1
            if x>ans:
                ans=x
        return ans
```

## 2.小根堆优化的Dijkstra算法

**单源正权最短路**

注意由于每次优先松弛最短的边,所以当一个点第一次从堆中弹出时,其对应的距离一定就是源点到它的最短距离

注意最短路算法和dp的区别,最短路算法允许环的存在,而dp无法解决带环问题

```python
#模版题743(https://leetcode.cn/problems/network-delay-time/)
#小根堆优化的Dijkstra算法,实际实现复杂度O(mlogm)
def Dijkstra(edges,n,start):
    g=[[] for _ in range(n)]
    # 默认是有向图,如果是无向图需要额外连反向边
    for x,y,w in edges:
        g[x].append((y,w))
    dis=[inf]*n
    dis[start]=0
    pq=[(0,start)]
    while pq:
        dis_u,u=heappop(pq)
        if dis_u>dis[u]:
            continue
        for v,w in g[u]:
            dis_v=dis_u+w
            if dis_v<dis[v]:
                dis[v]=dis_v
                heappush(pq,(dis_v,v))
    return dis
```

## 3.网格图Dijkstra

**单源正权最短路**

```python
#模版题3341(https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/)
#权值更新函数,根据题意编写
def g(dis_u,w):
    pass

def Dijkstra(grid, sx, sy):
    move = [(1, 0), (-1, 0), (0, -1), (0, 1)]
    n, m = len(grid), len(grid[0])
    dis = [[inf] * m for _ in range(n)]
    dis[sx][sy] = 0
    pq = [(0, sx, sy)]
    while pq:
        dis_u, x, y = heappop(pq)
        if dis_u > dis[x][y]:
            continue
        for dx, dy in move:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m:
                dis_v = g(dis_u,grid[nx][ny]) #根据题意修改
                if dis_v < dis[nx][ny]:
                    dis[nx][ny] = dis_v
                    heappush(pq, (dis_v, nx, ny))
    return dis
```

## 4.Dijkstra变形

**特殊情况下Dijkstra可维护单源最长路**

权重累积为乘法且权值在0~1之间的最长路问题可以用类似Dijkstra的方法解决,不过要用大根堆

```python
#模版题:1514(https://leetcode.cn/problems/path-with-maximum-probability/)
#回顾原始Dijkstra求最短路,它利用了加法不会变小的性质,优先松弛短的边,从而得到最短路
#而本题边权全是介于0~1之间的数,且为乘法,一个数乘上<=1的数不可能变大,只会不变或变小
#因此本题的乘法不会变大,贪心地优先松弛大的边,就可以得到最长路
#由于是维护最大边,维护一个大根堆,使用Dijkstra即可
class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:
        def Dijkstra(start):
            g=[[] for _ in range(n)]
            for (x,y),w in zip(edges,succProb):
                g[x].append((y,w))
                g[y].append((x,w))
            dis=[0]*n
            dis[start]=1
            pq=[(-1,start)]
            #python大根堆需要将数值取反
            while pq:
                dis_u,u=heappop(pq)
                if u==end_node:
                    return -dis_u
                if -dis_u<dis[u]:
                    continue
                for v,w in g[u]:
                    dis_v=-dis_u*w
                    if dis_v>dis[v]:
                        dis[v]=dis_v
                        heappush(pq,(-dis_v,v))
            return 0
        return Dijkstra(start_node)

```



## 4.Bellman-Ford

```python
#Bellman-Ford,时间复杂度O(m),最坏O(nm),一般处理负权图
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        distance=[inf]*(n+1) #每个点到源点距离
        distance[k]=0
        for i in range(n-1): #进行n-1次松弛操作,因为最短路最多有n-1条边
            backup=distance[:]
            for x,y,w in times:
                distance[y]=min(distance[y],backup[x]+w)
        ans=0
        for x in distance[1:]:
            if x==inf:
                return -1
            # ans=max(ans,x)
            if x>ans:
                ans=x
        return ans 
```

## 5.spfa

```python
#spfa,时间复杂度最坏O(mn),Bellman-Ford算法优化版，一般处理负权图
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        distance=[inf]*(n+1) #每个点到源点距离
        visited=[False]*(n+1) #visited数组表示某个点是否在队列中
        #建图
        graph=[[] for _ in range(n+1)] #邻接表
        for x,y,z in times:
            graph[x].append((z,y))

        q=deque([k])
        distance[k]=0

        while q:
            u=q.popleft()
            visited[u]=False
            for w,v in graph[u]:
                if distance[v]>(dis:=distance[u]+w):
                    distance[v]=dis
                    if not visited[v]:
                        q.append(v)
                        visited[v]=True
        ans=0
        for x in distance[1:]:
            if x==inf:
                return -1
            # ans=max(ans,x)
            if x>ans:
                ans=x
        return ans 
```

## 6.Floyd

```python
min=lambda x,y:x if x<y else y
#Floyd算法,时间复杂度O(n^3),可以求任意两点间最短距离,可以求解负权图
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, s: int) -> int:
        d=[[inf]*(n+1) for _ in range(n+1)]
        for i in range(1,n+1):
            for j in range(1,n+1):
                if i==j:
                    d[i][j]=0
        for x,y,z in times:
            d[x][y]=z

        for k in range(1,n+1):
            for i in range(1,n+1):
                for j in range(1,n+1):
                    d[i][j]=min(d[i][j],d[i][k]+d[k][j])
        ans=0
        for x in d[s][1:]:
            if x==inf:
                return -1
            if x>ans:
                ans=x
        return ans        
```

## 7.bfs

```python
#无权最短路
#模版题(https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/)
def bfs(start,edges,n):
    g=[[] for _ in range(n)]
    for x,y in edges:
        g[x].append(y)
        g[y].append(x)
    dis=[inf]*n
    dis[start]=0
    q=deque([start])
    level=1
    while q:
        size=len(q)
        for _ in range(size):
            u=q.popleft()
            for v in g[u]:
                if level<dis[v]:
                    q.append(v)
                    dis[v]=level
        level+=1
    return dis
```

# 10.图论问题

## 1.求联通块大小

### 1.按秩合并并查集

```python
#2316(https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/)
class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        u=UnionFind(n)
        for x,y in edges:
            u.union(x,y)
        ans=0
        for i in range(n):
            ans+=n-u.size[u.find(i)]
        return ans//2
        
class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
        self.size=[1]*n #记录每个集合的数量
        
    #扁平化
    def find(self,i):
        #递归写法
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
        
    #按秩合并(小集合挂大集合)
    def union(self,x,y):
        fx,fy=self.find(x),self.find(y)
        if fx!=fy:
       	    if self.size[fx]>=self.size[fy]:
                self.size[fx]+=self.size[fy]
                self.father[fy]=fx
            else:
                self.size[fy]+=self.size[fx]
                self.father[fx]=fy
```

### 2.dfs

```python
#2316(https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/)
class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[x].append(y)
            g[y].append(x)
        vis=set()
        def f(i):
            vis.add(i)
            cnt=1
            for j in g[i]:
                if j not in vis:
                    cnt+=f(j)
            return cnt
        ans=0
        for i in range(n):
            if i not in vis:
                t=f(i)
                ans+=t*(n-t)
        return ans//2
```

## 2.求连通块个数

### 1.并查集

```python
#1319(https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)
class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        if len(connections)<n-1:
            return -1
        u=UnionFind(n)
        for x,y in connections:
            u.union(x,y)
        return u.size-1
        

class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
        self.size=n
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
    def union(self,x,y):
        fx,fy=self.find(x),self.find(y)
        if fx!=fy:
            self.father[fx]=fy
            self.size-=1
```

### 2.dfs

```python
#1319(https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)
class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        if len(connections)<n-1:
            return -1
        g=[[] for _ in range(n)]
        for x,y in connections:
            g[x].append(y)
            g[y].append(x)
        vis=set()
        def f(i):
            vis.add(i)
            for j in g[i]:
                if j not in vis:
                    f(j)
        size=0
        for i in range(n):
            if i not in vis:
                f(i)
                size+=1
        return size-1
```

## 3.连通块内最小边权

### 1.dfs

```python
#2492(https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/)
class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        g=[[] for _ in range(n+1)]
        for x,y,z in roads:
            g[x].append((y,z))
            g[y].append((x,z))
        vis=set()
        ans=inf
        def f(i):
            vis.add(i)
            for j,v in g[i]:
                nonlocal ans
                ans=min(ans,v)
                if j not in vis:
                    f(j)
        f(1)
        return ans
```

### 2.并查集

```python
#2492(https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/)
class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        u=UnionFind(n+1)
        for x,y,z in roads:
            u.union(x,y,z)
        return u.dis[u.find(1)]

class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
        self.dis=[inf]*n
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
    def union(self,x,y,z):
        fx,fy=self.find(x),self.find(y)
        self.father[fx]=fy
        self.dis[fy]=min(self.dis[fx],self.dis[fy],z)
```

## 4.统计完全联通分量数量

**本质是求联通分量内边数e是否等于n*(n-1)//2,其中n为联通分量内点数**

### 1.并查集

```python
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        u=UnionFind(n)
        for x,y in edges:
            u.union(x,y)
        ans=0
        for i in range(n):
            if i==u.find(i) and u.size[i]*(u.size[i]-1)//2==u.edge[i]:
                ans+=1
        return ans


class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
        self.size=[1]*n #记录每个集合的数量
        self.edge=[0]*n #记录每个集合边的数量
        
    #扁平化
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
        
    def union(self,x,y):
        fx,fy=self.find(x),self.find(y)
        if fx==fy:
            self.edge[fx]+=1
        else:
            self.father[fx]=fy
            self.size[fy]+=self.size[fx]
            self.edge[fy]+=self.edge[fx]+1
```

### 2.dfs

```python
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[x].append(y)
            g[y].append(x)
        vis=set()
        def f(i):
            vis.add(i)
            nonlocal cnt,e
            cnt+=1
            e+=len(g[i])
            for j in g[i]:
                if j not in vis:
                    f(j)
        ans=0
        for i in range(n):
            if i not in vis:
                cnt=e=0
                f(i)
                #cnt*(cnt-1)//2==e//2,2消掉了
                ans+=cnt*(cnt-1)==e
        return ans
```

## 5.使连通分量连通

**使n个连通分量连通需要添加n-1条边**

## 6.寻找DAG上的祖先

### 1.正向dfs

```python
#2192(https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/)
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[x].append(y)
        def f(i):
            nonlocal start
            vis[i]=start
            nonlocal ans
            for j in g[i]:
                if vis[j]!=start:
                    ans[j].append(start)
                    f(j)
        ans=[[] for _ in range(n)]
        vis=[-1]*n
        for start in range(n):
            f(start)
        return ans
```

### 2.反向dfs

```python
#2192(https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/)
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[y].append(x)
        def f(i):
            vis[i]=True
            for j in g[i]:
                if not vis[j]:
                    f(j)
        ans=[None]*n
        for i in range(n):
            vis=[False]*n
            f(i)
            vis[i]=False
            ans[i]=[j for j,x in enumerate(vis) if x]
        return ans
```

## 7.割点与连通块

```python
#928(https://leetcode.cn/problems/minimize-malware-spread-ii/)
#首先将所有未感染点加入并查集合并
#然后统计所有与感染点相邻的只有一个感染点的连通块内元素数量之和t,求最大值对应的感染点
#如果有多个点t相同,就返回下标最小的
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n=len(graph)
        u=UnionFind(n)
        s=set(initial)
        for i in range(n):
            if i not in s:
                for j in range(i+1,n):
                    if graph[i][j] and j not in s:
                        u.union(i,j)
        g=defaultdict(set)
        cnt=defaultdict(int)
        for i in initial:
            for j in range(n):
                if j not in s and graph[i][j]:
                    g[i].add(u.find(j))
            for x in g[i]:
                cnt[x]+=1
        ans,mx=inf,0
        for i in initial:
            #由于当集合为空时sum求和为0,因此当没有cnt[root]=1时,返回的就是initial的最小下标
            t=sum(u.size[root] for root in g[i] if cnt[root]==1)
            if t>mx or (t==mx and i<ans):
                ans,mx=i,t
        return ans 

class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
        self.size=[1]*n #记录每个集合的数量
        
    #扁平化
    def find(self,i):
        #递归写法
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
        
    #按秩合并(小集合挂大集合)
    def union(self,x,y):
        fx,fy=self.find(x),self.find(y)
        if fx!=fy:
       	    if self.size[fx]>=self.size[fy]:
                self.size[fx]+=self.size[fy]
                self.father[fy]=fx
            else:
                self.size[fy]+=self.size[fx]
                self.father[fx]=fy
```

## 8.有向图判环

### 1.三色标记法

对于每个节点 x，都定义三种颜色值（状态值）：
0：节点 x 尚未被访问到。
1：节点 x 正在访问中，dfs(x) 尚未结束。
2：节点 x 已经完全访问完毕，dfs(x) 已返回。

```python
#207(https://leetcode.cn/problems/course-schedule/)
class Solution:
    def canFinish(self, n: int, prerequisites: List[List[int]]) -> bool:
        g=[[] for _ in range(n)]
        for x,y in prerequisites:
            g[y].append(x)
        colors=[0]*n
        def f(u):
            colors[u]=1
            for v in g[u]:
                #colors[v]==0说明该点之前没有访问过
                if colors[v]==1 or colors[v]==0 and f(v):
                    return True
            colors[u]=2
            return False
        for i,x in enumerate(colors):
            #找到了环
            if x==0 and f(i):
                return False
        return True
```

```python
#802(https://leetcode.cn/problems/find-eventual-safe-states/)
#三色标记法
#所有不在环中的点即为安全节点
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n=len(graph)
        colors=[0]*n
        ans=[]
        def f(i):
            colors[i]=1
            for j in graph[i]:
                #colors[j]==0说明该点之前没有访问过
                if colors[j]==1 or colors[j]==0 and f(j):
                    return True
            colors[i]=2
            return False
        for i in range(n):
            if colors[i]==0:
                f(i)
        return [i for i,x in enumerate(colors) if x==2]
```



### 2.拓扑排序



## 9.无向图判环

### 1.dfs

```python
#2471(https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/)
#bfs+置换环,环内元素不需要交换,因此核心是找环
class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        def f(a):
            n=len(a)
            a=sorted(range(n),key=lambda i:a[i])
            vis=[False]*n
            #排序后会形成若干个环,每个环内部交换次数为环大小-1
            #加起来为所有环大小-环数,即n-环数
            ans=n #初始为n,每找到一个环,就减去1
            for x in a:
                if vis[x]:continue
                while not vis[x]:
                    vis[x]=True
                    x=a[x]
                ans-=1
            return ans

        q=deque([root])
        ans=0
        while q:
            size=len(q)
            res=[]
            for i in range(size):
                cur=q.popleft()
                res.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            ans+=f(res)
        return ans
```

### 2.并查集

```python
#2471(https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/)
#bfs+置换环,环内元素不需要交换,因此核心是找环
class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        def f(arr):
            n=len(arr)
            arr=sorted([(x,i) for i,x in enumerate(arr)])
            u=UnionFind(n)
            for i,(x,j) in enumerate(arr):
                u.union(i,j)
            return n-u.size

        q=deque([root])
        ans=0
        while q:
            size=len(q)
            res=[]
            for i in range(size):
                cur=q.popleft()
                res.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            ans+=f(res)
        return ans
#带标签并查集,返回合并后有几个集合(即有几个环)
class UnionFind:
    def __init__(self,n):
        self.father=list(range(n))
        self.size=n
    def find(self,i):
        if i!=self.father[i]:
            self.father[i]=self.find(self.father[i])
        return self.father[i]
    def union(self,x,y):
        fx,fy=self.find(x),self.find(y)
        if fx!=fy:
            self.father[fx]=fy
            self.size-=1
```



## 10.拓扑序问题

解决拓扑序问题有两种思考方式:

1.一种是常规做法,即用队列进行拓扑排序

2.另一种是建立反图,即保存每个节点的前驱节点,只有当点i的前驱节点都访问过,再访问点i.实际实现时可以用状压dp处理,反图用位图替代,这样当遍历到一个点i时,判断其前驱节点集合p是否是当前遍历过的所有点集s的子集,如果是,说明可以遍历.位运算判断子集的方式:p|s=s或者p&s=p

## 11.有环有链问题

可以通过度数求链的数量,所有度数为1的点的个数之和除以2,即为链的数量

```python
#cf1833e(https://codeforces.com/problemset/problem/1833/E)
class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.size = [1] * n
        self.cc = n

    def find(self, i):
        st = []
        while i != self.father[i]:
            st.append(i)
            i = self.father[i]
        while st:
            self.father[st.pop()] = i
        return i

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        if self.size[fx] >= self.size[fy]:
            self.size[fx] += self.size[fy]
            self.father[fy] = fx
        else:
            self.size[fy] += self.size[fx]
            self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.size = [1] * n
        self.cc = n
#最小值为min(环数+1,连通分量数),即将所有链并成一条链,最大值为连通分量数
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    t = UnionFind(n+1)
    g=[[] for _ in range(n+1)]
    deg=[0]*(n+1)
    vis = set()
    for u,v in enumerate(a,1):
        if u>v:
            u,v=v,u
        if (u,v) not in vis:
            deg[u]+=1
            deg[v]+=1
        vis.add((u,v))
        t.union(u,v)
    #下标从1开始,因此连通块数量要减1
    tot=t.cc-1
    cnt=deg.count(1)
    # 度数为1的点的个数除以2就代表链的个数
    # 连通分量个数-链的个数=环的个数,将所有链合成一条链,因此再+1
    # 最后要和tot取min,因为可能没有链
    print(fmin(tot-cnt//2+1,tot),tot)


t = int(input())
for i in range(t):
    solve()
```

# 11.树上算法

**一般树问题需要能从题目中给出的条件看出这是一棵树**

 *n* 个点和 *n*−1 条边的**连通图**，是一棵**树**。

无向树建图时根节点父亲设为-1,这样当len(g[root])==1时,就说明到了叶节点

## 1a.树的直径(注释版)

**注意,直径是树中最长路径,和选谁为根没有关系**

```python
#3203(https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/description/)
def diameter(self,edges):
    n=len(edges)+1
    g=[[] for _ in range(n)]
    for x,y in edges:
        g[x].append(y)
        g[y].append(x)
    ans=0
    #记录满足条件的最长链
    def f(u,fa):
        nonlocal ans
        mx=0
        for v in g[u]:
            if v==fa:continue
            x=f(v,u)+1 #子节点链长(含父节点)
            ans=max(ans,mx+x)
            mx=max(mx,x)
        return mx #把根节点算上
    f(0,-1)
    return ans
```

## 1b.树的直径(纯净版)

```python
def diameter(self,edges):
    n=len(edges)+1
    g=[[] for _ in range(n)]
    for x,y in edges:
        g[x].append(y)
        g[y].append(x)
    ans=0
    def f(u,fa):
        nonlocal ans
        mx=0
        for v in g[u]:
            if v==fa:continue
            x=f(v,u)+1
            ans=max(ans,mx+x)
            mx=max(mx,x)
        return mx
    f(0,-1)
    return ans
```

## 2.dfs时间戳(注意和dfs序区分)

**dfs时间戳结论,如果x是y的祖先那么in\_[x]<in\_[y]<=out\_[y]<=out\_[x]**
**简化写法in\_[x]<in\_[y]<=out\_[x]**

```python

min=lambda x,y:x if x<y else y
max=lambda x,y:x if x>y else y
class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        #建图
        n=len(nums)
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[x].append(y)
            g[y].append(x)

        clock=0
        #子树异或和,进入和离开点i的时间
        xor_,in_,out_=[0]*n,[0]*n,[0]*n
        #遍历树求出dfs时间戳
        def f(u,fa):
            nonlocal clock
            clock+=1
            in_[u]=clock
            xor_[u]=nums[u]
            for v in g[u]:
                if v==fa:continue
                f(v,u)
                xor_[u]^=xor_[v]
            out_[u]=clock
        f(0,-1)
        #u是否是v的祖先
        def ancestor(u,v):
            return in_[u]<in_[v]<=out_[u]
        
        #设删除边的端点分别为i0,i,j0,j
        #三个连通块的异或和有三种情况
        #1.i0在j子树内,xor_[0]^xor_[j],xor_[j]^xor_[i],xor_[i]
        #2.j0在i子树内,xor_[0]^xor_[i],xor_[i]^xor_[j],xor_[j]
        #3.两条边属于不同子树,xor_[0]^xor_[i]^xor_[j],xor_[i],xor_[j]
        #实际遍历时直接遍历边的下端点i,j,因为求每个连通块的异或和不需要用上端点i0,j0

        #注意枚举时要把上端点空位留出来
        ans=inf
        for i in range(2,n):
            for j in range(1,i):
                if ancestor(j,i):
                    x,y,z=xor_[0]^xor_[j],xor_[j]^xor_[i],xor_[i]
                elif ancestor(i,j):
                    x,y,z=xor_[0]^xor_[i],xor_[i]^xor_[j],xor_[j]
                else:
                    x,y,z=xor_[0]^xor_[i]^xor_[j],xor_[i],xor_[j]
                ans=min(ans,max(max(x,y),z)-min(min(x,y),z))
        return ans
```

## 3.树的直径

树的直径即树中最长简单路径

直径的中心称为树的中心,可以有多条直径,但中心至多有两个,当直径有奇数个点时,所有直径相交于1点,当直径有偶数个点时,每条直径都经过直径中间的两个点

树的直径有两种求法

### 1.找最远点

从任意一点出发,利用dfs/bfs求出距离其最远的点u,然后从u出发,利用bfs/dfs求出距离u最远的点v,u到v的简单路径即为树的直径(简单路径:顶点和边都不重复)

### 2.直径dp

求出经过每个点的最长路径,取最大即为直径

## 4.树的中心

树的中心即到其他所有点的距离最近的点

树的中心一定在树的直径上,直径长度为偶数,则有两个树的中心,直径长度为奇数,则有一个树的中心

**树的中心常见有三种求法**

### 1.直径中点法

**找出树的直径,然后求出其中间的两个或者一个点**

### 2.递归剥叶法(剥洋葱法)

**递归去除度数为1的点(叶子),直到剩余的点小于或者等于2个,如果初始点数<=2,直接返回答案**

### 3.换根dp

## 5.寻找树上两点间路径

```python
#在树中求start到end之间的路径
def query(start, end, g):
    path = []

    def f(u, fa):
        if u == end:
            path.append(u)
            return True
        for v in g[u]:
            if v == fa:
                continue
            if f(v, u):
                path.append(u)
                return True
        return False

    f(start, -1)
    return path
```

## 6.dfs序

## 7.欧拉序

## 8.树的非递归遍历

## 9.morris前中后遍历

## 10.树链剖分

## 11.树上滑窗



## 5.LCA

常见的求lca的方法有两种:倍增,tarjan

倍增用于在线求lca,tarjan是离线求

### 1.倍增法求LCA

时间复杂度O(nlogn)

#### 1a.无权版本(注释版)

```python
# 无权树lca及求树上任意两点间距离
class LCA:
    # 如果下标从0开始,n初始化成边数+1,如果下标从1开始,n初始化成边数+2,root代表根节点编号
    def __init__(self, edges, n, root):
        m = n.bit_length()  # 可以跳2^0,2^1,...,2^(m-1),因此pa数组列长度为m
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
        depth = [0] * n
        pa = [[-1] * m for _ in range(n)]

        def f(u, fa):
            pa[u][0] = fa
            for v in g[u]:
                if v == fa: continue
                depth[v] = depth[u] + 1
                f(v, u)

        f(root, -1)
        for i in range(m - 1):
            for x in range(n):
                if (t := pa[x][i]) != -1:
                    pa[x][i + 1] = pa[t][i]
        self.depth = depth
        self.pa = pa
        self.m = m

    # 求node的第k个祖先
    def get_kth_ancestor(self, node, k):
        for i in range(k.bit_length()):
            if k >> i & 1:
                node = self.pa[node][i]
        return node

    # 求树上任意两点的lca
    def get_lca(self, x, y):
        # y为x,y中深度更大的节点,如果y的深度小于x,则交换两个节点
        if self.depth[x] > self.depth[y]:
            x, y = y, x
        # y向上跳到和x深度一样
        y = self.get_kth_ancestor(y, self.depth[y] - self.depth[x])
        # 如果此时y和x重合,说明x就是最近公共祖先
        if y == x:
            return x
        # px,py一起往上跳2^i步,从大到小依次尝试
        # 如果步子大了,跳过了lca,那么px和py会跳到相等的位置(可能是-1也可能是其他点)
        # 如果步子小了，则i-1,下一轮重复上述过程
        # 最终会到达离lca差一步的位置
        # 返回self.pa[x][0]即可,即从x再向上跳2^0=1步
        # 当px==py时,认为步子跳大了,选择更小的i,即在循环中,px,py永远不会等于lca,最多只会跳到离lca差一步的位置
        # 设x,y到lca距离为d,到lca下面一步的距离为d-1,由于任意数一定可以转化成二进制,而倍增每步跳的都对应二进制某位的值
        # 因此最终x,y一定可以跳到lca下面一步的位置
        # 而当x,y跳到>=lca的位置(即跳过了),px一定会等于py,这时不更新px,py,尝试更小的i,只有px!=py时,才更新x,y
        for i in range(self.m - 1, -1, -1):
            px, py = self.pa[x][i], self.pa[y][i]
            if px != py:
                x, y = px, py
        return self.pa[x][0]

    # #求树上任意两点间距离
    # x,y之间距离=根到x的距离+根到y的距离-2*根到lca(x,y)的距离,由于是无权树,距离可以用深度替代
    def get_dis(self, x, y):
        return self.depth[x] + self.depth[y] - 2 * self.depth[self.get_lca(x, y)]
```

#### 1b.无权版本(纯净版)

```python
# 无权树lca及求树上任意两点间距离
class LCA:
    # 如果下标从0开始,n初始化成边数+1,如果下标从1开始,n初始化成边数+2,root代表根节点编号
    def __init__(self, edges, n, root):
        m = n.bit_length()
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
        depth = [0] * n
        pa = [[-1] * m for _ in range(n)]

        def f(u, fa):
            pa[u][0] = fa
            for v in g[u]:
                if v == fa: continue
                depth[v] = depth[u] + 1
                f(v, u)

        f(root, -1)
        for i in range(m - 1):
            for x in range(n):
                if (t := pa[x][i]) != -1:
                    pa[x][i + 1] = pa[t][i]
        self.depth = depth
        self.pa = pa
        self.m = m

    def get_kth_ancestor(self, node, k):
        for i in range(k.bit_length()):
            if k >> i & 1:
                node = self.pa[node][i]
        return node

    def get_lca(self, x, y):
        if self.depth[x] > self.depth[y]:
            x, y = y, x
        y = self.get_kth_ancestor(y, self.depth[y] - self.depth[x])
        if y == x:
            return x
        for i in range(self.m - 1, -1, -1):
            px, py = self.pa[x][i], self.pa[y][i]
            if px != py:
                x, y = px, py
        return self.pa[x][0]

    def get_dis(self, x, y):
        return self.depth[x] + self.depth[y] - 2 * self.depth[self.get_lca(x, y)]
```

#### 2a.带权版本(注释版)

```python
# 带权树lca及求树上任意两点间距离
class LCA:
    # 如果下标从0开始,n初始化成边数+1,如果下标从1开始,n初始化成边数+2,root代表根节点编号
    def __init__(self, edges, n, root):
        m = n.bit_length()  # 可以跳2^0,2^1,...,2^(m-1),因此pa数组列长度为m
        g = [[] for _ in range(n)]
        for x, y, w in edges:
            g[x].append((y,w))
            g[y].append((x,w))
        depth = [0] * n
        dis = [0] * n
        pa = [[-1] * m for _ in range(n)]

        def f(u, fa):
            pa[u][0] = fa
            for v,w in g[u]:
                if v == fa: continue
                depth[v] = depth[u] + 1
                dis[v] = dis[u] + w
                f(v, u)

        f(root, -1)
        for i in range(m - 1):
            for x in range(n):
                if (t := pa[x][i]) != -1:
                    pa[x][i + 1] = pa[t][i]
        self.depth = depth
        self.dis = dis
        self.pa = pa
        self.m = m

    # 求node的第k个祖先
    def get_kth_ancestor(self, node, k):
        for i in range(k.bit_length()):
            if k >> i & 1:
                node = self.pa[node][i]
        return node

    # 求树上任意两点的lca
    def get_lca(self, x, y):
        # y为x,y中深度更大的节点,如果y的深度小于x,则交换两个节点
        if self.depth[x] > self.depth[y]:
            x, y = y, x
        # y向上跳到和x深度一样
        y = self.get_kth_ancestor(y, self.depth[y] - self.depth[x])
        # 如果此时y和x重合,说明x就是最近公共祖先
        if y == x:
            return x
        # px,py一起往上跳2^i步,从大到小依次尝试
        # 如果步子大了,跳过了lca,那么px和py会跳到相等的位置(可能是-1也可能是其他点)
        # 如果步子小了，则i-1,下一轮重复上述过程
        # 最终会到达离lca差一步的位置
        # 返回self.pa[x][0]即可,即从x再向上跳2^0=1步
        # 当px==py时,认为步子跳大了,选择更小的i,即在循环中,px,py永远不会等于lca,最多只会跳到离lca差一步的位置
        # 设x,y到lca距离为d,到lca下面一步的距离为d-1,由于任意数一定可以转化成二进制,而倍增每步跳的都对应二进制某位的值
        # 因此最终x,y一定可以跳到lca下面一步的位置
        # 而当x,y跳到>=lca的位置(即跳过了),px一定会等于py,这时不更新px,py,尝试更小的i,只有px!=py时,才更新x,y
        for i in range(self.m - 1, -1, -1):
            px, py = self.pa[x][i], self.pa[y][i]
            if px != py:
                x, y = px, py
        return self.pa[x][0]

    # #求树上任意两点间距离
    # x,y之间距离=根到x的距离+根到y的距离-2*根到lca(x,y)的距离
    def get_dis(self, x, y):
        return self.dis[x] + self.dis[y] - 2 * self.dis[self.get_lca(x, y)]

```

#### 2b.带权版本(纯净版)

```python
# 带权树lca及求树上任意两点间距离
class LCA:
    # 如果下标从0开始,n初始化成边数+1,如果下标从1开始,n初始化成边数+2,root代表根节点编号
    def __init__(self, edges, n, root):
        m = n.bit_length()
        g = [[] for _ in range(n)]
        for x, y, w in edges:
            g[x].append((y,w))
            g[y].append((x,w))
        depth = [0] * n
        dis = [0] * n
        pa = [[-1] * m for _ in range(n)]

        def f(u, fa):
            pa[u][0] = fa
            for v,w in g[u]:
                if v == fa: continue
                depth[v] = depth[u] + 1
                dis[v] = dis[u] + w
                f(v, u)

        f(root, -1)
        for i in range(m - 1):
            for x in range(n):
                if (t := pa[x][i]) != -1:
                    pa[x][i + 1] = pa[t][i]
        self.depth = depth
        self.dis = dis
        self.pa = pa
        self.m = m

    def get_kth_ancestor(self, node, k):
        for i in range(k.bit_length()):
            if k >> i & 1:
                node = self.pa[node][i]
        return node

    def get_lca(self, x, y):
        if self.depth[x] > self.depth[y]:
            x, y = y, x
        y = self.get_kth_ancestor(y, self.depth[y] - self.depth[x])
        if y == x:
            return x
        for i in range(self.m - 1, -1, -1):
            px, py = self.pa[x][i], self.pa[y][i]
            if px != py:
                x, y = px, py
        return self.pa[x][0]

    def get_dis(self, x, y):
        return self.dis[x] + self.dis[y] - 2 * self.dis[self.get_lca(x, y)]
```

# 12.拓扑排序

**严格的拓扑排序(即输出合法拓扑序)只能在DAG(有向无环图)上进行**

**如果一个有向图有环,拓扑排序也可以用来检测是否有环,即检验队列中弹出的元素数量是否等于原图节点数量**

**特殊的无向图(树)上的拓扑排序并不是严格的拓扑排序,称其为递归剥叶法(剥洋葱法)更合适,这种情况在求一些特殊问题时有妙用(如求树的中心)**

## 1a.模版(注释版)

```python
#拓扑排序需要建图和求点的入度
indegree=[0]*n
g=defaultdict(list)
for x,y in edges:
    g[x].append(y)
    indegree[y]+=1
#入度为0的点
arr=[i for i,x in enumerate(indegree) if x==0]
q=deque(arr)
res=[]
#拓扑排序
while q:
    cur=q.popleft()
    res.append(cur)
    for x in g[cur]:
        indegree[x]-=1
        if indegree[x]==0:
            q.append(x)
#res为拓扑序(注意可能不唯一),如果拓扑序数组长度不等于n,说明有向图存在环
if len(res)!=n:
    return -1
```

## 1b.模版(纯净版)

```python
indegree=[0]*n
g=defaultdict(list)
for x,y in edges:
    g[x].append(y)
    indegree[y]+=1
arr=[i for i,x in enumerate(indegree) if x==0]
q=deque(arr)
res=[]
while q:
    cur=q.popleft()
    res.append(cur)
    for x in g[cur]:
        indegree[x]-=1
        if indegree[x]==0:
            q.append(x)
if len(res)!=n:
    return -1
```

## 3.树上拓扑排序(类拓扑排序)

**本质是将度数为1的点逐渐剥离,并不是真正的排序,详情见树的中心第二节**

```python
#310(https://leetcode.cn/problems/minimum-height-trees/)
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n <= 2:
            return list(range(n))
        indegree = [0] * n
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
        deg = list(map(len, g))
        arr = [i for i, x in enumerate(deg) if x == 1]
        q = deque(arr)
        remains = n
        while remains > 2:
            size = len(q)
            remains -= size
            for _ in range(size):
                cur = q.popleft()
                for x in g[cur]:
                    deg[x] -= 1
                    if deg[x] == 1:
                        q.append(x)
        return list(q)

```



```python
#2603(https://leetcode.cn/problems/collect-coins-in-a-tree/)
#两次类拓扑排序(剥洋葱)
#注意:树中点数-1=边数,同时当n>=2时,每删除一个点就相当于删除一条边
class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        n=len(coins)
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[x].append(y)
            g[y].append(x)
        deg=list(map(len,g)) #求入度,因为是无向图可以这样写,有向图不可以这样写
        q=deque()

        #第一次类拓扑排序,将没有金币的叶子加入队列
        for i,(d,c) in enumerate(zip(deg,coins)):
            if d==1 and c==0: 
                q.append(i)

        #逐层剥洋葱,直到所有叶子节点都有金币
        remains=n-1 #初始有n-1条边
        while q:
            size=len(q) 
            remains-=size #每一轮删除叶子到其父节点的边
            for _ in range(size):
                cur=q.popleft()
                #去除没有金币的叶子
                for x in g[cur]:
                    deg[x]-=1
                    if deg[x]==1 and coins[x]==0:
                        q.append(x)
        
        #第二次类拓扑排序,将有金币叶子加入队列,第二次只需要剥一层
        for i,(d,c) in enumerate(zip(deg,coins)):
            if d==1 and c: 
                q.append(i)
        #队列中的点集u是所有有金币的叶子的点
        #这些点的邻居v是走一步就能获得金币的位置
        #首先将u,v之间的边删除
        #然后找v的邻居(类似bfs)t,在将v和t之间的删除,就得到必须走的边数ans
        #由于要回到原点,因此每条边要走两遍,答案是2*ans
        #为方便处理,可以用删点代替删边,对于边u->v(当v度数为1时),删除终点v,就相当于删除了这条边
        remains-=len(q)
        for cur in q:
            for x in g[cur]:
                deg[x]-=1
                if deg[x]==1:
                    remains-=1
        #由于是通过判断度数是否为1来删边,当只剩下两个点时,同一条边会删两次,从而产生负数,因此最后要和0取最大值
        return max(remains*2,0)
```



# 13.字符串

## 1.KMP

**KMP解决的问题**:判断模式串p是否是文本串s的子串,如果是返回s中p的最左开头位置,否则返回-1

KMP算法时间复杂度O(n+m)

### 1.普通暴力匹配方法

**暴力算法时间复杂度O(nm)**

```python
#暴力方法就是尝试将s的每个位置都做开头,然后去匹配p整体,
#文本串为s,模式串为p
for i in range(len(s)):
    flag=True
    for j in range(len(p)):
        if s[i]!=p[j]:
            flag=False
            break
```

### 2.KMP

**KMP算法时间复杂度O(n+m)**

#### 1a.求第一个匹配的子串位置(注释版)

```python
#KMP,s代表文本串,p代表模式串
def kmp(s,p):
    #n代表s长度,m代表p长度
    n,m=len(s),len(p)
    ne=[0]*m #ne[i]表示0...i范围前缀和后缀的最大匹配长度
    
    #TODO:求解next数组的过程,注意next数组是对模式串p求的
    j=0
    for i in range(1,m):
        while j and p[j]!=p[i]:
            #如果不等,j跳转到ne[j-1]
            j=ne[j-1] 
        if p[j]==p[i]:
            j+=1
        ne[i]=j
        
    #TODO:KMP匹配过程
    #p[0...j]和s[0...i]匹配,如果发现p[j]和s[i]不匹配,就递归地将p[ne[j-1]]和s[i]匹配
    j=0
    for i,v in enumerate(s):
        while j and p[j]!=v:
            j=ne[j-1]
        if p[j]==v:
            j+=1
        #匹配成功,返回在s中包含p的最左开头位置
        if j==m:
            return i-m+1
    #无法成功匹配,返回-1
    return -1
```

#### 1b.求第一个匹配的子串位置(纯净版)

```python
def kmp(s,p):
    n,m=len(s),len(p)
    ne=[0]*m
    
    j=0
    for i in range(1,m):
        while j and p[j]!=p[i]:
            j=ne[j-1] 
        if p[j]==p[i]:
            j+=1
        ne[i]=j
       
    j=0
    for i,v in enumerate(s):
        while j and p[j]!=v:
            j=ne[j-1]
        if p[j]==v:
            j+=1
        if j==m:
            return i-m+1
    return -1
```

#### 2a.求所有匹配的子串位置(纯净版)

```python
def kmp(s,p):
    n,m=len(s),len(p)
    ne=[0]*m
    
    j=0
    for i in range(1,m):
        while j and p[j]!=p[i]:
            j=ne[j-1] 
        if p[j]==p[i]:
            j+=1
        ne[i]=j
       
    j=0
    ans=[]
    for i,v in enumerate(s):
        while j and p[j]!=v:
            j=ne[j-1]
        if p[j]==v:
            j+=1
        if j==m:
            ans.append(i-m+1)
            j=ne[j-1]
    return ans
```

#### 3a.单纯求next数组(纯净版)

```python
def ne(p):
    m=len(p)
    ne=[0]*m
    
    j=0
    for i in range(1,m):
        while j and p[j]!=p[i]:
            j=ne[j-1] 
        if p[j]==p[i]:
            j+=1
        ne[i]=j
    return ne
```
## 2.Manacher算法

**解决的问题**:回文

### 1.暴力中心扩展求最长回文子串

```python
#求最长回文子串
class Solution:
    def longestPalindrome(self, s: str) -> str:
        mx=L=R=0
        n=len(s)
        for i in range(2*n-1):
            l,r=i//2,(i+1)//2 
            while l>=0 and r<n and s[l]==s[r]:
                l-=1
                r+=1
            if r-l-1>mx:
                mx=r-l-1
                L,R=l,r
        return s[L+1:R]
```

```python
#求最长回文子串长度
def f(s):
    ans=0
    n=len(s)
    for i in range(2*n-1):
        l,r=i//2,(i+1)//2 
        while l>=0 and r<n and s[l]==s[r]:
            l-=1
            r+=1
        ans=max(ans,r-l-1)
    return ans
```

### 2.Manacher

**时间复杂度O(n)**

应用Manacher之前,需要先对原串添加'#'分隔符,形成**Manacher扩展串**,扩展串一定为奇数长度,可以统一处理原串长度为奇数或者偶数的情况,同时注意扩展串利用的分隔字符不一定要是原串中没出现的字符,因为虚字符只会碰虚字符

扩展串的长度=2n+1,n为原串长度

原串中的i位置对应扩展串中的2i+1位置

**回文半径**:从回文中心走一半的长度

回文半径长度-1=原回文串长度

扩展串结束下标/2=原始串结束下标+1



**几个Manacher要用到的参数**:

**回文半径数组p**:p[i]为以i为中心的回文半径长度,注意半径要包含中心点

**回文覆盖右边界r**:从回文中心向右扩回文半径-1长度,得到的下标+1位置

**回文中心c**:最早使得回文覆盖右边界到达r的回文中心(可能有多个回文中心的r值都是一个,我们只考虑最靠左的回文中心)



**Manacher的四种情况**:

**i为当前遍历到的回文中心,r为之前计算过的最右回文覆盖右边界**

**1.r==i**,r没有包住i,暴力中心扩展即可,无法获得加速

如果r>i,落到下面三种情况,此时需要计算i关于c的对称点i',i'=2*c-i

**2.r>i**,且以i'为中心的回文区域在以c为中心的回文区域之**内**,那么p[i]=p[i'],即p[i]=p[2c-i]

**3.r>i**,且以i'为中心的回文区域在以c为中心的回文区域之**外**,那么p[i]=r-i

**4.r>i**,且以i'为中心的回文区域和以c为中心的回文区域**撞线**,从r之外位置进行扩展

**注意1和4情况r可能更新,2和3情况r一定不更新**

#### 1a.manacher模版(注释版)

```python
#模版:非常巧妙
def manacher(s):
    #扩展串2n+1长度
    n=len(s)<<1|1
    #p是回文半径数组
    p=[0]*n
    #ss是Manacher扩展串
    ss='#'+'#'.join(s)+'#'
    mx=0
    #i代表当前来到的中心,c代表回文中心,r代表回文覆盖右边界
    c=r=0
    for i in range(n):
        #至少的回文半径长度
        #这行代码涵盖了4种情况,r>i时走min(),r==i时回文串为单个字符,回文半径长度为1
        lens=min(p[2*c-i],r-i) if r>i else 1
        #考虑能不能往外扩,2和3情况会直接不执行while,只有1和4情况会执行while
        while i+lens<n and i-lens>=0 and ss[i+lens]==ss[i-lens]:
            lens+=1
        #更新回文覆盖右边界
        if i+lens>r:
            r=i+lens
            c=i
        mx=max(mx,lens)
        p[i]=lens
    #扩展串长度-1即为原串长度
    return mx-1
```

#### 1b.manacher模版(纯净版)

```python
def manacher(s):
    n=len(s)<<1|1
    p=[0]*n
    ss='#'+'#'.join(s)+'#'
    mx=0
    c=r=0
    for i in range(n):
        lens=min(p[2*c-i],r-i) if r>i else 1
        while i+lens<n and i-lens>=0 and ss[i+lens]==ss[i-lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        mx=max(mx,lens)
        p[i]=lens
    return mx-1
```



```python
#manacher求解具体回文串
#模版题:5(https://leetcode.cn/problems/longest-palindromic-substring/)
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def f(s):
            #扩展串2n+1长度
            n=len(s)<<1|1
            #p是回文半径数组
            p=[0]*n
            #ss是Manacher扩展串
            ss='#'+'#'.join(s)+'#'
            mx=end=0 #end标记最长回文半径在扩展串中对应的结束位置
            #i代表当前来到的中心,c代表回文中心,r代表回文覆盖右边界
            c=r=0
            for i in range(n):
                #至少的回文半径长度
                #这行代码涵盖了4种情况,r>i时走min(),r==i时回文串为单个字符,回文半径长度为1
                lens=min(p[2*c-i],r-i) if r>i else 1
                #考虑能不能往外扩,2和3情况会直接不执行while,只有1和4情况会执行while
                while i+lens<n and i-lens>=0 and ss[i+lens]==ss[i-lens]:
                    lens+=1
                #更新回文覆盖右边界
                if i+lens>r:
                    r=i+lens
                    c=i
                if lens>mx:
                    mx=lens
                    end=i+lens-1 #end记录最长回文半径的字符串在扩展串中的结束位置
                p[i]=lens
            #end//2即为原串中的结束位置+1
            #mx是扩展串最长回文半径,等于原串中最长回文串长度
            return end//2,mx-1
        end,size=f(s)
        return s[end-size:end]
```



## 3.Z函数(扩展KMP)

### 1.Z函数

**时间复杂度O(n)**

**Z函数解决的问题**:针对单一字符串s,z[i]表示后缀s[i:]与s的最长公共前缀长度

Z函数很像manacher,可以理解为manacher的一半

z[0]等价于s本身

**几个重要参数**:

**c**:匹配中心

**r**:匹配右边界

**z数组**:后缀s[i:]与s的最长公共前缀长度



**四种情况**:

**1.i=r**,没包住,暴力扩展

如果r>i,落到下面三种情况,此时需要计算i关于c的关键点i',i'=i-c

**2.r>i,关键点i'扩出的长度在大范围之内**,z[i]=z[i-c]

**3.r>i,关键点i'扩出的长度在大范围之外**,z[i]=r-i

**4.r>i,关键点i'扩出的长度在大范围撞线**,从r之外继续扩展

#### 1.模版1a(注释版)

```python
#模版:非常巧妙
def Z(s):
    n=len(s)
    z=[0]*n
    z[0]=n #z[0]表示s本身
    c=r=1
    #从下标1开始计算
    for i in range(1,n):
        lens=min(r-i,z[i-c]) if r>i else 0
        #涵盖四种情况,情况2和3不执行while,情况1和4执行while
        while i+lens<n and s[i+lens]==s[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        z[i]=lens
    #返回z数组
    return z
```

#### 2.模版1b(纯净版)

```python
def Z(s):
    n=len(s)
    z=[0]*n
    z[0]=n
    c=r=1
    for i in range(1,n):
        lens=min(r-i,z[i-c]) if r>i else 0
        while i+lens<n and s[i+lens]==s[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        z[i]=lens
    return z
```

### 2.E函数

**解决的问题**:针对两个字符串a和b,e[i]表示a[i:]和b的最长公共前缀长度

**求e数组需要先求出字符串B的z数组!!!,也可以用构造的方式跑一次b+'#'+a的z数组解决**

原理和z数组求解过程很类似,不再赘述

```python
#模版
def Z(s):
    n=len(s)
    z=[0]*n
    z[0]=n #z[0]表示s本身
    c=r=1
    #从下标1开始计算
    for i in range(1,n):
        lens=min(r-i,z[i-c]) if r>i else 0
        #涵盖四种情况,情况2和3不执行while,情况1和4执行while
        while i+lens<n and s[i+lens]==s[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        z[i]=lens
    #返回z数组
    return z

#求解a的e数组
def E(a,b):
    n,m=len(a),len(b)
    z=Z(b) #求解B的Z数组
    e=[0]*n
    c=r=0
    for i in range(n):
        lens=min(r-i,z[i-c]) if r>i else 0
        while i+lens<n and lens<m and a[i+lens]==b[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        e[i]=lens
    return e
```

````python
#也可以通过拼接字符串的形式单纯用Z函数生成e数组
def E(a,b):
    s=b+'#'+a
    n=len(s)
    z=[0]*n
    z[0]=n #z[0]表示s本身
    c=r=1
    #从下标1开始计算
    for i in range(1,n):
        lens=min(r-i,z[i-c]) if r>i else 0
        #涵盖四种情况,情况2和3不执行while,情况1和4执行while
        while i+lens<n and s[i+lens]==s[lens]:
            lens+=1
        if i+lens>r:
            r=i+lens
            c=i
        z[i]=lens
    #返回z数组
    return z[len(b)+1:]
````

## 4.字符串哈希

## 5.AC自动机

AC自动机=Trie+KMP

```c++
//AC自动机原始模版
//搜索关键词
//给定n个长度不超过50的由小写英文字母组成的单词,以及一篇长为m的文章,请问,有多少个单词在文章中出现了
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
using namespace std;

const int N=10010,S=55,M=1000010;
int n;
int tr[N*S][26],cnt=[N*S],idx;//cnt表示以每个节点结尾的单词数量
char str[M];
int q[N*S],ne[N*S];//q为bfs队列,ne为next数组

void insert()
{
    int p=0;
    for (int i=0;str[i];i++)
    {
        int t=str[i]-'a';
        if (!tr[p][t]) tr[p][t]=++idx;
        p=tr[p][t];
    }
    cnt[p]++;
}
void build()
{
    int hh=0,tt=-1;
    for (int i=0;i<26;i++)
        if (tr[0][i])
        	q[++tt]=tr[0][i];
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=0;i<26;i++)
        {
            int c=tr[t][i];
            if (!c) continue;
            int j=ne[t];
            while (j && !tr[j][i]) j=ne[j];
            if (tr[j][i]) j=tr[j][i];
            ne[c]=j;
            q[++tt]=c;
        }
    }
}
int main(){
    int T;
    scanf("%d",&T);
    while (T--){
        memset(tr,0,sizeof tr);
        memset(cnt,0,sizeof cnt);
        memset(ne,0,sizeof ne);
        idx=0;
        
        scanf("%d",&n);
        for (int i=0;i<n;i++){
            scanf("%s",str);
            insert();
        }
        
        build();
        scanf("%s",str);
        int res=0;
        for (int i=0,j=0;str[i];i++)
        {
            int t=str[i]-'a';
            while (j && !tr[j][t]) j=ne[j];
            if (tr[j][t]) j=tr[j][t];
            
            int p=j;
            while (p)
            {
                res+=cnt[p];
                cnt[p]=0;
                p=ne[p];
            }
        }
        printf("%d\n",res);
    }
    return 0;
}
```



```c++
//AC自动机Trie图优化模版
//搜索关键词
//给定n个长度不超过50的由小写英文字母组成的单词,以及一篇长为m的文章,请问,有多少个单词在文章中出现了
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
using namespace std;

const int N=10010,S=55,M=1000010;
int n;
int tr[N*S][26],cnt=[N*S],idx;//cnt表示以每个节点结尾的单词数量
char str[M];
int q[N*S],ne[N*S];//q为bfs队列,ne为next数组

void insert()
{
    int p=0;
    for (int i=0;str[i];i++)
    {
        int t=str[i]-'a';
        if (!tr[p][t]) tr[p][t]=++idx;
        p=tr[p][t];
    }
    cnt[p]++;
}
void build()
{
    int hh=0,tt=-1;
    for (int i=0;i<26;i++)
        if (tr[0][i])
        	q[++tt]=tr[0][i];
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=0;i<26;i++)
        {
            int p=tr[t][i];
            if (!p) tr[t][i]=tr[ne[t]][i];
            else
            {
                ne[p]=tr[ne[t]][i];
                q[++tt]=p;
            }
            
        }
    }
}
int main(){
    int T;
    scanf("%d",&T);
    while (T--){
        memset(tr,0,sizeof tr);
        memset(cnt,0,sizeof cnt);
        memset(ne,0,sizeof ne);
        idx=0;
        
        scanf("%d",&n);
        for (int i=0;i<n;i++){
            scanf("%s",str);
            insert();
        }
        
        build();
        scanf("%s",str);
        int res=0;
        for (int i=0,j=0;str[i];i++)
        {
            int t=str[i]-'a';
            j=tr[j][t]
            
            int p=j;
            while (p)
            {
                res+=cnt[p];
                cnt[p]=0;
                p=ne[p];
            }
        }
        printf("%d\n",res);
    }
    return 0;
}
```

## 6.后缀数组

## 7.后缀自动机

## 8.dp求最长公共子串

**常规做法是利用dp以O(nm)复杂度解决**

```python
#求s,t以i,j位置结尾的最长公共子串长度
def f(s,t):
    n,m=len(s),len(t)
    #f[i+1][j+1]表示s,t分别以i,j结尾的最长匹配长度
    f=[[0]*(m+1) for _ in range(n+1)]
    for i,x in enumerate(s):
        for j,y in enumerate(t):
            if s[i]==t[j]:
                f[i+1][j+1]=f[i][j]+1
    mx=list(map(max,f))
    return mx
```



```python
#求s,t以i结尾,j开头的最长公共子串长度
def f(s,t):
    n,m=len(s),len(t)
    #f[i+1][j]代表s中以i结尾,t中以j开头的最长匹配长度
    f=[[0]*(m+1) for _ in range(n+1)]
    for i,x in enumerate(s):
        for j,y in enumerate(t):
            if x==y:
                f[i+1][j]=f[i][j+1]+1
    mx=list(map(max,f))
    return mx
```



```python
#预处理lcp:2430(https://leetcode.cn/problems/maximum-deletions-on-a-string/)
#lcp[i][j] 表示 s[i:] 和 s[j:] 的最长公共前缀
lcp=[[0]*(n+1) for _ in range(n+1)]
for i in range(n-1,-1,-1):
    for j in range(n-1,i,-1):
        if s[i]==s[j]:
            lcp[i][j]=lcp[i+1][j+1]+1
```



```python
#后缀数组求最长公共子串
def suffix_array(s):
    """
    构建字符串的后缀数组
    """
    n = len(s)
    suffixes = [(s[i:], i) for i in range(n)]
    suffixes.sort()
    return [suffix[1] for suffix in suffixes]

def lcp_array(s, sa):
    """
    构建 LCP 数组
    """
    n = len(s)
    rank = [0] * n
    lcp = [0] * (n - 1)
    
    for i, suffix in enumerate(sa):
        rank[suffix] = i
    
    h = 0
    for i in range(n):
        if rank[i] > 0:
            j = sa[rank[i] - 1]
            while i + h < n and j + h < n and s[i + h] == s[j + h]:
                h += 1
            lcp[rank[i] - 1] = h
            if h > 0:
                h -= 1
    return lcp

def longest_common_substring(s1, s2):
    """
    使用后缀数组求两个字符串的最长公共子串
    """
    combined = s1 + '$' + s2 + '#'
    sa = suffix_array(combined)
    lcp = lcp_array(combined, sa)

    max_lcp = 0
    idx = 0
    for i in range(1, len(sa)):
        # 确保两个后缀来自不同的字符串
        if (sa[i - 1] < len(s1)) != (sa[i] < len(s1)):
            if lcp[i - 1] > max_lcp:
                max_lcp = lcp[i - 1]
                idx = sa[i - 1]

    return combined[idx:idx + max_lcp]
```

# 14.位运算进阶技巧

## 1.LogTrick

**本质是一类特殊滑动窗口**

**如果是算数运算,很容易求逆,但是里面涉及到位运算,求逆很困难.比如a|b=c,我们知道b,c,并不能反向求出a**

**因此需要特殊手段处理这类题目,可以理解为位运算+滑动窗口,我们将其命名为LogTrick.**

**这类题目往往也可以用双栈滑窗这种特殊技巧解决**

### 1.模版求最值

```python
#3171(https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/)
#LogTrick
#本质是利用或运算上界是有限的性质,题目中nums上界1e9,最多有29个二进制位有1
#而我们的二重循环计算顺序保证了nums[j]一定是nums[j-1]的子集
#如果nums[j]|x=nums[j],说明x是nums[j]的子集,也一定是nums[j-1],nums[j-2]....nums[0]的子集,此时循环中止
#第二重循环最多执行LogU=29次,总体时间复杂度为O(nLogU),n是1e5,因此不会超时
min=lambda x,y:x if x<y else y
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        ans=inf
        for i,x in enumerate(nums):
            ans=min(ans,abs(x-k))
            j=i-1
            while j>=0 and nums[j]|x!=nums[j]:
                nums[j]|=x
                ans=min(ans,abs(nums[j]-k))
                j-=1
        return ans
```

### 2.与二分结合求个数

```python
#3209(https://leetcode.cn/problems/number-of-subarrays-with-and-value-of-k/)
#LogTrick+二分
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        ans=0
        for i,x in enumerate(nums):
            j=i-1
            #num[j]不能是x的子集/x不能是nums[j]的超集,否则&完结果不变
            while j>=0 and nums[j]&x!=nums[j]:
                nums[j]&=x
                j-=1
            ans+=bisect_left(nums,k+1,0,i+1)-bisect_left(nums,k,0,i+1)
        return ans
```

## 2.拆位/贡献法

**本质是枚举二进制位**

```python
#477(https://leetcode.cn/problems/total-hamming-distance/)
#拆位/贡献法
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        n=len(nums)
        m=max(nums).bit_length()
        ans=0
        for i in range(m):
            t=sum(x>>i&1 for x in nums)
            ans+=t*(n-t)
        return ans
```



```python
#1863(https://leetcode.cn/problems/sum-of-all-subset-xor-totals/)
class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        return reduce(or_, nums) << (len(nums) - 1)
```

# 15.高精度

**在计算$ceil(a/b)(a/b结果为浮点数)$这类问题时,可以改为求$(a+b-1)//b\times b$,即乘上一个系数,用整数除法代替浮点数除法**

# 16.最小表示法

## 1.最小表示法模版

将一个字符串循环向左移动一位,得到若干字符串,其中字典序最小的被称为原串的最小表示法

时间复杂度O(n)

过程:

首先将原串(长度为n)复制一份,接到原串的后面,同时去掉最后一个字符(为了建立一一映射),得到串s,其长度为2n-1

初始化两个指针i,j分别指向长度为2n-1的串s的开头,下标分别为0,1,分别表示从i,j开头长度为n的子串

比较从i开始的串和从j开始的串的字典序大小关系

即分别比较s[i]和s[j],如果相等,则比较s[i+1]和s[j+1],直到两者不相等,设第一个不相等的位置为k,即s[i+k]!=s[j+k]

若s[i+k]>s[j+k],说明以i开头的串不是最小表示法,同时i~i+k之间任何位置开头的串都不是最小表示法,

因此i跳到i+k+1,即i+=k+1

同理若s[i+k]<s[j+k],j跳到j+k+1,即j+=k+1

如果全程没找到这样的k,直接break,因为说明原串是循环串

```c++
//项链
#include<bits/stdc++.h>
using namespace std;
const int N=1'000'010;
int n;
char a[N],b[N];

int get_min(char s[]){
    int i=0,j=1;
    while (i<n && j<n){
        int k=0;
        while (k<n && s[i+k]==s[j+k]) k++; //寻找不等位置
        if (k==n) break; //k==n说明没找到,存在循环节,直接break
        if (s[i+k]>s[j+k]) i+=k+1;
        else j+=k+1;
        if (i==j) j++; //i和j相同,j++保证错开
    }
    int k=min(i,j);
    s[k+n]=0;
    return k;

}
int main() {
    scanf("%s%s",a,b);
    n=strlen(a);
    memcpy(a+n,a,n);
    memcpy(b+n,b,n);

    int x=get_min(a),y=get_min(b);
    if (strcmp(a+x,b+y)) puts("No");
    else{
        puts("Yes");
        puts("a+x");
    }
    return 0;

}
```



```python
#899(https://leetcode.cn/problems/orderly-queue/?envType=problem-list-v2&envId=f4ErwFvQ)
#最小表示法模版
def f(s):
    i,j,n=0,1,len(s)
    s=s+s
    while i<n and j<n:
        k=0
        while k<n and s[i+k]==s[j+k]:k+=1
        if k==n:break
        if s[i+k]>s[j+k]:i+=k+1
        else:j+=k+1
        if i==j:j+=1
    k=min(i,j)
    return s[k:k+n]
```

## 2.最小表示法求最小后缀

虽然原理和求最大后缀类似,但是需要进行讨论,比较复杂

# 17.最大表示法

**最大表示法和最小表示法原理是类似的,这里不过多赘述**

## 1.模版

## 2.最大表示法求最大后缀

```python
#1163(https://leetcode.cn/problems/last-substring-in-lexicographical-order/)
class Solution:
    def lastSubstring(self, s: str) -> str:
        i,j,n=0,1,len(s)
        while j<n:
            k=0
            while j+k<n and s[i+k]==s[j+k]:
                k+=1
            if j+k<n and s[i+k]<s[j+k]:
                i,j=j,max(i+k+1,j+1)
            else:
                j+=k+1
        return s[i:]
```

# 18.曼哈顿距离转切比雪夫距离

切比雪夫的几何意义是在国际象棋棋盘上,国王从点a走到点b的最短距离,国王每次可以沿着水平,垂直或对角线方向走一格

$曼哈顿坐标系是通过切比雪夫坐标系逆时针旋转-45^{\circ}之后,再变为到原来的1/\sqrt2得到的$

$向量旋转公式(逆时针旋转\theta角)$
$$
(x',y')=(x,y)\cdot\begin{pmatrix}
cos\theta & sin\theta\\
-sin\theta & cos\theta
\end{pmatrix}=(xcos\theta-ysin\theta,xsin\theta+ycos\theta)
$$
设切比雪夫坐标系下的坐标为(x,y)

$那么新坐标为(x',y')=(xcos(-45^{\circ})-ysin(-45^{\circ}),xsin(-45^{\circ})+ycos(-45^{\circ}))$

​                                     $=(\frac{\sqrt2}{2}x+\frac{\sqrt2}{2}y,-\frac{\sqrt2}{2}x+\frac{\sqrt2}{2}y)$

$变为原来的1/\sqrt2即为(x+y,y-x)$

$设两个点坐标分别为a(x1,y1),b(x2,y2)$

$a,b之间的曼哈顿距离d1=|x1-x2|+|y1-y2|$
$a,b之间的切比雪夫距离d2=max(|x1-x2|,|y1-y2|)$

$将一个点(x,y)的坐标变为(x+y,y-x)后,新坐标系中的切比雪夫距离即为原坐标系中的曼哈顿距离$

即$d_{新坐标系切比雪夫}=max(|(x1+y1)-(x2+y2)|,|(y1-x1)-(y2-x2)|)$

​			      $=max(|(x1+y1)-(x2+y2)|,|(x1-y1)-(x2-y2)|)$

​                              $=d_{原坐标曼哈顿}=|x1-x2|+|y1-y2|$

$将一个点(x,y)的坐标变为((x+y)/2,(x-y)/2)后,新坐标系中的曼哈顿距离即为原坐标系中的切比雪夫距离$
$即d_{新坐标曼哈顿}=|(x1+y1)/2-(x2+y2)/2|+|(x1-y1)/2-(x2-y2)/2|$

​                        $=d_{原坐标切比雪夫}=max(|x1-x2|,|y1-y2|)$

