[TOC]

# 1.前缀和

## 1a.一维前缀信息(api)

注释版

```python
#前缀最小值,如果是求前缀和去掉min即可
pre=list(accumulate(nums,min))
#后缀最小值,如果是求后缀和去掉min即可
suf=list(accumulate(nums[::-1],min))[::-1]
```

纯净版

```python
pre=list(accumulate(nums,min))
suf=list(accumulate(nums[::-1],min))[::-1]
```

## 1b.一维前缀信息(手写)

```python
#前缀最小值
pre=nums[:]
for i in range(1,n):
    pre[i]=min(pre[i-1],pre[i])
#后缀最小值
suf=nums[:]
for i in range(n-2,-1,-1):
    suf[i]=min(suf[i+1],suf[i])
```



## 2a.二维前缀和(注释版)

```python
#二维前缀和
s=[[0]*(m+1) for _ in range(n+1)]
for i,row in enumerate(pizza):
    for j,x in enumerate(row):
        s[i+1][j+1]=s[i+1][j]+s[i][j+1]+x-s[i][j]
#查询左上角坐标(a,b),右下角坐标(c,d)的矩形的累加和
def query(a,b,c,d):
    return s[c+1][d+1]-s[a][d+1]-s[c+1][b]+s[a][b]
```

## 2b.二维前缀和(纯净版)

```python
s=[[0]*(m+1) for _ in range(n+1)]
for i,row in enumerate(pizza):
    for j,x in enumerate(row):
        s[i+1][j+1]=s[i+1][j]+s[i][j+1]+(x=='A')-s[i][j]
def query(a,b,c,d):
    return s[c+1][d+1]-s[a][d+1]-s[c+1][b]+s[a][b]
```

# 2.滑动窗口

引子:

滑动窗口乃算法入门第一篇,作为常见编程技巧,实乃重中之重,有诗云:

**滑**移数据细搜罗，**动**察分毫未肯讹。
**窗**启星河窥奥秘，**口**含灵韵解繁苛。
**智**通数理千重障，**巧**驭编程万里波。
**神**算奇功今尽显，**妙**参机要启先河。

滑动窗口的实现一般要结合哈希表或者变量来计数,同时用双指针l,r来维护左右边界

双指针在滑动窗口篇的用法较为套路和模式化,但是其实际有更多灵活的用法,欲知后事如何,且听下回分解(双指针用法会在第2章详细讲述)

## 1.定长滑动窗口

### 1.常规模版

**注意定长滑窗需要特判窗口大小为0的情况**

```python
#2461(https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/)
#定长滑窗模版
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        d=defaultdict(int)
        sums=ans=l=0
        for r,x in enumerate(nums):
            #入
            d[x]+=1
            sums+=x
            if r-l+1<k:
                continue
            #更新答案
            if len(d)==k:
                ans=max(ans,sums)
            #出
            out=nums[l]
            d[out]-=1
            if d[out]==0:
                del d[out]
            sums-=out
            l+=1
        return ans
```

### 2.模数滑窗

```python
#1652(https://leetcode.cn/problems/defuse-the-bomb/)
class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        n = len(code)
        ans = [0] * n
        r = k + 1 if k > 0 else n  # 第一个窗口的右开端点
        k = abs(k)
        s = sum(code[r - k: r])  # ans[0]
        for i in range(n):
            ans[i] = s
            s += code[r % n] - code[(r - k) % n]
            r += 1
        return ans
```

### 3.二维定长滑窗

**滑窗内元素从字母变成了字符串**

```python
#30(https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)
#滑动窗口
#和通常意义的定长滑窗的区别是,将原本的字母换成了单词
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        n=len(s) #s长度为n
        m=len(words) #words长度为m
        w=len(words[0]) #words中每个单词长度为w
        ans=[] #答案数组

        
        #把m*w看成一个大滑窗,我们预处理大滑窗偏移0~w这w种情况
        #其他偏移情况可以通过我们处理完的情况加减一个长度为w的单词得到,从而实现结果的复用
        for i in range(w):
            if i+m*w>n: #剪枝,防止滑窗边界大于n
                break 
            d=defaultdict(int) #每轮预处理清空哈希表
            for j in range(m):
                cur=s[i+j*w:i+(j+1)*w] #将从i开始的m个单词加入哈希表
                d[cur]+=1
            #判断两个哈希表是否相等的常用技巧,直接比较的话复杂度过高
            #这种做差的方法可以极大降低复杂度
            #对于words中的每个单词,一律在d中进行次数-1,对于不存在于d中的word,会产生负数
            #只有频数是0才删除key,负数的相当于赊账
            for word in words: 
                d[word]-=1
                if d[word]==0:
                    del d[word]
            #预处理结束后每次将大滑窗向右移动w长度
            for start in range(i,n-m*w+1,w):
                #start==i的时候直接判断d是否为空即可
                if start!=i:
                    #把单词看成一个元素,维护一个有m个元素的定长滑窗

                    #滑窗右边进
                    suf=s[start+(m-1)*w:start+m*w]
                    d[suf]+=1
                    #注意进也要判断频数是否为0,因为之前可能有负数频数(赊账的)
                    if d[suf]==0:
                        del d[suf]
                    
                    #滑窗左边出
                    pre=s[start-w:start]
                    d[pre]-=1
                    if d[pre]==0:
                        del d[pre]
                if not d:
                    ans.append(start)
        return ans

```

## 2.不定长滑动窗口

### 1.求最长/最大

```python
#1493(https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)
#不定长滑窗求最长
#原题可以转化成求最长的只包含一个1的子数组长度,最后减去1即可
max=lambda x,y:x if x>y else y
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        cnt=defaultdict(int)
        ans=l=0
        for r,x in enumerate(nums):
            cnt[x]+=1
            while cnt[0]>1:
                cnt[nums[l]]-=1
                l+=1
            ans=max(ans,r-l+1)
        return ans-1
```

### 2.求最短/最小

```python
模版题:209.长度最小的子数组
(https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
"""
这类题和上面解法类似
唯一区别是ans初始成inf,通过迭代求最小值来更新答案
"""
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n=len(nums)
        l=r=0
        sums=0
        minv=inf
        while r<n:
            sums+=nums[r]
            while sums>=target:
                if (cur:=(r-l+1))<minv:
                    minv=cur
                sums-=nums[l]
                l+=1
            r+=1
        return 0 if minv==inf else minv
```

### 3.越长越合法

```python
模版题:1358.包含所有三种字符的子字符串数目
(https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)
"""
这类题的特点是当while循环结束,左边界移动完成后,左边界向左侧延伸(0...l-1)共计l个位置都合法,因此每次答案需要加上左边界l
"""
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n=len(s)
        l=r=0
        d=defaultdict(int)
        cnt=0
        while r<n:
            d[s[r]]+=1
            while d['a']>0 and d['b']>0 and d['c']>0:
                d[s[l]]-=1
                l+=1
            cnt+=l #0...l-1位置开头,以r结尾的串都合法,所以加上l
            r+=1
        return cnt
```

### 4.越短越合法

```python
模版题:713.乘积小于k的子数组
(https://leetcode.cn/problems/subarray-product-less-than-k/description/)
"""
这类题和上面越长越合法类似,唯一区别是满足条件的都在滑动窗口内部(l...r),总计r-l+1种情况,因此每次答案需要加上r-l+1
"""
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k<=1:
            return 0
        n=len(nums)
        l=r=0
        product=1
        ans=0
        while r<n:
            product*=nums[r]
            while product>=k:
                product//=nums[l]
                l+=1
            ans+=r-l+1
            r+=1
        return ans 
```

### 5.恰好型滑动窗口

```python3
模版题:930.和相同的二元子数组
"""
这类题一般是求恰好k个,正常的滑动窗口处理这个不太好处理,而用前缀和处理这种又不够灵活
比较简单的思路是将它拆解成两个滑动窗口问题,即恰好k个等价于大于等于k的数目减去大于等于k+1的情况数
而大于等于k的数目就是上面提到的越长越合法问题,因此原问题就被转化成了两个越长越合法问题之差
为了简化代码,我们将越长越合法问题的代码封装成函数f,最终答案即为f(k)-f(k+1)

这类问题也可以用三指针滑窗解决,思路是一样的,只不过三指针滑窗是右边界r每移动一次,我们就做一次差,更新一次答案,而上面的写法是最后总和做差,最后一起更新答案,逻辑没有区别,不过三指针滑窗代码量较大,不如封装成函数清晰,这里不再赘述

还有一种解法是利用前缀和结合哈希表来解决,求某个固定的值可以转化成求两个前缀和之差的问题,当遍历到某个前缀和sums时,我们只要检查sums-target是否在哈希表中出现过就可以了,但是由于我们这章主要讨论滑动窗口问题,因此不再赘述
"""
#恰好型滑动窗口
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        n=len(nums)
        return self.f(nums,goal,n)-self.f(nums,goal+1,n)
    def f(self,nums,target,n):
        l=r=0
        sums=0
        ans=0
        while r<n:
            sums+=nums[r]
            #注意nums中含有0的情况,需要追加l<=r这个条件
            while l<=r and sums>=target:
                sums-=nums[l]
                l+=1
            ans+=l
            r+=1
        return ans 
    
#三指针滑动窗口
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        n=len(nums)
        #定义两个左指针
        l1=l2=r=0
        #滑动窗口维护两个
        sum1=sum2=0
        ans=0
        while r<n:
            sum1+=nums[r]
            sum2+=nums[r]

            while l1<=r and sum1>=goal:
                sum1-=nums[l1]
                l1+=1
            while l2<=r and sum2>=goal+1:
                sum2-=nums[l2]
                l2+=1
            ans+=l1-l2
            r+=1
        return ans 

    
#前缀和
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        presum=[0]
        sums=0
        d=defaultdict(int)
        d[0]=1
        ans=0
        for num in nums:
            sums+=num
            if sums-goal in d:
                ans+=d[sums-goal]
            presum.append(sums)
            d[sums]+=1
        return ans
```

## 3.双栈滑窗

```mysql
模版题:3095 或值至少K的最短子数组I
"""
双栈滑窗一般用来维护不可逆的滑动窗口,比如滑动窗口中保存子数组位运算和,这是不可逆运算,因此需要额外维护后缀和,将原数组作为栈股东呢更新后缀和,然后根据位运算性质,求解时不用遍历所有后缀和。当一个栈用完后,在右边再开一个栈,这就是双栈滑窗
"""
#双栈滑窗的题目也可以用logtrick方法,logtrick代码更短,但是时间复杂度稍高
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        ans,n=inf,len(nums)
        sums=l=bottom=0
        for r in range(n):
            sums|=nums[r]
            while l<=r and nums[l]|sums>=k:
                #等价于ans=min(ans,r-l+1)
                if (cur:=r-l+1)<ans:ans=cur
                if bottom==l:
                    for i in range(r-1,l,-1):nums[i]|=nums[i+1]
                    sums,bottom=0,r+1
                l+=1
        return -1 if ans==inf else ans
```

# 3.双指针

**双指针和滑动窗口一样,只有满足单调性时才可以使用**

## 1.固定次数的双指针

```python
#1471(https://leetcode.cn/problems/the-k-strongest-values-in-an-array/)
class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        n=len(arr)
        #中位数
        x=arr[(n-1)//2]
        ans=[0]*k
        i,j=0,n-1
        #每次选左边或右边,重复k次即可
        for p in range(k):
            if abs(arr[i]-x)>abs(arr[j]-x):
                ans[p]=arr[i]
                i+=1
            #相等时,由于原数组已经排序,因此右边元素一定更大,选右边
            else:
                ans[p]=arr[j]
                j-=1
        return ans
```

## 2.两数之和

**有序数组上的两数之和可以用双指针,无序数组则使用枚举右,维护左的方法,或者排序后再双指针**

## 3.三数之和

**更多数的和的问题都可以用三数之和的思想修改出来**

```python
#15(https://leetcode.cn/problems/3sum/)
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n=len(nums)
        nums.sort()
        ans=[]
        for k in range(n-2):
            x=nums[k]
            if k and x==nums[k-1]:continue
            if x+nums[k+1]+nums[k+2]>0:return ans #最小的三个数都大于0,直接返回答案
            if x+nums[-2]+nums[-1]<0:continue #最大的组合都<0,跳过本轮循环
            i,j=k+1,n-1
            while i<j:
                s=nums[i]+nums[j]
                if s+x>0:
                    j-=1
                elif s+x<0:
                    i+=1
                else:
                    ans.append([x,nums[i],nums[j]])
                    #当三数之和=0时
                    #i右移一位
                    i+=1
                    #i移动到大于之前的位置,去重
                    while i<j and nums[i]==nums[i-1]:
                        i+=1
                    #此时三数之和>0,为了达到0,nums[j]需要变小,因此j要左移到比之前小的位置,去重
                    while j<n-1 and nums[j]==nums[j+1]:
                        j-=1
        return ans
```

## 4.区间问题/恰好相等问题

求lo<=a+b<=hi的数目的问题,可以转化成求<=hi的数目减去<=lo-1的数目,这样就满足单调性,可以用双指针解决

同理求等于x的元组的数量,等价于求<=x的数量减去求<=x-1的数量

```python
#2563(https://leetcode.cn/problems/count-the-number-of-fair-pairs/)
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        #原问题可以转化成<=upper的数目减去<=lower-1的数目
        nums.sort()
        #求<=high的数对的数目
        def f(high):
            ans=0
            i,j=0,len(nums)-1
            while i<j:
                s=nums[i]+nums[j]
                if s>high:
                    j-=1
                else:
                    #越短越合法
                    ans+=j-i
                    i+=1
            return ans
        return f(upper)-f(lower-1)
```



```python
#1577(https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/)
#式子变形+排序+双指针+封装
#求等于x的数量等价于<=x的数量减去<=x-1的数量
#因此枚举nums1中的数x,用双指针求出nums2等于x的数量
#同理枚举nums2中的数x,用双指针求出nums1等于x的数量
class Solution:
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        def f(nums1,nums2):
            #求<=t的数目
            def g(nums,t):
                ans=0
                i,j=0,len(nums)-1
                while i<j:
                    s=nums[i]*nums[j]
                    if s<=t:
                        ans+=j-i
                        i+=1
                    else:
                        j-=1
                return ans
            return sum(g(nums2,x*x)-g(nums2,x*x-1) for x in nums1)
        return f(nums1,nums2)+f(nums2,nums1)
```

## 5.最小表示法

**最小表示法基于双指针实现,详情见刷题模版提高篇最小表示法章节**

## 6.同向双指针

**移除数组使原数组有序**

```python
#1574(https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/)
#双指针+前后缀分解思想
#枚举左,移动右
#将原数组分成三段,第一段是非递减前缀,第二段是非递减后缀,第三段是中间部分
#答案一定在第一段和第三段之中,枚举第一段终点l,移动第三段数的位置r使arr[r]>=arr[l]
#注意枚举第一段终点时要用arr[l-1]<=arr[l],这样才不会漏掉第一段最后一个位置
class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        n=len(arr)
        r=n-1
        while r and arr[r]>=arr[r-1]:
            r-=1
        if r==0:return 0 #arr非递减
        ans=r #删除arr[:r]
        l=0
        while l==0 or arr[l-1]<=arr[l]:
            #后缀段数字<前缀段数字,r向右移动
            while r<n and arr[r]<arr[l]:
                r+=1
            ans=min(ans,r-l-1)
            l+=1
        return ans
```

## 7.快慢指针

```python
#283(https://leetcode.cn/problems/move-zeroes/)
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        l=0
        for r in range(len(nums)):
            if nums[r]:
                nums[l],nums[r]=nums[r],nums[l]
                l+=1
```

## 8.双指针模拟栈

```py
#1089(https://leetcode.cn/problems/duplicate-zeros/)
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        n = len(arr)
        top = 0
        i = -1
        while top < n:
            i += 1
            top += 1 if arr[i] else 2
        j = n - 1
        if top == n + 1:
            arr[j] = 0
            j -= 1
            i -= 1
        while j >= 0:
            arr[j] = arr[i]
            j -= 1
            if arr[i] == 0:
                arr[j] = arr[i]
                j -= 1
            i -= 1
```

## 9.荷兰国旗算法

**利用双指针思想,将数组内元素分成三部分,<x,==x,>x**

```python
#75(https://leetcode.cn/problems/sort-colors/description/)
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        l,r=0,len(nums)-1
        i=l
        while i<=r:
            if nums[i]==1:
                i+=1
            elif nums[i]<1:
                nums[l],nums[i]=nums[i],nums[l]
                l+=1
                i+=1
            else:
                nums[r],nums[i]=nums[i],nums[r]
                r-=1
        return nums
```

## 11.双指针枚举距离k的数

```python
#arr1,arr2均有序,枚举arr1中的数i,判断arr2中是否有到i的距离<=k的数
#也可以用二分解决
arr1=kmp(s,a)
arr2=kmp(s,b)
n=len(arr2)
ans=[]
j=0
for i in arr1:
    while j<n and i-arr2[j]>k:
        j+=1
    if j<n and arr2[j]-i<=k:
        ans.append(i)
return ans
```



```python
#3455(https://leetcode.cn/problems/shortest-matching-substring/)
j=k=0
ans=inf
for i in range(len(pos1)):
    while j<len(pos2) and pos2[j]<pos1[i]+len(p1):
        j+=1
    if j==len(pos2):
        break
    while k<len(pos3) and pos3[k]<pos2[j]+len(p2):
        k+=1
    if k==len(pos3):
        break
    ans=min(ans,pos3[k]-pos1[i]+len(p3))
return -1 if ans==inf else ans
```

## 12.双序列双指针

### 1.同向写法1,同时限定i,j范围(类似归并排序)

```python
#2570(https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/)
class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        n,m=len(nums1),len(nums2)
        i=j=0
        arr=[]
        while i<n and j<m:
            idx1,v1=nums1[i]
            idx2,v2=nums2[j]
            if idx1==idx2:
                arr.append([idx1,v1+v2])
                i+=1
                j+=1
            elif idx1<idx2:
                arr.append(nums1[i])
                i+=1
            else:
                arr.append(nums2[j])
                j+=1
        while i<n:
            arr.append(nums1[i])
            i+=1
        while j<m:
            arr.append(nums2[j])
            j+=1
        return arr
```

### 2.同向写法2,枚举i范围,限定j范围

```python
#2337(https://leetcode.cn/problems/move-pieces-to-obtain-a-string/)
#双序列双指针
#L只能左移,因此如果start中L位置位于target中L位置位于的左侧(i<j),不合法
#同理R只能右移,因此如果start中R位置位于target中R位置的右侧(i>j),不合法
class Solution:
    def canChange(self, start: str, target: str) -> bool:
        #两个字符串去掉'_'后应该完全相同
        if start.replace('_','')!=target.replace('_',''):return False
        j=0
        for i,x in enumerate(start):
            if x=='_':continue
            while target[j]=='_':j+=1
            if i!=j and (x=='L')==(i<j):return False
            j+=1
        return True
```

### 3.相向

```python
#LCP18(https://leetcode.cn/problems/2vYnGI/)
mod=1_000_000_007
class Solution:
    def breakfastNumber(self, a: List[int], b: List[int], target: int) -> int:
        a.sort()
        b.sort()
        n,m=len(a),len(b)
        i,j=0,m-1
        ans=0
        while i<n and j>=0:
            x,y=a[i],b[j]
            if x+y>target:
                j-=1
            else:
                ans=(ans+j+1)%mod
                i+=1
        return ans
```

## 13.双指针求距离

```python
#1385(https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)
#双指针写法
class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        arr1.sort()
        arr2.sort()
        ans=j=0
        #注意python,c++中求容器大小的复杂度都是O(1)
        #对arr1排序保证了j指针不需要回退
        for x in arr1:
            #寻找arr2中第一个大于x-d的数
            while j<len(arr2) and arr2[j]<x-d:
                j+=1
            #如果不存在该数或者该数>x+d,说明[x-d,x+d]区间没有数,ans+1
            if j==len(arr2) or arr2[j]>x+d:
                ans+=1
        return ans
```

## 14.双指针遍历连续相同字符

```python
#809(https://leetcode.cn/problems/expressive-words/)
#同向双指针
#分别遍历两个字符串相同字母组成的分组,判断数量关系
class Solution:
    def expressiveWords(self, s: str, words: List[str]) -> int:
        def f(a,s):
            i=j=0
            n,m=len(a),len(s)
            if n>m:return False
            while i<n and j<m:
                if a[i]!=s[j]:return False
                cnt_a=cnt_s=0
                x=a[i]
                while i<n and a[i]==x:
                    i+=1
                    cnt_a+=1
                while j<m and s[j]==x:
                    j+=1
                    cnt_s+=1
                if cnt_a>cnt_s or cnt_a<cnt_s and cnt_s==2:return False
            return i==n and j==m
        return sum(f(word,s) for word in words)
```

## 15.双指针判断相邻交换问题

```python
#777(https://leetcode.cn/problems/swap-adjacent-in-lr-string/)
#本题是2337题换皮
#L只能向左,R只能向右
#同时去掉X两个字符串应该完全一样
class Solution:
    def canTransform(self, a: str, b: str) -> bool:
        if a.replace('X','')!=b.replace('X',''):return False
        j=0
        for i,x in enumerate(a):
            if x=='X':continue
            while b[j]=='X':j+=1
            if i!=j and (x=='L')==(i<j):return False
            j+=1
        return True
```

## 16.区间交集

**要求区间已经排好序的**

```python
#986(https://leetcode.cn/problems/interval-list-intersections/)
#同向双指针
#左区间取左侧大的,右区间取右侧小的
#同时右侧谁小谁的指针向右移动
max=lambda x,y:x if x>y else y
min=lambda x,y:x if x<y else y
class Solution:
    def intervalIntersection(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:
        i=j=0
        n,m=len(a),len(b)
        ans=[]
        while i<n and j<m:
            l1,r1=a[i]
            l2,r2=b[j]
            l,r=max(l1,l2),min(r1,r2)
            if l<=r:
                ans.append([l,r])
            if r1>r2:
                j+=1
            else:
                i+=1
        return ans

```

## 17.双指针求最小绝对差

```python
#面试题16.06(https://leetcode.cn/problems/smallest-difference-lcci/)
#双指针
#排序后比较两个指针对应的数
#如果a[i]<b[j],为了缩小绝对差,a[i]应该变大,i++
#如果a[i]>b[j],为了缩小绝对差,b[j]应该变大,j++
#如果相等,直接返回0
#本题特殊之处在于,不是到最后求出最小绝对差,而是对于每对不同的i,j,都更新一下最小绝对差
#从局部最小获得全局最小
class Solution:
    def smallestDifference(self, a: List[int], b: List[int]) -> int:
        a.sort()
        b.sort()
        n=len(a)
        min_diff=inf
        i=j=0
        n,m=len(a),len(b)
        while i<n and j<m:
            diff=abs(a[i]-b[j])
            if diff<min_diff:
                min_diff=diff
            if a[i]<b[j]:
                i+=1
            elif a[i]>b[j]:
                j+=1
            else:
                return 0
        return min_diff
```

## 18.双指针合并区间

```python
if v==ans[-1][0]:
    ans[-1][1]+=cnt
else:
    ans.append([v,cnt])
```

## 19.判断子序列

```python
#392(https://leetcode.cn/problems/is-subsequence/description/)
#双指针法,判断s是否是t的子序列
def f(s,t):
    n,m=len(s),len(t)
    i=j=0
    while i<n and j<m:
        if s[i]==t[j]:
            i+=1
            j+=1
        else:
            j+=1
    return i==n
```



```python
#迭代器写法,迭代器不会回退,迭代器每次会从上次的位置向后查找
#本质还是双指针思想,判断s是否是t的子序列
def f(s,t):
    t = iter(t)
    return all(c in t for c in s)
```

## 20.三指针

```python
#2367(https://leetcode.cn/problems/number-of-arithmetic-triplets/)
#三指针,可以做到O(n)时间,O(1)空间
#由于数组严格递增,具有单调性,因此可以用三指针求解
#三指针,i,j,k分别表示三元组第一个数,第二个数,第三个数
#如果第二个数+diff<x,j向右移动
#同理如果第一个数+2*diff<x,i向右移动
#注意当j=k时,nums[j]+diff>=x一定成立
#同理当i=k时,nums[i]+diff>=x一定成立
#因此i,j下标一定不会超过,因此一定不会越界
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        i=j=ans=0
        for x in nums:
            while nums[j]+diff<x:
                j+=1
            if nums[j]+diff>x:continue
            while nums[i]+2*diff<x:
                i+=1
            if nums[i]+2*diff==x:ans+=1
        return ans
```

## 21.下一个排列

```python
#31(https://leetcode.cn/problems/next-permutation/)
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        #TODO:倒序寻找第一个小于它相邻位的数
        n=len(nums)
        i=n-2
        while i>=0 and nums[i]>=nums[i+1]:
            i-=1
        
        #TODO:如果第一步找到则寻找该数右边最小的大于它的数,然后交换,如果没找到则跳过这步
        if i>=0:
            j=n-1
            while nums[j]<=nums[i]:
                j-=1
            nums[i],nums[j]=nums[j],nums[i]

        #TODO:翻转nums[i+1:],为了保证空间O(1),我们手动反转
        l,r=i+1,n-1
        while l<r:
            nums[l],nums[r]=nums[r],nums[l]
            l+=1
            r-=1
```



# 4.分组循环

**适用场景**：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。
**核心思想**：
- 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。
- 内层循环负责遍历组，找出这一组最远在哪结束。



```python
模版题:2760.最长奇偶子数组
(https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/)
# 分组循环
max = lambda x, y: x if x > y else y
class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        ans = i = 0
        while i < n:
            if nums[i] & 1 or nums[i] > threshold:
                i += 1
                continue
            start = i
            i += 1
            while i < n and nums[i] <= threshold and (nums[i] ^ nums[i - 1]) & 1:
                i += 1
            ans = max(ans, i - start)
        return ans

```



# 5.二分查找

```mysql
二分查找是一种常用的技巧,既可以单独使用,也可以结合贪心,动态规划以及图论算法等一起使用,
想要入门算法,就必须精通二分,下面我们来详细讲解一下二分
```



```python
需要用到二分查找的两种情况:
1.求>=x的第一个位置(最左位置/下界/lower_bound)
#示例代码,这段代码可以同时解决有重复元素和无重复元素的情况
ans=-1 #ans可以初始化成-1或n代表找不到时的标记
while l<=r:
    mid=(l+r)>>1
    if arr[mid]>=x:
        ans=mid
    	r=mid-1
    else:
        l=mid+1
#api版本,bisect_left的意思是x可以插在哪里,有多个相等的元素等于x时,x插入到第一次出现的位置
bisect_left(arr,x),当arr中元素均<x时,返回数组长度n

2.求<=x的最后一个位置(最右位置/上界/upper_bound)
需要注意的是,求<=x的最后一个位置其实等价于求>=x+1的第一个位置再减去1
#示例代码,这段代码可以同时解决有重复元素和无重复元素的情况
while l<=r:
    mid=(l+r)>>1
    if arr[mid]<=x:
        ans=mid
        l=mid+1
    else:
        r=mid-1
#api版本,bisect_right的意思是x可以插在哪里,有多个相等的元素等于x时,x插入到最后一次出现的位置后面的位置,因此需要额外减去1
bisect_left(arr,x+1)-1
bisect_right(arr,x)-1 #bisect_right本质是求>=x+1的第一个位置
这两种写法是等价的

3.求>x的第一个位置,即求>=x+1的第一个位置
bisect_left(arr,x+1)
bisect_right(arr,x)

4.求<x的第一个位置,即求<=x-1的第一个位置,即求>=x的位置再减去1
bisect_left(arr,x)-1
bisect_right(arr,x-1)-1

同时注意在查找严格相等的元素时,需要判断找到的元素是否和目标元素相等,因为bisect_left,bisect_right返回的可能是上下界的位置
我们之所以要掌握API的写法,是因为bisect_left,bisect_right的速度要比我们自己实现的二分快的多,在程序优化方面具有重大意义
```



```mysql
将上面4种情况归类,可以统一转化成>=某个数的形式,区别就是有时候要再减去1
在调用bisect_left,bisect_right时,要牢记,bisect_left(arr,x)等价于>=x,bisect_right(arr,x)等价于>=x+1
1.>=x,bisect_left(arr,x)或bisect_right(arr,x)-1
2.>x等价于>=x+1,bisect_left(arr,x+1)或bisect_right(arr,x)
3.<=x等价于>=x+1再-1,bisect_left(arr,x+1)-1或bisect_right(arr,x)-1
4.<x等价于<=x-1等价于>=x再-1,bisect_left(arr,x)-1或bisect_right(arr,x)-2
```



```mysql
1.>=x:
	bisect_left(arr,x),bisect_right(arr,x-1)
2.<x[<=x-1,(>=x)-1]
	bisect_left(arr,x)-1,bisect_right(arr,x-1)-1
3.>x[>=(x+1)]
	bisect_left(arr,x+1),bisect_right(arr,x)
4.<=x[(>=(x+1))-1]
	bisect_left(arr,x+1)-1,bisect_right(arr,x)-1
```



```mysql
特别注意事项:
bisect_left只能用于x,x+1,类似bisect_left(x-1)+1会造成错误,因为上一个数的上界+1不等于下一个数的上界
但是上一个数的下界等于下一个数的上界-1
bisect_right只能用于x,x-1,类似bisect_right(x+1)-1会造成错误,因为下一个数的下界-1不等于上一个数的下界
但是上一个数的下界+1等于下一个数的上界
```

## 1.二分算最短距离

```python
#1182(https://leetcode.cn/problems/shortest-distance-to-target-color/)
class Solution:
    def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        d=defaultdict(list)
        for i,c in enumerate(colors):
            d[c].append(i)
        m=len(queries)
        ans=[-1]*m
        for j,(i,c) in enumerate(queries):
            if c not in d:continue
            a=d[c]
            n=len(a)
            idx=bisect_left(a,i)
            ans[j]=min(a[idx]-i if idx<n else inf,i-a[idx-1] if idx>0 else inf)
        return ans
```

## 2.二分答案求最小

自定义判断函数f,然后range(up+1),up为上界,lo=down,dowen表示下界,查找值写成True

```python
#875(https://leetcode.cn/problems/koko-eating-bananas/)
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def f(k):
            return sum((x+k-1)//k for x in piles)<=h
        return bisect_left(range(max(piles)+1),True,lo=1,key=f)
```



# 6.对角线遍历

```python
#模版题:3446(https://leetcode.cn/problems/sort-matrix-by-diagonals/)
class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        #k=i-j+m,n为行数,m为列数
        n,m=len(grid),len(grid[0])
        for k in range(1,m+n):
            min_j=max(m-k,0)
            max_j=min(m+n-1-k,m-1)
            a=[grid[k+j-m][j] for j in range(min_j,max_j+1)]
            a.sort(reverse=min_j==0)
            for j,val in zip(range(min_j,max_j+1),a):
                grid[k+j-m][j]=val
        return grid
```

# 7.枚举

**枚举常见于暴力题或者模拟题,一些高难度算法题也会对枚举有一定要求**

## 1.枚举子串

```python
#3503(https://leetcode.cn/problems/longest-palindrome-after-substring-concatenation-i/)
class Solution:
    def longestPalindrome(self, s: str, t: str) -> int:
        ans=0
        #枚举s右边界
        for i in range(len(s)+1):
            #枚举s左边界
            for j in range(i+1):
                #枚举t右边界
                for p in range(len(t)+1):
                    #枚举t左边界
                    for q in range(p+1):
                        z=s[j:i]+t[q:p]
                        if z==z[::-1]:
                            ans=max(ans,len(z))
        return ans
```

# 8.二叉树

## 1.自顶向下dfs/先序遍历

**通常需要全局变量更新ans**

```python
#298(https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
#自顶向下dfs(先序遍历)
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        ans=0
        def f(root,pre,length):
            length=length+1 if root.val==pre+1 else 1
            nonlocal ans
            if length>ans:
                ans=length
            if root.left:
                f(root.left,root.val,length)
            if root.right:
                f(root.right,root.val,length)
        f(root,root.val-1,0)
        return ans
```

## 2.自底向上dfs/后序遍历/树型dp

**一般返回值为多元组形式,需要维护多个返回值**

```python
#298(https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
#自底向上dfs
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        def f(root):
            if not root:
                return 0,0
            lh,lans=f(root.left)
            rh,rans=f(root.right)
            if root.left and root.left.val!=root.val+1:
                lh=0
            if root.right and root.right.val!=root.val+1:
                rh=0
            h=max(lh,rh)+1
            return h,max(lans,rans,h)
        return f(root)[1]
```

## 3.判断两棵二叉树是否相同

```python
#100(https://leetcode.cn/problems/same-tree/)
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        def f(p,q):
            return p is q if not p or not q else\
                   p.val==q.val and f(p.left,q.left) and f(p.right,q.right)
        return f(p,q)
```

## 4.判断两棵二叉树是否对称

```python
#101(https://leetcode.cn/problems/symmetric-tree/)
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def f(p,q):
            return p is q if not p or not q else\
                   p.val==q.val and f(p.left,q.right) and f(p.right,q.left)
        return f(root.left,root.right)
```

## 5.判断子树

```python
#572(https://leetcode.cn/problems/subtree-of-another-tree/)
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        #判断相同的树
        def f(p,q):
            return p is q if not p or not q else\
                   p.val==q.val and f(p.left,q.left) and f(p.right,q.right)
        def g(root):
            if not root:
                return False
            return g(root.left) or g(root.right) or f(root,subRoot)
        return g(root)
```

## 6.树的直径

### 1.计入空节点模版(注释版)

```python
#543(https://leetcode.cn/problems/diameter-of-binary-tree/description/)
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans=0
        #f返回值代表root的最长链
        def f(root):
            #空节点返回-1,这样一个树的某个子树如果为空,该方向的链长+1后就是0
            if not root:
                return -1
            #d1,d2分别代表左右子树的最长链
            d1=f(root.left)+1
            d2=f(root.right)+1
            nonlocal ans
            #用d1+d2更新全局最大值(直径)
            ans=max(ans,d1+d2)
            return max(d1,d2)
        f(root)
        return ans
```

### 2a.计入空节点模版(纯净版)

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans=0
        def f(root):
            if not root:
                return -1
            d1=f(root.left)+1
            d2=f(root.right)+1
            nonlocal ans
            ans=max(ans,d1+d2)
            return max(d1,d2)
        f(root)
        return ans
```

### 2b.不计入空节点模版(纯净版)

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans=0
        def f(root):
            d1=d2=0
            if root.left:
                d1=f(root.left)+1
            if root.right:
                d2=f(root.right)+1
            nonlocal ans
            ans=max(ans,d1+d2)
            return max(d1,d2)
        f(root)
        return ans
```

## 7.最近公共祖先

```python
#236(https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
#如果是空或者p,q返回当前节点
#如果左右返回值都不为空,返回当前节点
#否则返回真的一边,如果两边都不是真就为空
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def f(root):
            if root is None or root is p or root is q:
                return root
            l=f(root.left)
            r=f(root.right)
            if l and r:
                return root
            return l or r
        return f(root)
```

## 8.二叉搜索树

### 1.二叉搜索树中序遍历是有序

```python
#530(https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)
#二叉搜索树的性质,中序遍历是有序的
#而有序序列绝对差最小值一定发生在相邻两数之间
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        #引入全局变量记录全局绝对差最小值以及上一个遍历的数
        ans=inf
        pre=-inf
        def f(root):
            if not root:
                return 
            f(root.left)
            nonlocal ans,pre
            ans=min(ans,root.val-pre)
            pre=root.val
            f(root.right)
        f(root)
        return ans
```

## 9.层序遍历

```python
#102(https://leetcode.cn/problems/binary-tree-level-order-traversal/)
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        q=deque([root])
        ans=[]
        while q:
            size=len(q)
            res=[]
            for i in range(size):
                cur=q.popleft()
                res.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            ans.append(res)
        return ans
```

# 9.回溯

天下难题出回溯,回溯变化甲天下

回溯问题主要分两种,一种是求出所有情况,另一种是求出一种情况

回溯本质是带路径递归,别名爆搜/dfs,往往和剪枝结合

这里我们主要介绍**划分型回溯**的几种变式,因为其变化最为复杂,且非常容易和划分型dp混淆

## 1.求出所有方案(正向)

**求出所有方案时,选或不选必须都走一遍**

```python
#131(https://leetcode.cn/problems/palindrome-partitioning/)
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans=[]
        #i代表某个子串开始位置,k代表上一个子串开始位置,s[i:k]代表当前子串,path记录路径
        def f(i,k,path):
            if i==-1:
                ans.append(path)
                return
            #不在当前位置截断,继续向前
            if i:
                f(i-1,k,path)
            #在当前位置截断
            t=s[i:k]
            if t==t[::-1]:
                f(i-1,i,[t]+path)
        n=len(s)
        f(n-1,n,[])
        return ans 
```

## 2.求出一种情况(正向)

**求出一种情况即可时,选或不选用or连接实现剪枝**

```python
# 1849(https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/)
class Solution:
    def splitString(self, s: str) -> bool:
        def f(i,k,x,cnt):
            if i==-1:
                return cnt>=2
            t=int(s[i:k])
            return i>0 and f(i-1,k,x,cnt) or (x==-1 or t-x==1) and f(i-1,i,t,cnt+1)
        n=len(s)
        return f(n-1,n,-1,0)
```

## 3.求出一种情况(反向)

```python
#306(https://leetcode.cn/problems/additive-number/description/)
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n=len(num)     
        #和正向写法类似,k表示上一个字符串结束位置的下一个位置,i表示当前字符串的结束位置
        def f(i,k,x,y,cnt):
            if i==n:
                return cnt>=3
            w=num[k:i+1]
            t=int(w)
            return i<n-1 and f(i+1,k,x,y,cnt) or (w=='0' or w[0]!='0') and (y==-inf or t==x+y) and f(i+1,i+1,t,x,cnt+1)
        return f(0,0,-inf,-inf,0)
```

## 4.求出所有情况(反向)

```python
#93(https://leetcode.cn/problems/restore-ip-addresses/)
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        n=len(s)
        ans=[]        
        def f(i,k,path,cnt):
            if i==n:
                if cnt==4:
                    nonlocal ans
                    ans.append(path)
                return
            w=s[k:i+1]
            t=int(w)
            if i<n-1:
                f(i+1,k,path,cnt)
            if 0<=t<=255 and (w=='0' or w[0]!='0'):
                f(i+1,i+1,path+w+('' if i==n-1 else '.'),cnt+1)
        f(0,0,'',0)
        return ans
```

# 10.位运算

```python
位运算性质:
1.随着AND的数越来越多,AND只会越来越小
2.随着OR的数越来越多,OR只会越来越大
```



## 1.求二进制位数

**n.bit_length()**

```python
#3370(https://leetcode.cn/problems/smallest-number-with-all-set-bits/)
class Solution:
    def smallestNumber(self, n: int) -> int:
        return (1<<n.bit_length())-1
```

## 2.判断子集

**$a\subseteq b \Leftrightarrow$ a&b=a或者a|b=b或者a&~b=0**

## 3.求二进制表示中1的个数

**n.bit_count()**

```python
#1356(https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)
class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        return sorted(arr,key=lambda p:(p.bit_count(),p))
```

## 4.十进制转二进制

**f"{x :0{n}b}":将数字x转化成长度为n的二进制字符串,不足部分补上前导0**

```python
#3211(https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros/description/)
class Solution:
    def validStrings(self, n: int) -> List[str]:
        ans = []
        mask = (1 << n) - 1
        for x in range(1 << n):
            if (x >> 1) & x == 0:
                # 0{n}b 表示长为 n 的有前导零的二进制
                ans.append(f"{x ^ mask:0{n}b}")
        return ans
```

## 5.判断二进制位是否全为1

**x&(x+1)==0**

```python
#693(https://leetcode.cn/problems/binary-number-with-alternating-bits/)
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        t=n^(n>>1)
        return t&(t+1)==0
```

## 6.利用位运算实现集合功能

**利用位运算获得的掩码,很多时候可以充当集合,实现并集交集等运算**

```python
#2657(https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/)
class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        a,b,ans=0,0,[]
        for x,y in zip(A,B):
            a|=1<<x
            b|=1<<y
            ans.append((a&b).bit_count())
        return ans
```

## 7.lowbit

**x&(-x) :即lowbit,取出最低位**

**x&(x-1):删除最低位的1,等价于x-=x&-x**

**x|(x+1):将最低位的0替换成1,等价于x|=y&-y,其中y=~x**

利用这一规律可以判断2的幂等

```python
#231(https://leetcode.cn/problems/power-of-two/)
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and n&n-1==0

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and n&(-n)==n
```

## 8.十六进制掩码

**利用十六进制掩码,很多时候可以O(1)时间内解决问题**

```python
#2595(https://leetcode.cn/problems/number-of-even-and-odd-bits/description/)
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        #0x555表示0b010101010101,0xAAA表示0b101010101010
        return [(n&0x555).bit_count(),(n&0xaaa).bit_count()]
```

## 9.分配律

**布尔代数有着类似乘法分配律一样的性质**

1.x|(y&z)=(x|y)&(x|z)

2.x&(y|z)=(x&y)|(x&z)

3.x&(y^z)=(x&y)^(x&z)

# 11.贪心

## 1.反悔贪心

**反悔贪心分两种,一种是一次反悔一个,用if即可,另一种是一次反悔多个,需要用while循环**

```python
#模版题LCP30(https://leetcode.cn/problems/p0NxJO/)
#一次反悔一个
class Solution:
    def magicTower(self, nums: List[int]) -> int:
        if sum(nums)<0:
            return -1
        hp,ans=1,0
        pq=[]
        for x in nums:
            if x<0:
                heappush(pq,x)
            hp+=x
            if hp<1:
                hp-=heappop(pq) #反悔
                ans+=1
        return ans
```



```python
#模版题871(https://leetcode.cn/problems/minimum-number-of-refueling-stops/)
#一次反悔多个
class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        stations.append([target,0])
        fuel=startFuel
        pq=[]
        ans=0
        for x,y in stations:
            while fuel<x and pq:
                fuel+=-heappop(pq) #一次反悔多个
                ans+=1
            if fuel<x:
                return -1
            heappush(pq,-y)
        return ans
```

## 2.区间操作

### 1.区间合并

```python
#56(https://leetcode.cn/problems/merge-intervals/)
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        ans=[]
        for l,r in intervals:
            if ans and l<=ans[-1][1]:
                ans[-1][1]=max(ans[-1][1],r)
            else:
                ans.append([l,r])
        return ans
```

## 2.区间最多重叠数

```python
#2406(https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/)
class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        pq = []
        for left, right in intervals:
            if pq and left > pq[0]: 
                heapreplace(pq, right)
            else: 
                heappush(pq, right)
        return len(pq)
```

# 12.倍增

## 1a.树上倍增(注释版)

```python
#1483(https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/)
class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        #从叶子节点跳到根节点最多能跳2^m步,m是多少,m上界为log2(N)下取整,即n.bit_length()-1
        m=n.bit_length()-1
        #pa[x][i]表示x的第2^i个祖先节点
        #pa[x][0]表示x的第2^0(1)个祖先(即父节点)
        #pa[x][1]表示x的第2^1(2)个祖先(即爷爷节点)
        #pa[x][i+1]=pa[pa[x][i]][i],即往上跳2^(i+1)步,等价于先跳2^i步到点t,然后从点t再跳2^i步,t=pa[x][i]
        pa=[[p]+[-1]*m for p in parent]
        #注意必须先枚举i后枚举x,这样在计算pa[x][i+1]时,才能保证pa[t][i]之前被计算过(t=pa[x][i])
        for i in range(m):
            for x in range(n):
                #如果t之前被算出来,那么更新pa[x][i+1]
                #如果t==-1,就说明无法从该点向上跳2^i步,自然也就跳不了2^(i+1)步了
                if (t:=pa[x][i])!=-1:
                    pa[x][i+1]=pa[t][i]
        self.pa=pa
        

    def getKthAncestor(self, node: int, k: int) -> int:
        #二进制拆分,比如14=8+4+2,其二进制为1110,可以先跳2步,然后4步,8步
        #这可以用位运算右移加取最低位实现
        for i in range(k.bit_length()):
            if k>>i&1:
                node=self.pa[node][i]
                if node<0:
                    break
        return node
```

## 1b.树上倍增(纯净版)

```python
class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        m=n.bit_length()-1
        pa=[[p]+[-1]*m for p in parent]
        for i in range(m):
            for x in range(n):
                if (t:=pa[x][i])!=-1:
                    pa[x][i+1]=pa[t][i]
        self.pa=pa
        

    def getKthAncestor(self, node: int, k: int) -> int:
        for i in range(k.bit_length()):
            if k>>i&1:
                node=self.pa[node][i]
                if node<0:
                    break
        return node
```

## 2.数组上倍增

**注意:数组上倍增不需要特判-1,只有树上倍增需要,因为树上点不能无限向上跳**

### 1.从一个点跳到另一个点要多少步

```python
#3534(https://leetcode.cn/problems/path-existence-queries-in-a-graph-ii/)
class Solution:
    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[int]:
        #将nums排序,idx中的数即为nums的原始下标
        idx=sorted(range(n),key=lambda p:nums[p])
        rank=[0]*n
        for i,x in enumerate(idx):
            rank[x]=i
        mx=n.bit_length()
        #倍增数组
        pa=[[0]*mx for _ in range(n)]
        left=0
        #计算每个数向左一步最多可以跳多远
        for i,x in enumerate(idx):
            while nums[x]-nums[idx[left]]>maxDiff:
                left+=1
            pa[i][0]=left
        #注意这种写法中,跳越界的情况一律视为跳到0
        for i in range(mx-1):
            for x in range(n):
                p=pa[x][i]
                pa[x][i+1]=pa[p][i]
        ans=[]
        for l,r in queries:
            if l==r:
                ans.append(0)
                continue
            l,r=rank[l],rank[r]
            if l>r:
                l,r=r,l
            res=0
            for i in range(mx-1,-1,-1):
                #考虑跳到l+1位置,最后再跳一步
                #因为我们没有设计诸如-1来标记越界位置
                #当步子迈大时一律视为跳到0
                if pa[r][i]>l:
                    res|=1<<i
                    r=pa[r][i]
            ans.append(-1 if pa[r][0]>l else res+1)
        return ans
```

# 13.组合数

```python
模版题:3179(https://leetcode.cn/problems/find-the-n-th-value-after-k-seconds/description/)
即求组合数C(a,b)%mod,a>=b,mod为大素数
```

## 1.直接用api求组合数

```python
mod=1000000007
def comb(n,k):
    return comb(n,k)%mod
```

## 2.递推预处理组合数,适用于a,b较小的情况

```python
mod=1000000007
N=2000
C=[[0]*N for _ in range(N)]
C[0][0]=1
for i in range(1,N):
    for j in range(i+1):
        C[i][j]=1 if not j else C[i-1][j]+C[i-1][j-1]   
def comb(n,k):
    return C[n][k]%mod
```

## 3.通过阶乘和逆元预处理组合数,适用于a,b较大的情况

**注意,python的pow()比手写的乘法快速幂还快,因此qmi可以用pow代替**

### 1a.利用pow求快速幂(注释版)

```python
#用pow代替手写的qmi
mod=1_000_000_007
N=2000
fact=[0]*N
infact=[0]*N
fact[0]=infact[0]=1
for i in range(1,N):
    fact[i]=fact[i-1]*i%mod
    infact[i]=infact[i-1]*pow(i,mod-2,mod)%mod #费马小定理+乘法快速幂求逆元
#C(a,b)=a!/(b!*(a-b)!),组合数转化成阶乘公式
def comb(n,k):
	return fact[n]*infact[k]%mod*infact[n-k]%mod
```

### 1b.利用pow求快速幂(纯净版)

```python
mod=1_000_000_007
N=2000
fact=[0]*N
infact=[0]*N
fact[0]=infact[0]=1
for i in range(1,N):
    fact[i]=fact[i-1]*i%mod
    infact[i]=infact[i-1]*pow(i,mod-2,mod)%mod
def comb(n,k):
    return fact[n]*infact[k]%mod*infact[n-k]%mod
```

### 2a.手写求快速幂(注释版)

```python
mod=1_000_000_007
N=2000
def qmi(a,k,p):
    res=1
    while k:
        if k&1:res=res*a%p
        a=a*a%p
        k>>=1
    return res
fact=[0]*N
infact=[0]*N
fact[0]=infact[0]=1
for i in range(1,N):
    fact[i]=fact[i-1]*i%mod
    infact[i]=infact[i-1]*qmi(i,mod-2,mod)%mod #费马小定理+乘法快速幂求逆元
def comb(n,k):
    #C(a,b)=a!/(b!*(a-b)!),组合数转化成阶乘公式
    return fact[n]*infact[k]%mod*infact[n-k]%mod
```

### 2b.手写求快速幂(纯净版)

```python
mod=1_000_000_007
N=2000
def qmi(a,k,p):
    res=1
    while k:
        if k&1:res=res*a%p
        a=a*a%p
        k>>=1
    return res
fact=[0]*N
infact=[0]*N
fact[0]=infact[0]=1
for i in range(1,N):
    fact[i]=fact[i-1]*i%mod
    infact[i]=infact[i-1]*qmi(i,mod-2,mod)%mod
def comb(n,k):
    return fact[n]*infact[k]%mod*infact[n-k]%mod
```

## 4.组合数模2余数

C(n,k)%2=1等价于n&k==k,即k是n的子集,具体证明过程由lucas定理和位运算性质推出

## 5.组合数模非素数的余数

需要使用扩展卢卡斯定理

# 14.组合数学

## 1.错排公式

1.递推式

$f(n)=(n-1)(f(n-1)+f(n-2)),其中f(0)=1,f(1)=0$

2.表达式

$f(n)=n!\displaystyle\sum_{k=2}^n\frac{(-1)^k}{k!}$

## 2.多重集的排列数

$f(n)=\frac{n!}{\displaystyle\prod_{i=1}^{k}n_i!}$

# 15.质数判断

## 1.暴力

适用于验证较小的数是否是质数

**时间复杂度**$O(\sqrt n)$

```python
p = lambda n: n >= 2 and all(n % i for i in range(2, isqrt(n) + 1))
```

## 2.Miller-Rabin测试

适用于验证较大的数是否是质数

1.每次选择1~n-1范围上的随机数字,或者指定一个比n小的质数,进行测试

2.原理:费马小定理,Carmichael,二次探测定理,乘法同余,快速幂

3.经过s次Miller-Rabin测试,s越大出错几率越低,但是速度也会越慢,一般测试20次以内即可

**时间复杂度**$O(s(logn)^3)$,s代表测试次数

```python
#Miller-Rabin测试只适合检验特别大的数是否是素数,比如n=10^18
#质数个数代表测试次数,如果想增加测试次数就继续增加更大的质数
prime=[2,3,5,7,11,13,17,19,23,29,31,37]
#返回n是不是合数
def witness(a,n):
    u,t=n-1,0
    while u&1==0:
        t+=1
        u>>=1
    x1=pow(a,u,n)
    for i in range(1,t+1):
        x2=pow(x1,2,n)
        if x2==1 and x1!=1 and x1!=n-1:
            return True
        x1=x2
    if x1!=1:
        return True
    return False
def p(n):
    if n<=2:
        return n==2
    #偶数不是素数
    if n&1==0:
        return False
    i=0
    while i<len(prime) and prime[i]<n:
        if witness(prime[i],n):
            return False
        i+=1
    return True
```

# 16.质因数分解

```python
def f(n):
    i,x=2,n
    p=[]
    while i<=isqrt(x):
        if x%i==0:
            p.append(i)
            while x%i==0:
                x//=i
        i+=1
    if x>1:
        p.append(x)
    return p
```

# 17.质数筛

## 1a.埃氏筛(注释版)

时间复杂度$O(log(logn))$

```python
#3115(https://leetcode.cn/problems/maximum-prime-difference/)
#预处理所有素数,埃氏筛,p[i]为True,说明i是素数,否则不是素数
N=100
p=[True]*(N+1)
p[0]=p[1]=False
for i in range(2,isqrt(N)+1):
    if p[i]:
        for j in range(i*i,N+1,i):
            p[j]=False
class Solution:
    def maximumPrimeDifference(self, nums: List[int]) -> int:
        i,j=0,len(nums)-1
        #题目中说明至少有一个素数,因此可以这样写
        while not p[nums[i]]:
            i+=1
        while not p[nums[j]]:
            j-=1
        return j-i
```

## 1b.埃氏筛(纯净版)

```python
N=100
p=[True]*(N+1)
p[0]=p[1]=False
for i in range(2,isqrt(N)+1):
    if p[i]:
        for j in range(i*i,N+1,i):
            p[j]=False
```

## 2.欧拉筛(线性筛)

时间复杂度$O(n)$

每个合数只筛一次,即每个合数只被自己的最小质因子筛

埃氏筛是对于每个质数,将是其倍数的数全筛掉,这样会导致同一个合数被筛多次

欧拉筛在此基础上进行改进,每个合数只被其最小质因子筛掉

实际实现时,对于每个质数,乘上<=lpf[x]的质数,lpf[x]指的是x的最小质因子

注意欧拉筛的过程中必须要求出质数数组

和埃氏筛相比,欧拉筛时间复杂度更优

每个合数只被筛一次,因此时间复杂度是O(n),但是常数稍大

欧拉筛的特点是在筛质数同时会顺便处理出lpf(最小质因子)

因此如果题目同时要判断质数以及用到lpf,使用欧拉筛会更快

```python
N=100_000
p=[True]*(N+1)
p[0]=p[1]=False
primes=[]
for i in range(2,N+1):
    if p[i]:
        primes.append(i)
    for x in primes: #p都是<=i的
        if x*i>=N:
            break
        p[x*i]=False
        if i%x==0: #x是i的lpf(最小质因子)
            break
```

# 16.基础图论算法

## 1.bfs计算最短路

```python
#3243(https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/)
class Solution:
    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        g=[[i+1] for i in range(n-1)]
        def f():
            dis=0
            q=deque([0])
            vis={0}
            while q:
                size=len(q)
                for i in range(size):
                    cur=q.popleft()
                    if cur==n-1:
                        return dis
                    for x in g[cur]:
                        if x not in vis:
                            q.append(x)
                            vis.add(x)
                dis+=1
        ans=[]
        for l,r in queries:
            g[l].append(r)
            ans.append(f())
        return ans
```

# 17.网格图bfs

**注意可以向四个方向走的题目不能用dp,因为不满足无后效性,只能用bfs或者dfs,涉及到求距离时,则只能用bfs**
## 1.单源bfs

**只有一个起点**

### 1.四方向

```python
move=[(1,0),(-1,0),(0,1),(0,-1)]
n,m=len(grid),len(grid[0])
start=(0,0)
end=(n-1,m-1)
q=deque([start])
vis={start}
dis=0
while q:
    size=len(q)
    for _ in range(size):
        x,y=q.popleft()
        if (x,y)==end:
            return dis
        for dx,dy in move:
            nx,ny=x+dx,y+dy
            if 0<=nx<n and 0<=ny<m and (nx,ny) not in vis and grid[nx][ny]==0:
                vis.add((nx,ny))
                q.append((nx,ny))
    dis+=1
return -1
```

### 2.八方向

```python
move=[(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]
n,m=len(grid),len(grid[0])
start=(0,0)
end=(n-1,m-1)
q=deque([start])
vis={start}
dis=1
while q:
    size=len(q)
    for _ in range(size):
        x,y=q.popleft()
        if (x,y)==end:
            return dis
        for dx,dy in move:
            nx,ny=x+dx,y+dy
            if 0<=nx<n and 0<=ny<m and (nx,ny) not in vis and grid[nx][ny]==0:
                vis.add((nx,ny))
                q.append((nx,ny))
    dis+=1
return -1
```

### 3.马踏八方

```python
move=[(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1),(-2,1),(-1,2)]
n,m=len(grid),len(grid[0])
start=(0,0)
end=(n-1,m-1)
q=deque([start])
vis={start}
dis=1
while q:
    size=len(q)
    for _ in range(size):
        x,y=q.popleft()
        if (x,y)==end:
            return dis
        for dx,dy in move:
            nx,ny=x+dx,y+dy
            if 0<=nx<n and 0<=ny<m and (nx,ny) not in vis and grid[nx][ny]==0:
                vis.add((nx,ny))
                q.append((nx,ny))
    dis+=1
return -1
```

## 2.多源bfs

**有多个起点**

```python
move=[(1,0),(-1,0),(0,1),(0,-1)]
n,m=len(grid),len(grid[0])
q=deque()
vis=set()
for i,row in enumerate(grid):
    for j,x in enumerate(row):
        if x:
            q.append((i,j))
            vis.add((i,j))
if len(q)==m*n:
    return -1
dis=0
while q:
    size=len(q)
    for _ in range(size):
        x,y=q.popleft()
        for dx,dy in move:
            nx,ny=x+dx,y+dy
            if 0<=nx<n and 0<=ny<m and (nx,ny) not in vis:
                vis.add((nx,ny))
                q.append((nx,ny))
    dis+=1
return dis-1
```

## 3.分层图bfs

**每个点除了常规的横纵坐标,还有第三维属性,前两维属性相同,第三维不同的视为不同的点**

```python
#1293(https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/)
#分层图bfs+最优性剪枝
#除了常规的横纵坐标,加入第三维坐标代表到达当前点经过了多少障碍物
class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        move=[(1,0),(-1,0),(0,1),(0,-1)]
        n,m=len(grid),len(grid[0])
        #从(0,0)到(n-1,m-1)需要走m+n-2步(注意虽然距离是m+n-1,但是起点不算入步数)
        #由于开头结尾没有障碍物,因此最短路上最多有m+n-3个障碍物
        #如果k>=m+n-3,说明这条路上的障碍物都可以移除,直接返回m+n-2
        #因此可以添加下面的最优性剪枝
        if k>=m+n-3:
            return m+n-2
        start=(0,0,0)
        q=deque([start])
        vis={start}
        dis=0
        while q:
            size=len(q)
            for _ in range(size):
                x,y,z=q.popleft()
                if x==n-1 and y==m-1:
                    return dis
                for dx,dy in move:
                    nx,ny=x+dx,y+dy
                    if 0<=nx<n and 0<=ny<m:
                        nz=z+grid[nx][ny]
                        if nz<=k and (nx,ny,nz) not in vis:
                            vis.add((nx,ny,nz))
                            q.append((nx,ny,nz))
            dis+=1
        return -1
```

## 4.分层图bfs+状压

```python
# 3568(https://leetcode.cn/problems/minimum-moves-to-clean-the-classroom/)
# 状压bfs
class Solution:
    def minMoves(self, grid: List[str], k: int) -> int:
        move = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        n, m = len(grid), len(grid[0])
        idx = [[0] * m for _ in range(n)]
        garbage = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == "S":
                    start = (i, j, k, 0)
                elif x == "L":
                    idx[i][j] = 1 << garbage
                    garbage += 1
        if garbage == 0:
            return 0
        u = (1 << garbage) - 1
        # 队列中四元组,前两维度表示横纵坐标,第三维度表示当前剩余的能量值,第四维度表示收集到的垃圾的掩码
        x, y, z, g = start
        q = deque([start])
        # vis数组中去掉能量的维度,用值表示能量
        # 当其他三个维度状态相同时,只有能量大于vis中对应的能量值,才加入队列,同时更新vis中的值
        vis = [[[-1] * (1 << garbage) for _ in range(m)] for _ in range(n)]
        vis[x][y][g] = z
        dis = 0
        while q:
            size = len(q)
            for _ in range(size):
                x, y, z, g = q.popleft()
                if g == u:
                    return dis
                if z == 0:
                    continue
                for dx, dy in move:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != "X":
                        nz = k if grid[nx][ny] == "R" else z - 1
                        ng = g | idx[nx][ny] if grid[nx][ny] == "L" else g
                        if nz > vis[nx][ny][ng]:
                            vis[nx][ny][ng] = nz
                            q.append((nx, ny, nz, ng))
            dis += 1
        return -1
```

## 5.分段bfs

### 1.常规分段

**将原本求a到b的距离分成a到c,c到d,...,d到b的若干段,然后求和**

```python
#675(https://leetcode.cn/problems/cut-off-trees-for-golf-event/)
#砍树是陷阱,因为树并不影响行走,只有障碍物影响行走
#将所有树找出来排序得到数组a
#然后用bfs依次计算a1~a2,a2~a3,a3~a4,an-1~an的距离,然后求和即可
#如果其中任何一段因为障碍物阻碍,返回-1
class Solution:
    def cutOffTree(self, grid: List[List[int]]) -> int:
        move=[(1,0),(-1,0),(0,1),(0,-1)]
        n,m=len(grid),len(grid[0])
        def bfs(start,end):
            q=deque([start])
            vis={start}
            dis=0
            while q:
                size=len(q)
                for _ in range(size):
                    x,y=q.popleft()
                    if (x,y)==end:
                        return dis
                    for dx,dy in move:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m and (nx,ny) not in vis and grid[nx][ny]:
                            vis.add((nx,ny))
                            q.append((nx,ny))
                dis+=1
            return -1
        arr=sorted([(x,i,j) for i,row in enumerate(grid) for j,x in enumerate(row) if x>1])
        start=(0,0)
        ans=0
        for v,x,y in arr:
            end=(x,y)
            t=bfs(start,end)
            if t==-1:
                return -1
            ans+=t
            start=end
        return ans
```

### 2.迷宫分段

**将每次开始到停止看成一段**

```python
#只关注球的每段行动中开始和停止的地方(利用while循环实现)
#如果停止地方没来过,加入队列
class Solution:
    def hasPath(self, grid: List[List[int]], start: List[int], destination: List[int]) -> bool:
        move=[(1,0),(-1,0),(0,1),(0,-1)]
        n,m=len(grid),len(grid[0])
        start=tuple(start)
        destination=tuple(destination)
        q=deque([start])
        vis={start}

        while q:
            x,y=q.popleft()
            if (x,y)==destination:
                return True
            for dx,dy in move:
                nx,ny=x+dx,y+dy
                while 0<=nx<n and 0<=ny<m and grid[nx][ny]==0:
                    nx+=dx
                    ny+=dy
                #注意while循环得到的是球的越界位置,需要减一步才得到真正的位置
                px,py=nx-dx,ny-dy
                if (px,py) not in vis:
                    vis.add((px,py))
                    q.append((px,py))
        return False
```

## 6.01bfs



# 17.基本计算几何

## 1.三点共线

**也可以用叉乘**

```python
#斜率公式的变形
def g(i1,i2,i3):
    a,b,c=points[i1],points[i2],points[i3]
    return (a[1]-b[1])*(a[0]-c[0])==(a[0]-b[0])*(a[1]-c[1])
```

# 18.gcd和lcm

```python
#注意这种写法gcd,lcm可能返回负数
def gcd(a,b):
    while b:
        a,b=b,a%b
    return a
def lcm(a,b):
    t=gcd(a,b)
    return a*b//t
```

# 19.枚举回文数

```python
#866(https://leetcode.cn/problems/prime-palindrome/description/)
#枚举回文的一半
p = lambda n: n >= 2 and all(n % i for i in range(2, isqrt(n) + 1))
class Solution:
    def primePalindrome(self, n: int) -> int:
        #依次枚举长度为1,2,3,4,5,6...的回文串
        for length in range(1,6):
            #检查奇数长度
            #回文一半从1~10,10~100,100~1000,....枚举
            for root in range(10**(length-1),10**length):
                s=str(root)
                #12345+4321=123454321,从倒数第二个位置向前反向切片
                x=int(s+s[-2::-1])
                if x>=n and p(x):
                    return x
            
            for root in range(10**(length-1),10**length):
                s=str(root)
                x=int(s+s[::-1])
                if x>=n and p(x):
                    return x
```

# 20.链表

## 1.删除链表

```python
#3217(https://leetcode.cn/problems/delete-nodes-from-linked-list-present-in-array/)
#删除链表
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        s=set(nums)
        p=dummy=ListNode(next=head)
        while p.next:
            if p.next.val in s:
                p.next=p.next.next
            else:
                p=p.next
        return dummy.next
```

## 2.链表中的递归

```python
#2487(https://leetcode.cn/problems/remove-nodes-from-linked-list/)
#由于删除节点依赖于后面的最大值,因此可以用递归解决
class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def f(head):
            if head.next is None:
                return head
            node=f(head.next)
            if node.val>head.val:
                return node
            head.next=node
            return head
        return f(head)
```

## 3.链表插入

**先连后继,再连前驱**

```python
#147(https://leetcode.cn/problems/insertion-sort-list/description/)
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        #虚拟头节点
        dummy=ListNode(next=head)
        tail=head #最后一个元素一开始指向head
        #当前遍历到的元素cur
        cur=tail.next
        #当前元素非空
        while cur:
            #如果tail<=cur,不需要进行插入排序,直接后移tail即可
            if tail.val<=cur.val:
                tail=cur
            #否则需要进行插入排序
            else:
                p=dummy
                #从头开始找插入节点
                while p.next.val<cur.val:
                    p=p.next
                #插入元素需要连两根线,一根指前驱,一根指后继,先连后继可以减少很多操作
                tail.next=cur.next #tail下个元素更新成下下个元素
                cur.next=p.next
                p.next=cur
            cur=tail.next #更新当前元素为最后一个元素的下一个
        return dummy.next
```

## 4.头插法

```python
#2046(https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/)
#将负数值移到前面即可,由于负数绝对值越大实际值越小,因此可以采用头插法
class Solution:
    def sortLinkedList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy=ListNode(next=head)
        tail=dummy.next
        cur=tail.next #cur从第二个节点开始,因为第一个节点已经在dummy后面了,即使是负数也不需要插入了
        while cur:
            if cur.val>=0:
                tail=cur
            else:
                #如果cur的值<0,将其插入到dummy和dummy.next之间
                tail.next,cur.next,dummy.next=cur.next,dummy.next,cur
            cur=tail.next
        return dummy.next
```

## 5.反转链表

### 1.迭代

```python
#206(https://leetcode.cn/problems/reverse-linked-list/description/)
#迭代写法
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        #当前节点p
        p=head
        #p的原始前驱
        pre=None
        while p:
            #nx存储p的原始后继,p的next指向p的原始前驱
            nx,p.next=p.next,pre
            #p的前驱和p后移,即p的值赋给p的前驱,p的后继的值赋给p
            pre,p=p,nx
        #最后的pre即为头节点,此时p=None
        return pre
```

### 2.递归

```python
#递归写法
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def f(head):
            #边界
            if head is None or head.next is None:
                return head
            #反转head之后的链表a,得到a的头节点
            node=f(head.next)
            #a的尾节点即为head.next,head.next的next指向head
            head.next.next=head
            #注意要把head.next置空,如果不置空链表中会产生环
            head.next=None
            return node
        return f(head)
```

## 6.前后指针(两个指针每次走的距离一样)

```python
#1721(https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/)
#前后指针,快节点先走k-1步
class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        slow=fast=head
        for _ in range(k-1):
            fast=fast.next
        a=fast
        while fast.next:
            slow,fast=slow.next,fast.next
        a.val,slow.val=slow.val,a.val
        return head
```

## 7.链表中点(通过前后指针实现,两个指针每次走到距离不一样)

```python
#876(https://leetcode.cn/problems/middle-of-the-linked-list/)
#快慢指针,快指针每次走两步,慢指针每次走一步
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow=fast=head
        while fast and fast.next:
            slow,fast=slow.next,fast.next.next
        return slow
```

## 8.回文链表

```python
#234(https://leetcode.cn/problems/palindrome-linked-list/)
#反转链表+快慢指针找中点+检验回文
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        #反转链表
        def f(head):
            pre,p=None,head
            while p:
                #nx存储p的原始后继,p的next指向p的原始前驱
                nx,p.next=p.next,pre
                #p的前驱和p后移,即p的值赋给p的前驱,p的后继的值赋给p
                pre,p=p,nx
            #最后的pre即为头节点,此时p=None
            return pre

        #寻找右半部分开头(奇数长度为中点,偶数长度为第二个中点),pre记录slow前驱
        #slow的最终位置即为中点
        pre=slow=fast=head
        while fast and fast.next:
            pre,slow,fast=slow,slow.next,fast.next.next

        #将中点及中点右边的部分反转,然后p,q分别指向左右部分的头
        p,q=head,f(slow) 

        #检验回文
        def check(p,q):
            #注意必须是while q,不能是while p
            #因为对于偶数长度的链表,左半部分比右半部分长度多一个
            #如1->2->2<-1
            while q:
                if p.val!=q.val:
                    return False
                p,q=p.next,q.next
            return True
        ans=check(p,q)

        #恢复链表,即将反转后的右半部分再反转回去,然后接在前驱后面
        pre.next=f(q)
        return ans
```

## 9.环形链表

### 1.检测环

```python
#141(https://leetcode.cn/problems/linked-list-cycle/)
#快慢指针判环
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast=slow=head
        while fast and fast.next:
            fast=fast.next.next
            slow=slow.next
            if fast is slow:
                return True
        return False
```

### 2.求入环点

```python
#弗洛伊德判圈法
#快慢指针+数学推导
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        #设起点到入环点距离为a,入环点到相遇点距离为b,环长为c
        #设快指针走的距离为x,慢指针走的距离为y
        #则有x-y=c,因为快指针比慢指针多走了一个环的距离
        #同时有x=2*y,因为快指针速度是慢指针2倍,因此走的距离也是2倍
        #可以求出y=c,而y=a+b(慢指针的路径可以划分为起点到入环点及入环点到相遇点两段)
        #因此c=a+b,即a=c-b
        #c-b即环的距离减去从入环点到相遇点的距离(下半弧),结果就是从相遇点走到入环点的距离(上半弧)
        #即起点到入环点的距离=从相遇点走到入环点的距离
        #此时用两个指针从起点和相遇点同时出发,当两个指针相遇时即为入环点
        slow=fast=head
        while fast and fast.next:
            slow,fast=slow.next,fast.next.next
            #相遇
            if slow is fast:
                #从起点和相遇点同时出发,再次相遇即为入环点
                while head is not slow:
                    head,slow=head.next,slow.next
                return head
        return None
```

### 3.寻找环内数正负性相同且长度大于1的环

```python
#457(https://leetcode.cn/problems/circular-array-loop/description/)
#快慢指针O(1)空间判环
class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        n=len(nums)
        #下一步的位置
        def f(x):
            return (x+nums[x])%n
        for i,x in enumerate(nums):
            if x==0:continue
            slow,fast=i,f(i)
            #保证走的每一步正负性相同
            #对于链中正负性不同,但是环中正负性相同的情况,会等到遇到和环正负性相同的链或者入环点再处理
            while nums[slow]*nums[fast]>0 and nums[slow]*nums[f(fast)]>0:
                if slow==fast:
                    #环长为1,不合题意,break
                    if slow==f(slow):
                        break
                    #环长>1,返回True
                    return True
                slow=f(slow) #慢指针每次走一步
                fast=f(f(fast)) #快指针每次走两步
            x=i
            #将从x出发可以到达的点都置0,因为已经访问过了
            while nums[x]*nums[f(x)]>0:
                #注意是同时赋值
                #将nums[x]置0,代表访问过x了,同时x迭代成f(x)
                #注意f(x)运算时要用到nums[x],如果不是同步赋值,nums[x]=0要写在最后,同时要用tmp=x暂存x
                nums[x],x=0,f(x)
        return False
```

## 10.合并链表(三指针)

### 1.合并有序链表

```python
#21(https://leetcode.cn/problems/merge-two-sorted-lists/)
#归并排序
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        p=dummy=ListNode()
        p1,p2=list1,list2
        while p1 and p2:
            if p1.val<p2.val:
                p.next=p1
                p1=p1.next
            else:
                p.next=p2
                p2=p2.next
            p=p.next
        p.next=p1 or p2 #短路写法,此时表示的不再是布尔值
        return dummy.next
```

### 2.合并特定链表

```py
#86(https://leetcode.cn/problems/partition-list/)
#合并链表
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        p1=dummy_less=ListNode()
        p2=dummy_greater=ListNode()
        p=head
        while p:
            if p.val<x:
                p1.next=p
                p1=p1.next
            else:
                p2.next=p
                p2=p2.next
            p=p.next
        p1.next,p2.next=dummy_greater.next,None #注意将第二个链表结尾置空
        return dummy_less.next
```

## 11.相交链表

```python
#160(https://leetcode.cn/problems/intersection-of-two-linked-lists/)
#双指针
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        #不相交时将交点看成空节点,最终两个指针都会走到空节点
        p,q=headA,headB
        while p is not q:
            p=p.next if p else headB
            q=q.next if q else headA
        return p
```

## 12.链表相加

```python
#2(https://leetcode.cn/problems/add-two-numbers/)
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        p=dummy=ListNode()
        p1,p2,carry=l1,l2,0 #carry表示进位
        while p1 or p2 or carry:
            s=(p1.val if p1 else 0)+(p2.val if p2 else 0)+carry
            carry,v=divmod(s,10) #商表示新的进位,余数表示当前位的值
            p.next=ListNode(v)
            p1,p2,p=p1.next if p1 else p1,p2.next if p2 else p2,p.next
        return dummy.next
```

# 21.归并排序

## 1.递归实现

```python
#23(https://leetcode.cn/problems/merge-k-sorted-lists/)
#归并分治写法,类似线段树(递归版)
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        def merge(list1,list2):
            p=dummy=ListNode()
            p1,p2=list1,list2
            while p1 and p2:
                if p1.val<p2.val:
                    p.next=p1
                    p1=p1.next
                else:
                    p.next=p2
                    p2=p2.next
                p=p.next
            p.next=p1 or p2 #短路写法,此时表示的不再是布尔值
            return dummy.next
        def f(lists):
            n=len(lists)
            if n==0: #注意特判空列表的情况
                return None
            if n==1:
                return lists[0]
            l=f(lists[:n//2])
            r=f(lists[n//2:])
            return merge(l,r)
        return f(lists)
```

## 2.迭代实现

```python
#归并分治写法(迭代版)
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        def merge(list1,list2):
            p=dummy=ListNode()
            p1,p2=list1,list2
            while p1 and p2:
                if p1.val<p2.val:
                    p.next=p1
                    p1=p1.next
                else:
                    p.next=p2
                    p2=p2.next
                p=p.next
            p.next=p1 or p2 #短路写法,此时表示的不再是布尔值
            return dummy.next
        def f(lists):
            n=len(lists)
            if n==0: #注意特判空列表的情况
                return None
            step=1
            #迭代写法,一开始两两合并,0保存0,1,2保存2,3,4保存4,5...
            #第二轮四四合并,0和2合并,由于0保存0和1合并后的结果,2保存2和3合并后的结果
            #因此合并0,2其实是合并四个表,后面以此类推
            while step<n:
                for i in range(0,n-step,step*2):
                    lists[i]=merge(lists[i],lists[i+step])
                step*=2
            return lists[0]
        return f(lists)
```

# 22.贪心

## 1.从最小/最大开始贪心

**这种贪心往往要将原数组根据某一个指标排序,然后进行贪心**

**常用指标有数值/频数/绝对值等**

```python
#1481(https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/)
#从最小开始贪心
#统计每种元素出现的频数,然后将频数从小到大排序
class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        arr=sorted(Counter(arr).values())
        n=len(arr)
        #这种排序贪心的题目,可以根据下标计算出已经遍历过的元素数量
        for i,x in enumerate(arr):
            if k<x:
                return n-i
            k-=x
        return 0
```

# 23.背包dp

背包问题有多种变形题目,如恰好装满V/至多装V/至少装V,方案数,具体方案,根据结果推条件(构造)

## 1.01背包

## 2.完全背包

### 1.最值模型

**这里是恰好装满的类型**

**0号位置初始化成0,其他位置根据是求最大/最小初始化成0/inf**

**注意完全背包空间压缩时要正序遍历,因为依赖当前行前面元素的状态**

```python
#322(https://leetcode.cn/problems/coin-change/)
class Solution:
    def coinChange(self, nums: List[int], v: int) -> int:
        f=[0]+[inf]*v
        for x in nums:
            for j in range(x,v+1):
                f[j]=min(f[j],f[j-x]+1)
        return f[-1] if f[-1]<inf else -1
```

### 2.方案模型

**这里是恰好装满的类型**

**0号位置初始化成1,其他位置初始化成0**

**转移方程从min/max改成+=**

```python
class Solution:
    def change(self, v: int, nums: List[int]) -> int:
        f=[1]+[0]*v
        for x in nums:
            for j in range(x,v+1):
                f[j]+=f[j-x]
        return f[-1]
```

### 3.方案反推体积数组(构造)

```python
#完全背包求方案数+构造
#本质是每找到一个新的合法面值硬币,就更新一次方案数数组,然后将题目中给出的方案数组与构造出的数组比对
#同时可以发现,原数组的最小非0值必须是1,因为最小的面值和必定就是由一种硬币构成的
#利用这个性质,每一轮更新的硬币对应的方案数要么比原数组少1,要么相等
class Solution:
    def findCoins(self, numWays: List[int]) -> List[int]:
        n=len(numWays)
        f=[1]+[0]*n #f[i]表示和为i的方案数,初始化方式和完全背包求方案数相同
        ans=[]
        #本质仍是背包问题选或不选,遍历每个面值
        #如果选当前面值(即假设含有当前面值),那么当前面值方案数就应该等于不选当前面值的方案数+1,+1就对应只拿当前面值的硬币的情况
        #如果不选当前面值,那么当前面值方案数就应该等于不选当前面值的方案数,这就是背包问题的两种情况,如果出现其他情况,就一定是无解的
        for i,x in enumerate(numWays,1):
            #如果x和f[i]相等,说明之前的硬币就能构造出和为i的所有方案,尝试下一个
            if x==f[i]:continue
            #如果不等,且不等于f[i]+1,说明添加当前硬币也无法满足条件,又因为从小到大尝试所有面值,因此无解,返回空数组
            if x!=f[i]+1:
                return []
            #有解,将当前面值加入答案,同时从当前面值往后,按照完全背包求方案数的写法,更新后面面值的方案数
            ans.append(i)
            for j in range(i,n+1):
                f[j]+=f[j-i]
        return ans

```

# 24.质因数分解

```python
#质因数分解
def f(n):
    i,x=2,n
    p=[]
    while i<=isqrt(x):
        if x%i==0:
            p.append(i)
            while x%i==0:
                x//=i
        i+=1
    if x>1:
        p.append(x)
    return p
```

# 25.最小质因子(LPF)

```python
#最小质因子LPF
N=1_000_000
p=[0]*(N+1)
for i in range(2,N+1):
    if p[i]==0:
        for j in range(i,N+1,i):
            if p[j]==0:
                p[j]=i
```

# 26.裴蜀定理

对任何整数a,b和m,关于未知数x和y的线性丢番图方程$ax+by=m$有整数解当且仅当m是a及b的最大公约数d的倍数.

```python
#1250(https://leetcode.cn/problems/check-if-it-is-a-good-array/)
```

