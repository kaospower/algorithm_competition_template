[TOC]

# 1.组合数学篇

## 1.卡特兰数

**求卡特兰数的四个公式**

1.$f(n)=C_{2n}^{n}-C_{2n}^{n-1}$

2.$f(n)=\frac{C_{2n}^n}{n+1}$

3.$f(n)=f(n-1)\cdot (4n-2)/(n+1)$

4.$f(n)=\displaystyle\sum_{i=0}^{n-1}f(i)\cdot f(n-1-i)$

```c++
#include <iostream>
#include <algorithm>

typedef long long LL;
using namespace std;

const int mod=1e9+7;

int qmi(int a,int k,int p)
{
    int res=1;
    while (k)
    {
        if (k&1) res=(LL)res*a%p;
        a=(LL)a*a%p;
        k>>=1;
    }
    return res;
}
int main()
{
    int n;
    cin>>n;
    
    int a=2*n,b=n;
    int res=1;
    
    for (int i=a;i>a-b;i--)res=(LL)res*i%mod;
    for (int i=1;i<=b;i++)res=(LL)res*qmi(i,mod-2,mod)%mod;
    res=(LL)res*qmi(n+1,mod-2,mod)%mod;
    cout<<res<<endl;
    return 0;
}
```

## 2.斯特林数

### 1.第一类斯特林数

将1~n划分成k个圆排列的方案数,记作s(n,k)

$s(n,k)=s(n-1,k-1)+(n-1)\cdot s(n-1,k)$

特别地,$s(0,0)=1$

```python
#模版题1866(https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/)
mod=1000000007
N=1001
s=[[0]*N for _ in range(N)]
s[0][0]=1
for i in range(1,N):
    for j in range(1,i+1):
        s[i][j]=(s[i-1][j-1]+(i-1)*s[i-1][j]%mod)%mod
class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        return s[n][k]
```

### 2.第二类斯特林数

将1~n划分成k个非空子集的方案数,记作S(n,k)

$S(n,k)=S(n-1,k-1)+k*S(n-1,k)$

特别地,$S(0,0)=1$

```python
#模版题3317(https://leetcode.cn/problems/find-the-number-of-possible-ways-for-an-event/)
mod=1000000007
N=1001
#预处理第二类斯特林数
S=[[0]*N for _ in range(N)]
S[0][0]=1
for i in range(1,N):
    for j in range(1,i+1):
        S[i][j]=(S[i-1][j-1]+j*S[i-1][j]%mod)%mod
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans=0
        fact=p=1
        for j in range(1,min(n,x)+1):
            #A(x,j)*S[n][j]*y^j
            fact=fact*(x+1-j)%mod
            p=p*y%mod
            ans=(ans+fact*S[n][j]%mod*p%mod)%mod
        return ans
```

## 3.康托展开和逆康托展开

求某个排列在所有排列中的排名

$rank=\displaystyle\sum rightSmall(S[i])\times (n-i)!$

对于位置i,求出它右侧比它小的数的个数乘上右边数的个数的阶乘,所有位置求和即为其排名

注意排名从0开始

rightSmall(s[i])可以用树状数组维护,一开始1~n范围所有数都是1,每经过一个数字,将该数字置0

righSmall(s[i])即为1~s[i]-1范围内的个数

# 2.数据结构篇

## 1.珂朵莉树

```python
#模版题:699(https://leetcode.cn/problems/falling-squares/)
class ODT:
    def __init__(self):
        self.tree = SortedList()
        self.maxh=0 #记录每个新正方形加入后最大高度

    #截断函数
    def split(self,pos):
        idx = self.tree.bisect_left([pos,])
        if idx != len(self.tree) and self.tree[idx][0] == pos:
            return idx 
        idx -= 1
        l,r,v = self.tree[idx]
        self.tree[idx][1] = pos-1
        self.tree.add([pos,r,v])
        return idx+1
       
    #赋值函数
    def assign(self,l,r,v):
        begin = self.split(l)
        end = self.split(r+1)

        h=max(v for l,r,v in self.tree[begin:end])
        self.maxh=max(self.maxh,h+v) #过往最大高度+新增加的高度
        del self.tree[begin:end]
        self.tree.add([l,r,h+v])

class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        odt=ODT() #初始化珂朵莉树 
        odt.tree.add([1,inf,0]) #将哨兵加入树中
        ans = []
        for l,d in positions:
            odt.assign(l,l+d-1,d) #每个正方形的左右边界及高度
            ans.append(odt.maxh)
        return ans
```

## 2.平衡树

## 3.可持久化线段树

## 4.FHQ树

## 5.莫队

### 1.普通莫队

莫队算法,本质是通过巧妙地改变回答询问的顺序,让相邻询问的重叠部分尽量大,从而使访问的元素个数(区间左右端点的总移动次数)由$O(nq)降至O(n\sqrt q)$,其中q是queries的长度

把数组分成若干块,每块大小为B,分成$k=\frac{n}{B}$块,最后一块的大小$\leq B$

莫队算法的核心思想是:把询问按照左端点所在块分组,左端点在同一个块的询问分到同一组

对于每个块,把右端点排序,使得右端点在数组中一直向右移动,而左端点只在块内抖动,如此一来,两个相邻询问区间的交集就能尽量大,就能减少增删元素的次数

对于左端点,相邻查询之间最大抖动距离为B,总计复杂度为qB,对于右端点,每个块中的查询最多向右移动n,总计$\frac{n}{B}n=\frac{n^2}{B}$,因此总复杂度为$qB+\frac{n^2}{B}\geq 2n\sqrt{q}$

### 2.带修莫队

### 3.树上莫队

### 4.回滚莫队

### 5.二维莫队

### 6.莫队二次离线

### 7.莫队配合bitset

# 3.图论算法篇

## 1.连通分量

### 1.tarjan算法求有向图强连通分量

时间戳:按照dfs遍历的顺序给每个点一个编号

对每个点定义两个时间戳:

dfn[u]表示遍历到u的时间戳

low[u]表示从u开始走,所能遍历到的最小时间戳

u是其所在强连通分量的最高点,等价于dfn[u]==low[u]

时间复杂度O(n+m)

缩点:遍历所有点和其所有邻点j,如果i,j不在同一个scc中,加一条新边id(i)->id(j),可以将有向图转化成有向无环图,利用DAG的拓扑序,可以解决很多问题

连通分量编号递减的顺序一定是拓扑序

```c++
//受欢迎的奶牛
//利用tarjan+缩点将原图转化成DAG,然后查看出度为0的点是否为1个
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int N=10010,M=50010;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int stk[N],top;//栈
bool in_stk[N];//表示每个点是否在栈中
//id表示每个点属于哪个强连通分量编号,scc_cnt为强连通分量数量
//size表示每个强连通分量中点的数量
int id[N],scc_cnt,size[N];
int dout[N];//每个强连通分量的出度

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u,in_stk[u]=true;
    for (int i=h[u];~i;i=ne[i])
    {
        int j=ne[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if (in_stk[j]) low[u]=min(low[u],dfn[j]);
    }
    if (dfn[u]==low[u])
    {
        ++scc_cnt;
        int y;
        do
        {
            y=stk[top--];
            in_stk[y]=false;
            id[y]=scc_cnt;
            size[scc_cnt]++;
        }while (y!=u);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    memset(h,-1,sizeof h);
    while (m--)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
    }
    for (int i=1;i<=n;i++)
        if (!dfn[i])
            tarjan(i);
    for (int i=1;i<=n;i++)
        for (int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if (a!=b) dout[a]++;
        }
    int zeros=0,sum=0;//sum表示所有出度为0的强连通分量的点的数量之和
    for (int i=1;i<=scc_cnt;i++)
        if (!dout[i])
        {
            zeros++;
            sum+=size[i];
            if (zeros>1)
            {
                sum=0;
                break;
            } 
        }
    printf("%d\n",sum);
    return 0;
}
```

### 2.tarjan算法求无向图双连通分量

```c++
//边双连通分量算法
//冗余路径
//给定一个无向连通图,问最少加几条边,可以将其变成一个边双连通分量
//将原图缩点成树,ans=(cnt+1)/2下取整,cnt为缩完点之后度数为1的点的个数
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=5010,M=20010;

int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],timestamp;
int stk[N],top;//栈
int id[N],dcc_cnt;//记录每个点属于哪个双连通分量
bool is_bridge[M];//记录每条边是不是桥
int d[N];//度数

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void tarjan(int u,int from)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    for (int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if (!dfn[j])
        {
            tarjan(j,i);
            low[u]=min(low[u],low[j]);
            if (dfn[u]<low[j])
                is_bridge[i]=is_bridge[i^1]=true;    
        }
        else if (i!=(from^1))
            low[u]=min(low[u],dfn[j]);
    }
    if (dfn[u]==low[u])
    {
        ++dcc_cnt;
        int y;
        do{
            y=stk[top--];
            id[y]=dcc_cnt;
        }while (y!=u);
    }
}
int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);
    while (m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b),add(b,a);
    }
    tarjan(1,-1);//记录父节点
    for (int i=0;i<idx;i++)
        if (is_bridge[i])
            d[id[e[i]]]++;
    int cnt=0;
    for (int i=1;i<=dcc_cnt;i++)
        if (d[i]==1)
            cnt++;
    printf("%d\n",(cnt+1)/2);
    return 0;
}
```



```c++
//矿场搭建
//点双连通分量算法
//给定一个无向图,问最少在几个点上设置出口,可以使得不管其他哪个点坍塌,其余所有点都可以与某个出口连通
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef unsigned long long ULL;
const int N=1010,M=510;

int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N],low[N],idx;
int stk[N],top;
int dcc_cnt;
vector<int> dcc[N]; //双连通分量里面有哪些点
bool cut[N];//双连通分量是不是割点
int root;

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++top]=u;
    if (u==root && h[u]==-1)
    {
        dcc_cnt++;
        dcc[dcc_cnt].push_back(u);
        return;
    }
    int cnt=0;
    for (int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u]=min(low[u],low[j]);
            if (dfn[u]<=low[j])
            {
                cnt++;
                if (u!=root || cnt>1) cut[u]=true;
               	++dcc_cnt;
                int y;
                do{
                    y=stk[top--];
                    dcc[dcc_cnt].push_back(y);
                }while (y!=j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u]=min(low[u],low[j]);
    }
}
int main()
{
    int T=1;
    while (cin>>m,m)
    {
        for (int i=1;i<=dcc_cnt;i++) dcc[i].clear();
        idx=n=timestamp=top=dcc_cnt=0;
        memset(h,-1,sizeof h);
        memset(dfn,0,sizeof dfn);
        memset(cut,0,sizeof cut);
        while (m--)
        {
            int a,b;
            cin>>a>>b;
            n=max(n,a),n=max(n,b);
            add(a,b),add(b,a);
        }
        for (root=1;root<=n;root++)
            if (!dfn[root])
                tarjan(root);
        int res=0;
        ULL num=1;
        for (int i=1;i<=dcc_cnt;i++)
        {
            int cnt=0;
            for (int j=0;j<dcc[i].size();j++)
                if (cut[dcc[i][j]])
                    cnt++;
            if (cnt==0) res+=2,num*=dcc[i].size()*(dcc[i].size()-1)/2;
            else if (cnt==1) res++,num*=dcc[i].size()-1;
        }
        printf("Case %d: %d %llu\n",T++,res,num);   
    }
    return 0;
}
```

# 4.网络流篇

## 1.最大流

**EK算法**,$O(nm^2)$
存图:邻接表
加边时正向边和反向边成对存储,即第i条边的反向边=i^1,找反向边非常容易

最大流建图正确性:
流网络中的任何一个可行流f都是原问题的一组可行解
原问题的任何一组可行解都是流网络的一个可行流
证明了这两点,原问题的最大值就是流网络的最大流

```c++
//EK算法模版
#include <iostream>
#include <cstring>
#inlcude <algorithm>

using namespace std;

const N=1010,M=20010,INF=1e8;
    
int n,m,S,T;
int h[N],e[M],f[M],ne[M],idx;//f表示容量
int q[N],d[N],pre[N];//q:队列,d:从起点走到某个点,容量的最小值,pre:前驱点
bool st[N];//bfs判重数组

void add(int a,int b,int c)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++; //正向边容量是c
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++; //反向边容量是0
}

//宽搜找增广路
bool bfs()
{
    int hh=0,tt=0;
    memset(st,false,sizeof st);
    q[0]=S,st[S]=true,d[S]=INF; //起点加入队列,一开始没有任何限制,所以d[S]=INF
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (!st[ver] && f[i]) //f[i]要大于0,根据增广路定义,增广路上所有边容量都要大于0
            {
                st[ver]=true;
                d[ver]=min(d[t],f[i]);
                
                pre[ver]=i;//前驱边
                if (ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}
int EK()
{
    int r=0;
    //迭代更新残留网络
    while (bfs())
    {
        r+=d[T];
        for (int i=T;i!=S;i=e[pre[i]^1])
            f[pre[i]]-=d[T],f[pre[i]^1]+=d[T];
    }
    return r;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    memset(h,-1,sizeof h);
    while (m--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    printf("%d\n",EK());
    return 0;
}
```

**Dinic算法**,$O(n^2m)$在求解最大流最小割问题时更常用,EK算法在求解这些问题时基本不会用

为了处理环的问题,dinic算法引入了分层图的概念,在寻找路径时,每次只能从前一层走到后一层,从而保证没有环路

1.bfs建立分层图

2.dfs找出所有能够增广路径,无回溯

**当前弧优化**:如果某条边已经满了,下次搜索的时候就跳过这条边,从它的下一条边开始搜

代码中维护的图是残留网络$G_f$

```c++
//dinic算法模版
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=10010,M=200010,INF=1e8;

int n,m,S,T;//S:源点,T:汇点
int h[N],e[M],f[M],ne[M],idx;//f表示残留网络容量
int q[N],d[N],cur[N];//q:队列,d:分层图层数,cur:当前弧优化

void add(int a,int b,int c)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;//正向边
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;//反向边
}

bool bfs()
{
    int hh=0,tt=0;
    memset(d,-1,sizeof d);
    q[0]=S,d[S]=0,cur[S]=h[S];//起点入队,cur表示当前弧优化
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (d[ver]==-1 && f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if (ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
    
}

//深搜
int find(int u,int limit)//从u开始搜,从起点流向u的最大流量是limit
{
    if (u==T) return limit;
    int flow=0;//flow表示从这个点往后流的流量最多是多少
    //从当前没有满的路径开始搜,flow<limit是重要优化,如果不加这个条件会TLE
    for (int i=cur[u];~i && flow<limit;i=ne[i])
    {
        cur[u]=i; //当前弧优化
        int ver=e[i];
        //搜索下一层
        if (d[ver]==d[u]+1 && f[i])
        {
            int t=find(ver,min(f[i],limit-flow));
            if (!t) d[ver]=-1;//删点
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}
int dinic()
{
    int r=0,flow;
    //bfs会返回是否存在增广路,如果有增广路会同时建出分层图
    //find()是dfs函数
    while (bfs()) while (flow=find(S,INF)) r+=flow;
    return r;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    memeset(h,-1,sizeof h);
    while (m--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c); //每条边的起点,终点,容量
        add(a,b,c);
    }
    printf("%d\n",dinic());
    return 0;
}
```

## 2.最小割

```c++
//dinic求最小割
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N=10010,M=200010,INF=1e8;

int n,m,S,T;
int h[N],e[M],f[M],ne[M],idx;
int q[N],d[N],cur[N];

void add(int a,int b,int c)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;
}
bool bfs()
{
    int hh=0,tt=0;
    memset(d,-1,sizeof d);
    q[0]=S,d[S]=0,cur[S]=h[S];
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (d[ver]==-1 && f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if (ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}

int find(int u,int limit)
{
    if (u==T) return limit;
    int flow=0;
    for (int i=cur[u];~i && flow<limit;i=ne[i])
    {
        cur[u]=i;
        int ver=e[i];
        if (d[ver]==d[u]+1 && f[i])
        {
            int t=find(ver,min(f[i],limit-flow));
            if (!t) d[ver]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int r=0,flow;
    while (bfs()) while (flow=find(S,INF)) r+=flow;
    return r;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    memset(h,-1,sizeof h);
    while (m--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    printf("%d\n",dinic());
    return 0;
}
```

## 3.费用流

**费用流**:所有最大可行流中费用的最小/最大值,简称为最小/最大费用最大流

可行流的总费用=流量$\times$费用

求最小费用最大流,将EK算法中的bfs换成spfa

该算法不能处理有负权回路的网络,因为spfa不能处理负环,如果想处理负环,需要用到消圈法模版

w(v,u)=-w(u,v)即正向边的费用和反向边的费用相反



EK算法:

1.在残留网络中找一条增广路

2.更新残留网络$G_f$

求费用流时将bfs替换成spfa,相当于每次迭代不是再求任意一条增广路,而是求从源点到汇点的最短/最长增广路



**费用流解决二分图带权最大匹配模版**

```mysql
模版题:1879.两个数组最小的异或值之和
(https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/description/)
```



```python
#EK+spfa求最小费用最大流
min=lambda x,y:x if x<y else y
class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        N=14*2+10;M=(14*14+2*14)*2+10
        n=len(nums1);S=0;T=n*2+1
        h=[-1]*N;e=[0]*M;f=[0]*M;w=[0]*M;ne=[0]*M;idx=0
        q=deque();d=[0]*N;pre=[0]*N;incf=[0]*N
        st=[False]*N
        def add(a,b,c,d):
            nonlocal idx
            e[idx]=b;f[idx]=c;w[idx]=d;ne[idx]=h[a];h[a]=idx;idx+=1
            e[idx]=a;f[idx]=0;w[idx]=-d;ne[idx]=h[b];h[b]=idx;idx+=1
        def spfa():
            d[:]=[inf]*N;incf[:]=[0]*N
            q.append(S);d[S]=0;incf[S]=inf
            while q:
                t=q.popleft()
                st[t]=False

                i=h[t]
                while ~i:
                    ver=e[i]
                    if f[i] and d[ver]>d[t]+w[i]:
                        d[ver]=d[t]+w[i]
                        pre[ver]=i
                        incf[ver]=min(f[i],incf[t])
                        if not st[ver]:
                            q.append(ver)
                            st[ver]=True
                            
                    i=ne[i]
            return incf[T]>0

        def EK():
            cost=0
            while (spfa()):
                t=incf[T];cost+=t*d[T]

                i=T
                while i!=S:
                    f[pre[i]]-=t
                    f[pre[i]^1]+=t

                    i=e[pre[i]^1]
            return cost
        for i in range(1,n+1):
            add(S,i,1,0)
            add(n+i,T,1,0)
        for i in range(1,n+1):
            for j in range(1,n+1):
                add(i,n+j,1,nums1[i-1]^nums2[j-1])
        return EK()

```



```c++
//最小费用最大流模版
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=5010,M=100010,INF=1e8;

int n,m,S,T;
int h[N],e[M],f[M],w[M],ne[M],idx;//w表示每条边的费用
int q[N],d[N],pre[N],incf[N];//pre:从后往前把spfa最短路推出的数组,incf:走到每个点的时候最大流量
bool st[N];//spfa判重数组

void add(int a,int b,int c,int d){
    e[idx]=b,f[idx]=c,w[idx]=d,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,w[idx]=-d,ne[idx]=h[b],h[b]=idx++;
}


bool spfa()
{
    int hh=0,tt=1;
    memset(d,0x3f,sizeof d);//初始化距离
    memset(incf,0,sizeof incf);
    q[0]=S,d[S]=0,incf[S]=INF;
    while (hh!=tt)//循环队列
    {
        int t=q[hh++];
        if (hh==N) hh=0;
        st[t]=false;
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (f[i] && d[ver]>d[t]+w[i])
            {
                d[ver]=d[t]+w[i];
                pre[ver]=i;
                incf[ver]=min(f[i],incf[t]);
                if (!st[ver])
                {
                    q[tt++]=ver;
                    if (tt==N) tt=0;
                    st[ver]=true;
                }
            }
        }
    }
    return incf[T]>0;
}
void EK(int& flow,int& cost){//以引用参数形式返回
    flow=cost=0;
    while (spfa()){
        int t=incf[T];//走到终点时最大流量是多少
        flow+=t,cost+=t*d[T];
        for (int i=T;i!=S;i=e[pre[i]^1])//反向边的终点就是前一个点
        {
            f[pre[i]]-=t;
            f[pre[i]^1]+=t;
        }
    }
}
int main(){
    scanf("%d%d%d%d",&n,&m,&S,&T);
    memset(h,-1,sizeof h);
    while (m--){
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        add(a,b,c,d);
        
    }
    int flow,cost;
    EK(flow,cost);
    printf("%d %d\n",flow,cost);
    
    return 0;
}
```



```c++
//同时求最小费用最大流和最大费用最大流
//运输问题
//多源汇网络流问题,建立虚拟源点,虚拟汇点

#inlcude <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=160,M=5150*2+10,INF=1e8;

int n,m,S,T;
int h[N],e[M],f[M],w[M],ne[M],idx;
int q[N],d[N],pre[N],incf[N];//注意f是容量,incf是流量
bool st[N];

void add(int a,int b,int c,int d)
{
    e[idx]=b,f[idx]=c,w[idx]=d,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,w[idx]=-d,ne[idx]=h[b],h[b]=idx++;
}

bool spfa()
{
    int hh=0,tt=1;
    memset(d,0x3f,sizeof d);
    memset(incf,0,sizeof incf);
    q[0]=S,d[S]=0,incf[S]=INF;
    while (hh!=tt)
    {
        int t=q[hh++];
        if (hh==N) hh=0;
        st[t]=false;
        
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (f[i] && d[ver]>d[t]+w[i])
            {
                d[ver]=d[t]+w[i];
                pre[ver]=i;
                incf[ver]=min(incf[t],f[i]);
                if (!st[ver])
                {
                    q[tt++]=ver;
                    if (tt==N) tt=0;
                    st[ver]=true;
                }
            }
        }
    }
    return incf[T]>0;
}
int EK()
{
    int cost=0;
    while (spfa())
    {
        int t=infc[T];
        cost+=t*d[T];
        for (int i=T;i!=S;i=e[pre[i]^1])
        {
            f[pre[i]]-=t;
            f[pre[i]^1]+=t;
        }
    }
    return cost;
}
int main(){
    scanf("%d%d",&m,&n);
    S=0,T=m+n+1;
    memset(h,-1,sizeof h);
    for (int i=1;i<=m;i++)
    {
        int a;
        scanf("%d",&a);
        add(S,i,a,0);
    }
    for (int i=1;i<=n;i++)
    {
        int b;
        scanf("%d",&b);
        add(m+i,T,b,0);
    }
    for (int i=1;i<=m;i++)
        for (int j=1;j<=n;j++)
        {
            int c;
            scanf("%d",&c);
            add(i,m+j,INF,c);
        }
    printf("%d\n",EK());
    for (int i=0;i<idx;i+=2) //最大费用取反费用即可
    {
        f[i]+=f[i^1],f[i^1]=0;
        w[i]=-w[i],w[i^1]=-w[i^1];
    }
    printf("%d\n",-EK());
    
    return 0;         
}
```

## 4.二分图

### 1.KM算法

```python
模版题:3376.破解锁的最少时间I
(https://leetcode.cn/problems/minimum-time-to-break-locks-i/)
```



```python
#KM算法(bfs)
def KM(w):
    """
    vb:记录右侧顶点是否已在交错树中
    slack:记录每个右侧顶点与当前交错树的差距
    last:记录交错树中右侧顶点的前驱，用于回溯增广路径
    y:从哑结点开始构造交错树
    mt[0]=i:假设左侧顶点 i 与哑结点 0 匹配
    x:当前 y 对应的左侧顶点
    """
    n=len(w)
    mt,la,lb=[0]*n,[0]+[max(w[i][j] for j in range(1, n)) for i in range(1, n)],[0] * n
    # 对于每个真实左侧顶点寻找匹配
    for i in range(1,n):
        vb,slack,last,y,mt[0]=[False]*n,[inf]*n,[0]*n,0,i
        while True:
            vb[y],x,delta,nexty=True,mt[y],inf,0
            # 更新所有未加入交错树右侧顶点的 slack 值
            for j in range(1,n):
                if not vb[j]:
                    if (d:=la[x]+lb[j]-w[x][j])<slack[j]:slack[j],last[j]=d,y
                    if slack[j]<delta:delta,nexty=slack[j],j
            # 如果 delta > 0，则调整所有标号
            if delta>0:
                for j in range(n):
                    if vb[j]:
                        la[mt[j]]-=delta
                        lb[j]+=delta
                    else:slack[j]-=delta
            y=nexty
            # 找到未匹配的右侧顶点时退出循环
            if mt[y]==0:break
        # 倒推更新增广路
        while y>0:mt[y],y=mt[last[y]],last[y]
    return -sum(w[mt[i]][i] for i in range(1,n))
class Solution:
    def findMinimumTime(self, power: List[int], k: int) -> int:
        n=len(power)
        w=[[0]*(n+1) for _ in range(n+1)]
        for i in range(n):
            for j,x in enumerate(power):
                w[i+1][j+1]=-((x+i*k)//(i*k+1))
        return KM(w)
```

### 2.最大流解决二分图匹配

匈牙利算法解决二分图匹配时间复杂度是$O(nm)$

dinic算法解决二分图匹配时间复杂度是$O(m\sqrt{n})$,dinic算法更快

```python
建出虚拟源点S和汇点T

从源点向第一个点集的每一个点连一条容量是1的边

从第二个点集向汇点连一条容量是1的边

对于两个点集之间的边,容量是1
```

```python
//飞行员配对方案问题
//最大流解决二分图匹配问题模版
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=110,M=5210,INF=1e8;

int m,n,S,T;
int h[n],e[M],f[M],ne[M],idx;
int q[N],d[N],cur[N];

void add(int a,int b,int c)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;
}

bool bfs()
{
    int hh=0,tt=0;
    memset(d,-1,sizeof d);
    q[0]=S,d[S]=0,cur[S]=h[S];
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (d[ver]==-1 && f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if (ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}
int find(int u,int limit)
{
    if (u==T) return limit;
    int flow=0;
    for (int i=h[u];~i && flow<limit;i=ne[i])
    {
        cur[i]=i;
        int ver=e[i];
        if (d[ver]==d[u]+1 && f[i]){
            int t=find(ver,min(f[i],limit-flow));
            if (!t) d[ver]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}
int dinic()
{
    int r=0,flow;
    while (bfs()) while (flow==find(S,INF)) r+=flow;
    return r;
}
int main()
{
    scanf("%d%d",&m,&n);
    S=0,T=n+1;
    memset(h,-1,sizeof h);
    for (int i=1;i<=m;i++) add(S,i,1);
    for (int i=m+1;i<=n;i++) add(i,T,1);
    
    int a,b;
    while (cin>>a>>b,a!=-1) add(a,b,1);
    printf("%d\n",dinic());
    for (int i=0;i<idx;i+=2) //枚举所有正向边
        if (e[i]>m && e[i]<=n && !f[i])
            printf("%d %d\n",e[i^1],e[i]);
    return 0;
}
```

### 3.最大流解决二分图多重匹配

```python
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=430,M=(150*270+N)*2,INF=1e8;

int m,n,S,T;
int h[N],e[M],f[M],ne[M],idx;
int q[N],d[N],cur[N];

void add(int a,int b,int c)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;
}
bool bfs()
{
    int hh=0,tt=0;
    memset(d,-1,sizeof d);
    q[0]=S,d[S]=0,cur[S]=h[S];
    while (hh<=tt)
    {
        int t=q[hh++];
        for (int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if (d[ver]==-1 && f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if (ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}
int find(int u,int limit)
{
    if(u==T) return limit;
    int flow=0;
    for (int i=cur[u];~i && flow<limit;i=ne[i])
    {
        cur[u]=i;
        int ver=e[i];
        if (d[ver]==d[u]+1 && f[i])
        {
            int t=find(ver,min(f[i],limit-flow));
            if (!t) d[ver]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}
int dinic()
{
    int r=0,flow;
    while (bfs()) while (flow=find(S,INF)) r+=flow;
    return r;
}
int main()
{
    scanf("%d%d",&m,&n);
    S=0,T=m+n+1;
    memeset(h,-1,sizeof h);
    int tot=0;
    for (int i=1;i<=m;i++)
    {
        int c;
        scanf("%d",&c);//c是人数
        add(S,i,c);
        tot+=c;
    }
    for (int i=1;i<=n;i++)
    {
        int c;
        scanf("%d",&c);
        add(m+i,T,c);
    }
    for (int i=1;i<=m;i++)
        for (int j=1;j<=n;j++)
            add(i,m+j,1);
    if (dinic()!=tot) puts("0");
    else {
        puts("1");
        for (int i=1;i<=m;i++)
        {
            for (int j=h[i];~j;j=ne[j])
                if (e[j]>m && e[j]<=m+n && !f[j])
                    printf("%d",e[j]-m);
            puts("");
        }
    }
    return 0;
}
```
