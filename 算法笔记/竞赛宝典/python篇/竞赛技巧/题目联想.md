算法题目五步走

1.看数据范围

2.看题目大类,某些大类,如网格图/树/图/字符串/位运算可以直接看出,其他大类需要结合题目关键字才能看出

3.看关键字,滑窗/二分/单调栈/dp/数据结构/贪心/数学/大模拟/爆搜等需要结合题目关键字才能看出来

4.如果无法看出题目分类或者单纯用大类对应的方法无法解决,就需要尝试相应的技巧

5.如果以上方法均无法解决,可尝试脑筋急转弯/数学公式推导/构造/猜想/打表

# 1.数据范围篇(天字第一号技巧)

## 1.n<=10

10!=3,628,800

11!=39,916,800

O(n!)或O(C^m)

回溯,爆搜

## 2.n<=25

2^25=33,554,432

2^26=67,108,864

O(2^n)

状压dp

## 3.n<=10^2

O(n^3)

三重循环dp,floyd

## 4.n<=10^3

O(n^2)

二重dp,背包dp

## 5.n<=10^5

O(nlogn)

滑窗,dp,二分,树上算法

## 6.n<=10^6

O(n)

滑窗,dp

## 7.n<=10^9

O(sqrt(n))

判断质数

## 8.n<=10^18

O(logn)或O(1)

数位dp,二分,快速幂,数学公式

# 2.题目大类篇

## 1.网格图

网格图dfs/网格图bfs/网格图01bfs/网格图dijkstra/网格图dp/网格图并查集/网格图双集合多源bfs

注意以上算法实现时可能结合状压,二分

注意在网格图中,如果四个方向都可以走,不满足无后效性,此时不能用dp

只有满足无后效性时,才能用dp,比如只能向左下,下,右下走时,或者只能向右,下走时

## 2.树

dfs/bfs/直径/树形dp/dfs时间戳/树上拓扑排序(剥洋葱)/lca/树上倍增/树上滑窗/树上启发式合并/点分治

dfs序/欧拉序

## 3.图

dfs/bfs/拓扑排序/剥洋葱/拓扑序dp/最短路算法(注意bfs也可以求最短路)/最小生成树

欧拉回路/连通分量算法/二分图/网络流

## 4.字符串

kmp,循环节/z函数/Manacher/字符串哈希/最小表示法/字典树/AC自动机/后缀数组/后缀自动机/子序列自动机/LCP(最长公共前缀)性质/状压

## 5.位运算

拆位,对于1个1e9大小的数,它的二进制位有log(1e9+1)向上取整=30位,枚举0~29位,即为拆位

枚举位和枚举数相比,时间复杂度大大降低,往往会从n^2降低到nlogU级别

## 6.滑动窗口

## 7.二分

## 8.单调栈

## 9.dp

**dp往往求最优解,贪心则是dp的子集,即在逻辑上对dp进行剪枝,如何区分dp和贪心,需要大量做题经验**

简单dp:爬楼梯/打家劫舍/最大子段和/网格图dp

背包dp:01背包/完全背包/多重背包/分组背包/树形背包

线性dp:LCS(最长公共子序列)/LIS(最长递增子序列)

套路dp:划分型dp/区间dp/状压dp/轮廓线dp/数位dp/树形dp/换根dp/计数dp(基于组合计数的dp)

状态设计:状态机dp/多维dp/前缀dp/后缀dp/刷表法/填表法

特殊dp:不相交区间型dp/子数组dp/合法子序列dp/子矩形dp/拓扑序dp/图dp/博弈dp/概率,期望dp/数学结论dp

输出具体方案型dp/构造型dp

前后缀分解

优化dp:前缀和优化dp/单调栈优化dp/单调队列优化dp/树状数组,线段树优化dp/字典树优化dp/矩阵快速幂优化dp/斜率优化dp/费用提前思考/wqs二分优化dp/特殊技巧优化dp/数据结构优化dp

## 10.数据结构

栈:后进先出

常用于解决:邻项消除/合法括号字符串/表达式解析

单调栈:

对顶栈:

队列:先进先出

双端队列

单调队列



堆:重排元素/第k小,大

反悔堆:常用于解决反悔贪心

懒删除堆

对顶堆:滑动窗口第 K 小/大

字典树:字典序问题

01字典树:往往和位运算题目结合



并查集:集合合并

gcd并查集

数组上的并查集

区间并查集

带权并查集



一维树状数组:维护区间信息,单点修改/区间查询/逆序对

二维树状数组:维护区间信息,区间修改/区间查询

注意:树状数组通常只能维护不可差分信息,如累加和,不能维护最大/最小值等不可差分信息

某些时候树状数组可以被SortedList替代



普通线段树:维护区间信息,单点修改/区间查询

Lazy线段树:维护区间信息,区间修改/区间查询

线段树可以维护不可差分信息



动态开点线段树:当值域范围过大,如1e9时,需要动态开点

动态开点线段树通常也可以被线段树+离散化替代

某些动态开点线段树题目也可以用珂朵莉树解决

可持久化线段树:常用于需要回滚版本的查询问题



SortedList:维护区间第k小/大,插入/删除值后保证区间依然有序,某些时候可以代替树状数组

SortedDict:常用于珂朵莉树的实现

SortedSet:常用于树上启发式合并

splay

treap/平衡树

离线算法:常用于区间查询问题

## 11.贪心

**识别贪心问题需要大量经验,当常规做法难以解决或者复杂度过高时,可以尝试贪心**

基本贪心:从最小,最大开始贪心/从最左,最右开始贪心/先枚举,再贪心

套路贪心:划分型贪心/交换论证法/相邻不同型贪心/反悔贪心

区间贪心:不相交区间/区间分组/区间选点/区间覆盖/合并区间

字符串贪心:字典序最小,最大贪心/回文串贪心/合法括号字符串贪心

数学贪心:乘积贪心/排序不等式/基本不等式/中位数贪心/归纳法/其他数学技巧

## 12.数学

**常见数学问题可以一眼看出,其他需要一定经验,和贪心类似,当常规做法难以解决或者复杂度过高时,可以尝试数学方法或者数学公式推导**

数论:质数筛/质因数分解/阶乘分解/gcd/lcm/互质/同余/其他数论技巧

组合数学:乘法原理/组合计数,计数dp/放球问题/容斥原理/贡献法

特殊领域:博弈论/计算几何/随机算法(这里的随机算法偏向指生成随机数的算法)/水塘抽样/模拟退火

特殊技巧:回文数/整数拆分/曼哈顿距离/多项式卷积/FWT

博弈:博弈dp/数学博弈/sg函数等

概率期望:纯数学问题/概率,期望dp/树,图上期望问题

## 13.大模拟

**题意很明确,需要实现一系列给定的操作,即大模拟**

矩阵模拟:注意有专门模版

## 14.爆搜/暴力枚举

**求出所有方案的过程,即为爆搜,某些无法用dp实现的题目,也需要爆搜求解**

注意爆搜和dp求具体方案的区别.

有些看似数据范围很大的题目,实际搜索范围不大,因此也可以用爆搜解决.

## 15.杂题

一些比较冷门的问题,无法加入常见分类

1.循环节算法,本质是kmp的拓展

# 3.题目关键字篇

## 子数组/子串问题

1.求最长/最短子数组/子串

2.求子数组/子串个数

这两种题型都可以用**滑动窗口/双指针**解决

3.子数组/子串中两种字符差值的最大值最小值

枚举字符种类+滑动窗口+前缀和

```python
#3445(https://leetcode.cn/problems/maximum-difference-between-even-and-odd-frequency-ii/)
```

4.更复杂的子数组问题

子数组dp/线段树/RMQ

## 最大值/最小值

子数组最大/最小:单调队列/排序+滑窗

子序列和最大/最小:堆

## 子序列问题

1.判断子序列

双指针/子序列自动机

2.合法子序列

合法子序列dp

## 最值问题

1.求最小/最大

二分答案/dp/最短路/bfs

2.最小化最大值/最大化最小值

二分答案

3.复杂最值问题

dp/最短路/bfs

## 第k小/大

二分/二分套二分/二分答案/堆

## 最小字典序

排序/字典树/字典序最小,最大贪心/单调栈/最小,最大表示法/字典序枚举/dp按字典序输出方案/有序pair处理字典序/线段树/RMQ

## 滑动窗口第 K 小/大

对顶堆

## 双变量问题

枚举右,维护左

## 多变量问题

三个变量以上,优先考虑枚举中间

## 山形三元组问题

枚举中间/前后缀分解/单调栈

## 折返行走问题

滑动窗口

## 非递增/非递减/单调

单调栈/单调队列

## 区间问题

1.不相交区间

不相交区间型dp/不相交区间型贪心

2.区间分组

贪心

3.区间选点

贪心

4.区间覆盖

贪心

5.合并区间

贪心

6.更复杂的区间问题

滑动窗口/扫描线/堆/数据机构+贪心

## 子数组划分问题

划分型dp/划分型贪心

## 相邻不同

相邻不同型构造贪心

## 邻项消除

栈

## 最短距离

最短路/bfs/01bfs/分段bfs/dp/贪心

## 重排元素

堆

## 逆序对

二维逆序对:树状数组/归并排序

高维度逆序对,即n维偏序问题:CDQ分治

## 单序列配对/双序列配对

贪心/双指针

## 回文

最长回文子序列:dp

最长回文子串:中心扩展/Manacher

枚举回文串

回文串贪心

回文数

## 判环

1.无向图

dfs/并查集

2.有向图

三色标记法/拓扑排序/弗洛伊德判圈法(龟兔赛跑)

3.基环树

无向无权图最小环:bfs

## gcd问题

欧几里得除法/logTrick/质因数分解/gcd并查集

## 矩形

单调栈/悬线法/子矩形dp

## 特殊式子变形

1.$a_1<=a_2<=a_3...<=a_i>=a_{i+1}>=a_{i+2}...>=a_n \rightarrow 前后缀分解$ 

2.$j-i\quad !=nums[j]-nums[i]\rightarrow 移项式子变形$

3.$abs(nums[i]-nums[j])>=v\rightarrow 式子变形\rightarrow mx-nums[j]>=v或者nums[j]-mn>=v$

4.询问是否存在子数组b满足$max(b)-min(b)>=len(b)$

当最大值和最小值分别取在子数组两个端点时,更容易满足要求.考虑子数组3,7,1,4,它显然不如7,1,因为后者max(b)-min(b)和前者一样,但是长度更小,更同意满足条件.因此分两种情况讨论,第一种是最大值在左端点,最小值在右端点,第二种是最大值在右端点,最小值在左端点.拿最大值在右端点举例,式子可以变形为

$a[j]-a[i]>=(j-i+1)\rightarrow a[j]-j>=a[i]-i+1\rightarrow a[j]-j>a[i]-i$

这可以用枚举右,维护左解决.最大值在右端点的情况同理

5.绝对值变形,将绝对值表达式分情况讨论拆分成不带绝对值的形式

## 字符串中只有26个字母

枚举字母

## 值域很小

枚举所有可能取值

## 除2

除2等价于右移2位

位运算/lowbit/logtrick

## 杨辉三角

**对于相邻项叠加问题,可以转化成杨辉三角**

可以从两个方向思考:

1.一种是从杨辉三角系数出发求解

2.另一种是从递归角度思考,即f(i,j)=f(i+1,j)+f(i,j-1)

## 两部分之间的关系

前后缀分解

## 跳跃游戏

倒序思考

dp

# 4.技巧篇

## 1.枚举

枚举右,维护左:双指针

枚举中间:双指针/三指针/前后缀分解/单调栈

值域枚举

折半枚举

## 2.逆向

从右往左,正难则反,从右下往左上,以及各种逆向思维方式

尤其是图论问题,反向思考有时候有奇效,求起点到终点距离不好求,求终点到起点可能就好求

戳气球不好求,填气球就简单了

当前问题不好解决,考虑当前问题的补集,即容斥原理

```python
#174(https://leetcode.cn/problems/dungeon-game/)
#312(https://leetcode.cn/problems/burst-balloons/)
```

## 3.排序

数值排序:快排/堆排/归并排序/计数排序/桶排序

以及衍生的快速选择算法/归并分治思想/荷兰国旗算法

索引排序:将索引按照在原数组中的值排序

```python
ids=sorted(range(len(nums)),key=lambda p:nums[p])
```

## 4.置换

将一个数组映射成某个关系后,对另一个数组应用这个关系,可以简化问题难度,常用于双数组问题

循环排列置换性:当题目中的表达式是一个循环形式时,注意对于原排列的所有置换,表达式的值都一样

```python
#2179(https://leetcode.cn/problems/count-good-triplets-in-an-array/description/)
#3149(https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/description/)
```

## 5.哈希

哈希表/滚动哈希/原地哈希/字符串哈希/tuple防止卡哈希

## 6.对称

从对称性出发,可以消掉很多东西,从而简化求解过程

```python
#2527(https://leetcode.cn/problems/find-xor-beauty-of-array/)
#3363(https://leetcode.cn/problems/find-the-maximum-number-of-fruits-collected/)
```

## 7.滑动窗口

定长/不定长/恰好/掉头折返型滑窗/分组滑窗/特殊滑窗/双栈滑窗

## 8.双指针

双指针/快慢指针/三指针/k指针

## 9.前缀和

1.一维/二维前缀和

2.**字符出现次数为偶数/奇数**:长度为偶数的子串必定是异或值为0的两个前缀和做差而来,长度为奇数的子串必定是异或值为1的两个前缀和做差而来

3.前缀和+哈希表

4.距离和

5.前缀异或和:可以解决回文问题

## 10.差分

一维差分/扫描线

二维差分

## 11.做差

```python
#76(https://leetcode.cn/problems/minimum-window-substring/)
```

## 12.状压

二进制状压,tuple状压

## 13.递归

链表/树/dp的递归及非递归实现

## 14.归并分治

树上/数组上归并分治

## 15.倍增

数组上的倍增/树上倍增

## 16.二次扫描

正反两次扫描数组,结果取交集/并集等,在栈,贪心题目中常用这种技巧,换根dp本质也是二次扫描

```python
#2116(https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/description/)
#3413(https://leetcode.cn/problems/maximum-coins-from-k-consecutive-bags/description/)
```

## 17.前后缀分解

前后缀和/双指针/前后缀dp

## 18.LogTrick/双栈滑窗

位运算

## 19.拆位/贡献法

拆位:位运算

贡献法:单调栈/位运算/数学

## 20.试填法

位运算

## 21.交换论证法

这是一种常用贪心技巧,主要用数学方法进行论证

## 22.离散化

值域范围过大时,要使用离散化

## 23.破环成链

解决环上问题通用方式,也可用于环形数组,环形链表等

即通过在原数组后面接一个一模一样的数组或者模运算的方式实现

```python
#2134(https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/description/)
```

## 24.折返分裂

对于一来一回的问题,可以拆解成两条去的路径

```python
#741(https://leetcode.cn/problems/cherry-pickup/)
```

## 25.同时记录两组状态

在dp函数中同时记录两个人的坐标

```python
#741(https://leetcode.cn/problems/cherry-pickup/)
```

## 26.检验双射

```python
#291(https://leetcode.cn/problems/word-pattern-ii/)
```

## 27.恒等式

位运算

## 28.扫描线

处理区间问题的利器

## 29.公式推导

一定程度的数学公式推导可以消除冗余项,简化计算

```python
#724(https://leetcode.cn/problems/find-pivot-index/)
```

## 30.考虑相邻元素

某些复杂的题目可以转成考虑相邻元素关系的问题

## 31.根号分治/分块/莫队

三种根号复杂度的结构

## 32.构造

构造题纯靠经验

巧妙的构造方法可以极大简化代码

```python
#2610(https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/description/)
```

## 33.思维题

/从特殊到一般/脑筋急转弯/逆向思维/等价转换/位运算/单调栈
## 34.洪水填充+时光倒流

网格图问题常用技巧,常结合网格图dfs/网格图并查集一起使用,本质是逆向思维的一种

```python
#1970(https://leetcode.cn/problems/last-day-where-you-can-still-cross/description/)
```

## 35.双龙出海

即双集合多源bfs,常见于网格图,是一种常见技巧

```python
#2814(https://leetcode.cn/problems/minimum-time-takes-to-reach-destination-without-drowning/)
```

```python
#2258(https://leetcode.cn/problems/escape-the-spreading-fire/)
```

## 36.容斥原理

当正向dp会超时时,可以考虑其补集

```python
#3333(https://leetcode.cn/problems/find-the-original-typed-string-ii/)
```

## 37.剪枝

当dp上界过大时,可以用剪枝方法将上界剪到可行范围

```py
#3333(https://leetcode.cn/problems/find-the-original-typed-string-ii/)
```

## 38.最优性选择问题

```python
#https://codeforces.com/problemset/problem/625/A
fmax = lambda x, y: x if x > y else y
fmin = lambda x, y: x if x < y else y
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    ans=0
    if b-c<=a:
        ans=fmax(n-c,0)//(b-c)
        n-=ans*(b-c)
    ans+=n//a
    print(ans)
```

```python
#https://codeforces.com/contest/2113/problem/A
fmax = lambda x, y: x if x > y else y
fmin = lambda x, y: x if x < y else y
def solve():
    k,a,b,x,y = map(int, input().split())
    if x>y:
        a,b=b,a
        x,y=y,x
    ans=fmax(k-a+x,0)//x
    k-=ans*x
    ans+=fmax(k-b+y,0)//y
    print(ans)
t = int(input())
for i in range(t):
    solve()
```

## 39.分组循环

## 40.反搜路径

# 5.必杀技篇

当常用方法无法解决问题时,可尝试脑筋急转弯/数学公式推导/构造/猜想/打表

