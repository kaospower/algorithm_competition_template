[TOC]

**请注意:以下所有问题在某些特殊情况下都可以用暴力解决,在求解相应问题时请关注题目给出的复杂度**

**本专题解决的是遇到一道题目,思考的方向**

# 1.子数组问题

## 1.子数组个数

### 1.滑窗(越长越合法/越短越合法/恰好型滑窗)

```python
#2537(https://leetcode.cn/problems/count-the-number-of-good-subarrays/description/)
class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        ans=l=cnt=0
        d=defaultdict(int)
        for x in nums:
            cnt+=d[x]
            d[x]+=1
            while cnt>=k:
                x=nums[l]
                d[x]-=1
                cnt-=d[x]
                l+=1
            ans+=l
        return ans
```

### 2.前缀和+哈希表

```python
#2588(https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/)
class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        pre=ans=0
        d=defaultdict(int)
        for i,x in enumerate(nums):
            d[pre]+=1
            pre^=x
            ans+=d[pre]
        return ans
```

## 2.子数组翻转问题

### 1.并查集

```python
#2612(https://leetcode.cn/problems/minimum-reverse-operations/description/)
class UnionFind:
    def __init__(self, n: int):
        self.fa = list(range(n))

    def find(self, x: int) -> int:
        if self.fa[x] != x:
            self.fa[x] = self.find(self.fa[x])
        return self.fa[x]

    def merge(self, from_: int, to: int) -> None:
        self.fa[self.find(from_)] = self.find(to)

class Solution:
    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:
        indices = UnionFind(n + 2)
        indices.merge(p, p + 2)  # 删除 p
        for i in banned:
            indices.merge(i, i + 2)  # 删除 i

        ans = [-1] * n
        ans[p] = 0
        q = deque([p])
        while q:
            i = q.popleft()
            mn = max(i - k + 1, k - i - 1)
            mx = min(i + k - 1, n * 2 - k - i - 1)
            j = indices.find(mn)
            while j <= mx:
                ans[j] = ans[i] + 1
                q.append(j)
                indices.merge(j, mx + 2)  # 删除 j
                j = indices.find(j + 2)  # 快速跳到 >= j+2 的下一个下标
        return ans
```

## 3.子数组长度问题

### 1.logtrick

```python
#3095(https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-i/description/)
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        ans=inf
        for i,x in enumerate(nums):
            if nums[i]>=k:
                return 1
            j=i-1
            while j>=0 and nums[j]|x!=nums[j]:
                nums[j]=nums[j]|x
                if nums[j]>=k:
                    ans=min(ans,i-j+1)
                    break
                j-=1
        return -1 if ans==inf else ans
```

### 2.双栈滑窗

```python
#3095(https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-i/description/)
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        ans,n=inf,len(nums)
        sums=l=bottom=0
        for r in range(n):
            sums|=nums[r]
            while l<=r and nums[l]|sums>=k:
                #等价于ans=min(ans,r-l+1)
                if (cur:=r-l+1)<ans:ans=cur
                if bottom==l:
                    for i in range(r-1,l,-1):nums[i]|=nums[i+1]
                    sums,bottom=0,r+1
                l+=1
        return -1 if ans==inf else ans
```

## 4.子数组模k乘积问题

### 1.刷表法

**在动态规划中，根据转移来源计算状态叫查表法，用当前状态更新其他状态叫刷表法。**

```python
#(https://leetcode.cn/problems/find-x-value-of-array-i/)
class Solution:
    def resultArray(self, nums: List[int], k: int) -> List[int]:
        n=len(nums)
        f=[[0]*k for _ in range(n+1)]
        ans=[0]*k
        for i,x in enumerate(nums):
            f[i+1][nums[i]%k]=1
            for j,v in enumerate(f[i]):
                f[i+1][x*j%k]+=v
            for j,v in enumerate(f[i+1]):
                ans[j]+=v
        return ans
```

# 2.子序列问题

# 3.子集类问题

**子集类问题即无顺序的子序列问题,而后者可以用dp解决**

## 1.背包dp

```python
#416(https://leetcode.cn/problems/partition-equal-subset-sum/description/)
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums=sum(nums)
        if sums&1:
            return False
        m=sums//2
        f=[False]*(m+1)
        f[0]=True
        for num in nums:
            for j in range(m,num-1,-1):
                f[j]=f[j] or f[j-num]
        return f[m]
```

## 2.子集型回溯

```python
#2597(https://leetcode.cn/problems/the-number-of-beautiful-subsets/description/)
class Solution:
    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        ans=-1 #去掉空集
        def f(i,d):
            if i==-1:
                nonlocal ans
                ans+=1
                return 
            f(i-1,d)
            v=nums[i]
            if d[v-k]==0 and d[v+k]==0:
                t=d.copy()
                t[v]+=1
                f(i-1,t)
        f(len(nums)-1,defaultdict(int))
        return ans

```

# 4.字符串问题

## 1.贪心

```python
#2712(https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/description/)
class Solution:
    def minimumCost(self, s: str) -> int:
        n=len(s)
        ans=0
        for i in range(1,n):
            if s[i]!=s[i-1]:
                ans+=min(i,n-i)
        return ans
```

## 2.状态机dp

```python
#2272(https://leetcode.cn/problems/substring-with-largest-variance/description/)
class Solution:
    def largestVariance(self, s: str) -> int:
        ans = 0
        f0 = [[0] * 26 for _ in range(26)]
        f1 = [[-inf] * 26 for _ in range(26)]
        for ch in map(ord, s):
            ch -= ord('a')
            # 遍历到 ch 时，只需计算 a=ch 或者 b=ch 的状态，其他状态和 ch 无关，f 值不变
            for i in range(26):
                if i == ch:
                    continue
                # 假设出现次数最多的字母 a=ch，更新所有 b=i 的状态
                f0[ch][i] = max(f0[ch][i], 0) + 1
                f1[ch][i] += 1
                # 假设出现次数最少的字母 b=ch，更新所有 a=i 的状态
                f1[i][ch] = f0[i][ch] = max(f0[i][ch], 0) - 1
                ans = max(ans, f1[ch][i], f1[i][ch])
        return ans
```

## 3.滑窗

```python
#3306(https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/)
#恰好型滑窗
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        n=len(word)
        return self.f(word,k,n)-self.f(word,k+1,n)
    def f(self,nums,target,n):
        l=0
        cnts=defaultdict(int)
        cnt=0
        ans=0
        for num in nums:
            if num in 'aeiou':
                cnts[num]+=1
            else:
                cnt+=1
            while len(cnts)==5 and cnt>=target:
                if nums[l] in 'aeiou':
                    cnts[nums[l]]-=1
                    if cnts[nums[l]]==0:
                        del cnts[nums[l]]
                else:
                    cnt-=1
                l+=1
            ans+=l
        return ans 
```

## 4.划分型dp

```python
#1278(https://leetcode.cn/problems/palindrome-partitioning-iii/)
class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        n=len(s)
        @cache
        def g(i,j):
            if i>=j:
                return 0
            return g(i+1,j-1)+(0 if s[i]==s[j] else 1)
        @cache
        def f(i,k):
            if i>=0 and k==0:
                return inf
            if i<0:
                return 0 if k==0 else inf
            return min(f(j-1,k-1)+g(j,i) for j in range(k-1,i+1))
        return f(n-1,k)
```

## 5.划分型回溯

```python
#131(https://leetcode.cn/problems/palindrome-partitioning/description/)
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans=[]
        #i代表某个子串开始位置,k代表上一个子串开始位置,s[i:k]代表当前子串,path记录路径
        def f(i,k,path):
            if i==-1:
                ans.append(path)
                return
            #不在当前位置截断,继续向前
            if i:
                f(i-1,k,path)
            #在当前位置截断
            t=s[i:k]
            if t==t[::-1]:
                f(i-1,i,[t]+path)
        n=len(s)
        f(n-1,n,[])
        return ans 
```

## 6.字符串掩码

```python
#2506(https://leetcode.cn/problems/count-pairs-of-similar-strings/description/)
class Solution:
    def similarPairs(self, words: List[str]) -> int:
        ans=0
        d=defaultdict(int)
        for x in words:
            t=0
            for c in set(x):
                t|=1<<(ord(c)-ord('a'))
            ans+=d[t]
            d[t]+=1
        return ans
```

# 5.设计类问题

## 1.懒删除堆

```python
#2353(https://leetcode.cn/problems/design-a-food-rating-system/description/)
class FoodRatings:

    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):
        self.d=defaultdict(list)
        self.e={}
        for x,y,z in zip(cuisines,ratings,foods):
            self.d[x].append((-y,z))
            self.e[z]=[x,y]
        for h in self.d.values():
            heapify(h)
        

    def changeRating(self, food: str, newRating: int) -> None:
        p=self.e[food]
        heappush(self.d[p[0]],(-newRating,food))
        p[1]=newRating
    
    def highestRated(self, cuisine: str) -> str:
        h=self.d[cuisine]
        while -h[0][0]!=self.e[h[0][1]][1]:
            heappop(h)
        return h[0][1]
        
```

## 2.对顶栈

```python
#2296(https://leetcode.cn/problems/design-a-text-editor/description/)
class TextEditor:
    def __init__(self):
        self.left = []  # 光标左侧字符
        self.right = []  # 光标右侧字符

    def addText(self, text: str) -> None:
        self.left.extend(text)  # 入栈

    def deleteText(self, k: int) -> int:
        pre = len(self.left)  # 删除之前的栈大小
        del self.left[-k:]  # 出栈
        return pre - len(self.left)  # 减去删除之后的栈大小

    def text(self) -> str:
        return ''.join(self.left[-10:])  # 光标左边至多 10 个字符

    def cursorLeft(self, k: int) -> str:
        while k and self.left:
            self.right.append(self.left.pop())  # 左手倒右手
            k -= 1
        return self.text()

    def cursorRight(self, k: int) -> str:
        while k and self.right:
            self.left.append(self.right.pop())  # 右手倒左手
            k -= 1
        return self.text()
```

## 3.数组

```python
#1472(https://leetcode.cn/problems/design-browser-history/description/)
class BrowserHistory:
    def __init__(self, homepage: str):
        self.history = [homepage]
        self.cur = 0  # 当前页面是 history[cur]

    def visit(self, url: str) -> None:
        self.cur += 1
        del self.history[self.cur:]  # 把浏览历史前进的记录全部删除
        self.history.append(url)  # 从当前页跳转访问 url 对应的页面

    def back(self, steps: int) -> str:
        self.cur = max(self.cur - steps, 0)  # 后退 steps 步
        return self.history[self.cur]

    def forward(self, steps: int) -> str:
        self.cur = min(self.cur + steps, len(self.history) - 1)  # 前进 steps 步
        return self.history[self.cur]
```

## 4.哈希表+有序表

```python
#2502(https://leetcode.cn/problems/design-memory-allocator/description/)
class Allocator:

    def __init__(self, n: int):
        self.d=defaultdict(list)
        self.arr=SortedList()
        self.arr.add((-1,-1))
        self.arr.add((n,n))
        self.vol=2
    def allocate(self, size: int, mID: int) -> int:
        for i in range(self.vol-1):
            a,b=self.arr[i]
            c,d=self.arr[i+1]
            if c-b-1>=size:
                self.arr.add((b+1,b+size))
                self.d[mID].append((b+1,b+size))
                self.vol+=1
                return b+1
        return -1


    def freeMemory(self, mID: int) -> int:
        if mID not in self.d:
            return 0
        cnt=0
        for x,y in self.d[mID]:
            self.arr.remove((x,y))
            self.vol-=1
            cnt+=y-x+1
        del self.d[mID]
        return cnt
```

## 5.跳表

```c++
class Skiplist {
public:
    static const int level=8;//层数
    struct Node{
        int val;
        vector<Node*>next;
        Node(int _val):val(_val){
            next.resize(level,NULL);
        }
    }*head;
    Skiplist() {
        head=new Node(-1);
        
    }
    ~Skiplist() {
        delete head;
        
    }
    
    void find(int target,vector<Node*>& pre){
        auto p=head;
        for (int i=level-1;i>=0;i--){
            while (p->next[i] && p->next[i]->val<target) p=p->next[i];
            pre[i]=p;
        }
    }
    bool search(int target) {
        vector<Node*>pre(level);
        find(target,pre);
        auto p=pre[0]->next[0];
        return p && p->val==target;
    }
    
    void add(int num) {
        vector<Node*>pre(level);
        find(num,pre);
        auto p=new Node(num);
        for (int i=0;i<level;i++){
            p->next[i]=pre[i]->next[i];
            pre[i]->next[i]=p;
            if (rand()%2) break;
        }
    }
    
    bool erase(int num) {
        vector<Node*>pre(level);
        find(num,pre);
        auto p=pre[0]->next[0];
        if (!p||p->val!=num) return false;

        for (int i=0;i<level && pre[i]->next[i]==p;i++)
            pre[i]->next[i]=p->next[i];
        delete p;
        return true;
    }
};
```

## 6.哈希表+二分

```python
#2080(https://leetcode.cn/problems/range-frequency-queries/description/)
class RangeFreqQuery:

    def __init__(self, arr: List[int]):
        self.d=defaultdict(list)
        for i,x in enumerate(arr):
            self.d[x].append(i)
    def query(self, left: int, right: int, value: int) -> int:
        arr=self.d[value]
        # return bisect_left(arr,right+1)-bisect_left(arr,left)
        #<=right即>=right+1再-1,和>=left作差后再+1消掉了
        return bisect_right(arr,right)-bisect_left(arr,left)
```

## 7.珂朵莉树

```python
#珂朵莉树
class ODT:
    def __init__(self):
        self.tree = SortedList()

    #截断函数
    def split(self,pos):
        idx = self.tree.bisect_left([pos,])
        if idx != len(self.tree) and self.tree[idx][0] == pos:
            return idx 
        idx -= 1
        l,r,v = self.tree[idx]
        self.tree[idx][1] = pos-1
        self.tree.add([pos,r,v])
        return idx+1
       
    #赋值函数
    def assign(self,l,r,v):
        begin = self.split(l)
        end = self.split(r+1)
        for i in range(begin,end):
            if self.tree[i][2]>0:
                return False
        del self.tree[begin:end]
        self.tree.add([l,r,v])
        return True
class MyCalendar:

    def __init__(self):
        self.odt=ODT()
        self.odt.tree.add([0,inf,0])

    def book(self, startTime: int, endTime: int) -> bool:
        return self.odt.assign(startTime,endTime-1,1)
        
```

# 6.异或类问题

## 1.隔位异或

```python
#1734(https://leetcode.cn/problems/decode-xored-permutation/)
class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        n=len(encoded)
        s=reduce(xor,encoded[::2])
        t=reduce(xor,range(1,n+2))
        ans=[0]*(n+1)
        ans[-1]=s^t
        for i in range(n-1,-1,-1):
            ans[i]=encoded[i]^ans[i+1]
        return ans
```

## 2.枚举

```python
#2857(https://leetcode.cn/problems/count-pairs-of-points-with-distance-k/)
class Solution:
    def countPairs(self, coordinates: List[List[int]], k: int) -> int:
        d=defaultdict(int)
        ans=0
        for x,y in coordinates:
            for i in range(k+1):
                ans+=d[(i^x,k-i^y)]
            d[(x,y)]+=1
        return ans
```

## 3.考虑奇偶性

```python
#3215(https://leetcode.cn/problems/count-triplets-with-even-xor-set-bits-ii/)
#统计每个数组的设置位的个数t,要么三组的t都是偶数,要么两奇一偶
class Solution:
    def tripletCount(self, a: List[int], b: List[int], c: List[int]) -> int:
        count_odd_1 = lambda a: sum(x.bit_count() % 2 for x in a)
        x, y, z = count_odd_1(a), count_odd_1(b), count_odd_1(c)
        return (len(a) - x) * (len(b) - y) * (len(c) - z) + \
            x * y * (len(c) - z) + x * z * (len(b) - y) + y * z * (len(a) - x)
```



# 7.与或类问题

## 1.利用AND/OR的基本性质贪心

```python
1.随着AND的数越来越多,AND只会越来越小
2.随着OR的数越来越多,OR只会越来越大
-1和任何数的AND都是那个数的本身,-1可以看成11111....1111,即一个比特位全为1的数
```



```python
#2871(https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/)
#与的性质,贪心
#假设整个子数组的AND值为a(a>0),由于AND的数越多,AND越小,AND数越少,AND越大
#因此如果整个数组分出两个子数组x,y,那么它们各自的AND值一定>=a,加起来就是2a>a了
#因此只有遇到AND值为0的子数组,才考虑对其进行分割,如果不为0,不分割
class Solution:
    def maxSubarrays(self, nums: List[int]) -> int:
        ans = 0
        a = -1  # -1 就是 111...1，和任何数 AND 都等于那个数
        for x in nums:
            a &= x
            if a == 0:
                ans += 1  # 分割
                a = -1
        return max(ans, 1)  # 如果 ans=0 说明所有数的 and>0，答案为 1
```



```python
#2680(https://leetcode.cn/problems/maximum-or/description/)
class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        n = len(nums)
        # suf[i] 表示 nums[i+1:] 的 OR
        suf = [0] * n
        for i in range(n - 2, -1, -1):
            suf[i] = suf[i + 1] | nums[i + 1]

        # pre 表示 nums[:i] 的 OR
        ans = pre = 0
        for x, suf_or in zip(nums, suf):
            ans = max(ans, pre | (x << k) | suf_or)
            pre |= x
        return ans
```

## 2.利用AND的性质优化dp

**当dp题中出现AND等位运算符号时,要注意位运算的性质,由于AND的结果数量有限,因此AND的结果可以作为参数写在记忆化搜索中,也可以用Logtrick等方法优化**

```python
#3117(https://leetcode.cn/problems/minimum-sum-of-values-by-dividing-array/)
#本题也可以用双栈滑窗/logtrick/线段树优化dp/单调队列优化dp等方法解决
#本题非常特殊,需要记录and的值,因为and的值的数量是有限的
#本题写法比较像2463题
class Solution:
    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:
        n,m=len(nums),len(andValues)
        #i表示nums下标,j表示当前已经完成了几段划分
        @cache
        def f(i,j,s):
            if n-i<m-j:  # 剩余元素不足
                return inf
            if j==m:  # 分了 m 段
                return 0 if i==n else inf
            s&=nums[i]
            res=f(i+1,j,s) #当前段继续延长,不划分
            #与的结果==andValues[j],可以划分
            if s==andValues[j]:  # 划分,nums[i] 是这一段的最后一个数
                res=min(res,f(i+1,j+1,-1)+nums[i])
            return res
        ans=f(0,0,-1)
        return ans if ans < inf else -1
```

## 3.LogTrick



# 8.二元组问题

## 1.式子变形

**通过移项等技巧对所给条件进行变形,转化成枚举右维护左问题**

```python
#2364(https://leetcode.cn/problems/count-number-of-bad-pairs/description/)
class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        d=defaultdict(int)
        ans=0
        for i,x in enumerate(nums):
            t=x-i
            ans+=i-d[t]
            d[t]+=1
        return ans
```

## 2.双指针

```python
#2563(https://leetcode.cn/problems/count-the-number-of-fair-pairs/description/)
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        n=len(nums)
        nums.sort()
        def f(x):
            i,j,ans=0,n-1,0
            while i<j:
                if nums[i]+nums[j]>x:
                    j-=1
                else:
                    ans+=j-i
                    i+=1
            return ans
        return f(upper)-f(lower-1)
```



# 9.三元组问题

**三元组问题一般要进行左右拆分,计算出左边和右边数量,相乘即是答案**

## 1.树状数组/有序表

```python
#2179(https://leetcode.cn/problems/count-good-triplets-in-an-array/description/)
class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        #将nums1映射成0,1,2,...,n-1,nums2按照这个关系映射,就从位置问题转化成数值问题
        d={x:i for i,x in enumerate(nums1)}
        nums2=[d[x] for x in nums2]
        s=SortedList()
        ans=0
        for i,x in enumerate(nums2):
            s.add(x)
            left=s.bisect_left(x) #left记录x左边比x小的数量
            #n-1-x为比x大的总数量,i-left为x左边比x大的数量,做差即为right记录x右边比x大的数量
            right=n-1-x-(i-left) 
            ans+=left*right
        return ans
```

## 2.枚举右,维护左

```python
#2874(https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/)
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        max_diff=pre=ans=0
        for x in nums:
            ans=max(ans,max_diff*x)
            max_diff=max(max_diff,pre-x)
            pre=max(pre,x)
        return ans
```

```python
#1442(https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)
#这个解法在枚举右维护左的基础上添加了间隔至少为2的延迟修改
class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        ans=s=0
        d=defaultdict(int)
        tot=defaultdict(int)
        #第i轮的前缀和t,第i+1轮才加入到哈希表,第i+2轮才投入使用,从而保证了数组长度至少是2
        for i,v in enumerate(arr):
            if (t:=s^v) in d:
                ans+=d[t]*i-tot[t]
            d[s]+=1
            tot[s]+=i
            s=t
        return ans
```



## 3.暴力+优化

**朴素暴力即三重循环,当结果和顺序无关时,可以使用循环拆分的技巧,将三重循环拆成二重循环+一重循环**

```python
#3514(https://leetcode.cn/problems/number-of-unique-xor-triplets-ii/)
class Solution:
    def uniqueXorTriplets(self, nums: List[int]) -> int:
        nums = list(set(nums))  # 优化：去重，减少循环次数
        st={x^y for x in nums for y in nums}
        return len({xy^z for xy in st for z in nums})
```

## 4.前后缀分解

```python
#2012(https://leetcode.cn/problems/sum-of-beauty-in-the-array/description/)
class Solution:
    def sumOfBeauties(self, nums: List[int]) -> int:
        n=len(nums)
        suf=[0]*n
        suf[-1]=nums[-1]
        for i in range(n-2,-1,-1):
            suf[i]=min(nums[i],suf[i+1])
        ans=0
        maxv=nums[0]
        for i in range(1,n-1):
            x=nums[i]
            if maxv<x<suf[i+1]:
                ans+=2
            elif nums[i-1]<x<nums[i+1]:
                ans+=1
            maxv=max(maxv,x)
        return ans
            
```

# 10.计数问题

## 1.朴素计数

**如果朴素计数问题的数量较大,可能需要取模,这时一般要用到快速幂**

```python
#1922(https://leetcode.cn/problems/count-good-numbers/description/)
mod=1_000_000_007
class Solution:
    def countGoodNumbers(self, n: int) -> int:
        #奇数下标n//2个,偶数下标(n+1)//2个
        return (pow(4,n//2,mod)*pow(5,(n+1)//2,mod))%mod
```

## 2.组合数学

**组合数学的题目往往要求逆元和阶乘**

```python
#3272(https://leetcode.cn/problems/find-the-count-of-good-integers/description/)
N=11
fact=[0]*N
fact[0]=1
for i in range(1,N):
    fact[i]=fact[i-1]*i
class Solution:
    def countGoodIntegers(self, n: int, k: int) -> int:
        ans=0
        visited=set()
        base=10**((n-1)//2)
        for i in range(base,base*10):#枚举回文数
            s=str(i)
            s+=s[::-1][n&1:]
            if int(s)%k:continue
            st=''.join(sorted(s))
            if st in visited:continue
            visited.add(st)

            cnt=Counter(st)
            res=(n-cnt['0'])*fact[n-1]
            for x in cnt.values():
                res//=fact[x]
            ans+=res
        return ans
```

## 3.数位dp

**当题干中提出求指定范围的数字个数,且范围很大时,往往就是数位dp**

```python
#2843(https://leetcode.cn/problems/count-symmetric-integers/description/)
class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        high=list(map(int,str(high)))
        n=len(high)
        low=list(map(int,str(low).zfill(n)))
        @cache
        def f(i,start,diff,limit_low,limit_high):
            if i==n:
                return 1 if diff==0 else 0
            
            lo=low[i] if limit_low else 0
            hi=high[i] if limit_high else 9
            #特判长度奇数情况
            if start<0 and (n-i)%2:
                return 0 if lo else f(i+1,start,diff,True,False)
            res=0
            is_left=start<0 or i<(start+n)//2 #奇数情况上面已经判断过了
            for d in range(lo,hi+1):
                res+=f(i+1,
                       i if start<0 and d else start, #记录第一个数字的位置
                       diff+(d if is_left else -d),
                       limit_low and d==lo,
                       limit_high and d==hi)
            return res
        return f(0,-1,0,True,True)
```

## 4.杨辉三角

遇到系数形如1,3,3,1之类应该联想到杨辉三角

# 11.图论问题

## 1.环

### 1.dfs+时间戳

**记录经过某个点的时间,如果在不同时间经过同一个点,说明存在环**

```python
#2360(https://leetcode.cn/problems/longest-cycle-in-a-graph/description/)
class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        cur=1
        vis=[0]*n
        ans=-1
        for i in range(n):
            start=cur
            while i!=-1 and vis[i]==0:
                vis[i]=cur
                cur+=1
                i=edges[i]
            #i!=-1说明存在环,如果不存在环,终点一定是-1
            #vis[i]>=start说明是本轮访问的,如果<start说明不是在本轮访问的,之前已经更新过了
            if i!=-1 and vis[i]>=start: 
                ans=max(ans,cur-vis[i])
        return ans
```

# 12.网格图问题

## 1.网格图dp

**题目给出的遍历方向具有单调性,往四个方向走的一定不是网格图dp**

## 2.网格图dfs/bfs

**可以向四个甚至八个方向走,这种只能用bfs/dfs,绝对不能用dp,因为不满足无后效性,如果求距离则优先用bfs/01bfs,有时也可以用最短路算法如Dijkstra**

# 13.查询类问题

## 1.在线算法

```python
#2070(https://leetcode.cn/problems/most-beautiful-item-for-each-query/description/)
class Solution:
    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        items.sort()
        n=len(items)
        k=0
        for i in range(1,n):
            if items[i][1]>items[k][1]:
                k+=1
                items[k]=items[i]
        
        for i,q in enumerate(queries):
            idx=bisect_left(items,[q+1,],0,k+1)-1 #0~k+1范围二分
            queries[i]=0 if idx==-1 else items[idx][1]
        return queries
```

## 2.离线算法

```python
#2070(https://leetcode.cn/problems/most-beautiful-item-for-each-query/description/)
class Solution:
    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        items.sort(key=lambda item: item[0])
        idx = sorted(range(len(queries)), key=lambda i: queries[i])

        ans = [0] * len(queries)
        max_beauty = j = 0
        for i in idx:
            q = queries[i]
            # 增量地遍历满足 queries[i-1] < price <= queries[i] 的物品
            while j < len(items) and items[j][0] <= q:
                max_beauty = max(max_beauty, items[j][1])
                j += 1
            ans[i] = max_beauty
        return ans
```

## 3.预处理(本质是离线算法)

**特别地,对于二进制字符串相关题目,由于一个数转成二进制后长度只有几十位,因此长度可以看成常数,通过预处理可以实现O(nlogU)的时间复杂度**

```python
#2564(https://leetcode.cn/problems/substring-xor-queries/)
class Solution:
    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        d={}
        if (cur:=s.find('0'))!=-1:
            d[0]=[cur,cur]
        arr=list(map(int,s))
        n=len(arr)
        for i in range(n):
            s=0
            if arr[i]:
                for j in range(i,min(i+30,n)):
                    s=s*2+arr[j]
                    if s not in d:
                        d[s]=[i,j]

        return [d.get(x^y,[-1,-1]) for x,y in queries]
```

# 14.距离问题

## 1.枚举右,维护左

```python
#624(https://leetcode.cn/problems/maximum-distance-in-arrays/description/)
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        mx,mn,ans=-inf,inf,0
        for x in arrays:
            #ans和历史最大值-当前最小值,当前最大值-历史最小值比较,求max
            ans=max(ans,max(mx-x[0],x[-1]-mn))
            mx=max(mx,x[-1]) #更新历史最大
            mn=min(mn,x[0]) #更新历史最小
        return ans
```

# 15.博弈问题

## 1.dp型博弈

```python
#913(https://leetcode.cn/problems/cat-and-mouse/description/)
class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        dp = [[[0, 0] for _ in range(n)] for _ in range(n)]
        degree = [[[0, 0] for _ in range(n)] for _ in range(n)]
        q = deque()
        for i in range(n):
            for j in range(n):
                degree[i][j][0] = len(graph[i])
                degree[i][j][1] = len(graph[j])
        for i in graph[0]:
            for j in range(n):
                degree[j][i][1] -= 1
        for i in range(1, n):
            dp[0][i][0] = 1
            dp[0][i][1] = 1
            q.append((0, i, 0))
            q.append((0, i, 1))
        for i in range(1, n):
            dp[i][i][0] = 2
            dp[i][i][1] = 2
            q.append((i, i, 0))
            q.append((i, i, 1))
        while q:
            midx, cidx, who = q.popleft()
            tmp = dp[midx][cidx][who]
            if who:
                for i in graph[midx]:
                    if tmp == 1 and dp[i][cidx][0] == 0:
                        dp[i][cidx][0] = 1
                        q.append((i, cidx, 0))
                    elif tmp == 2 and dp[i][cidx][0] == 0: 
                        degree[i][cidx][0] -= 1
                        if degree[i][cidx][0] == 0:
                            dp[i][cidx][0] = 2
                            q.append((i, cidx, 0))
            else:
                for i in graph[cidx]:
                    if i == 0:
                        continue
                    if tmp == 2 and dp[midx][i][1] == 0:
                        dp[midx][i][1] = 2
                        q.append((midx, i, 1))
                    elif tmp == 1 and dp[midx][i][1] == 0:
                        degree[midx][i][1] -= 1
                        if degree[midx][i][1] == 0:
                            dp[midx][i][1] = 1
                            q.append((midx, i, 1))
            
        return dp[1][2][0]
```

# 16.分治

## 1.分解变量

```python
#1706(https://leetcode.cn/problems/where-will-the-ball-fall/description/)
class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        n = len(grid[0])
        ans = [-1] * n
        for j in range(n):
            # 模拟第 j 列球的移动
            cur_col = j  # 当前列号
            for row in grid:
                d = row[cur_col]  # -1 或 1，表示左/右
                cur_col += d  # 左/右走一步
                # 如果球出界或者卡在 V 形，退出循环，否则继续循环（垂直落入下一排）
                # V 形就是 -1 的左边是 1，1 的右边是 -1，即 row[cur_col] != d
                if cur_col < 0 or cur_col == n or row[cur_col] != d:
                    break
            else:  # 没有中途 break，说明球成功到达底部
                ans[j] = cur_col
        return ans
        
```

# 17.区间最大最小

## 1.单调队列

# 18.最大化/最小化

```python
#1552(https://leetcode.cn/problems/magnetic-force-between-two-balls/description/)
class Solution:
    def maxDistance(self, price: List[int], k: int) -> int:
        price.sort()
        return self.find(1,(price[-1]-price[0])//(k-1),price,k)
    def check(self,d,price,k):
        x0,cnt=price[0],1
        for x in price:
            if x-x0>=d:
                cnt+=1
                x0=x
        return cnt>=k
    def find(self,l,r,price,k):
        ans=0
        while l<=r:
            m=(l+r)//2
            if self.check(m,price,k):
                ans=m
                l=m+1
            else:
                r=m-1
        return ans

```

# 19.特定排序问题

## 1.双指针

```python
#922(https://leetcode.cn/problems/sort-array-by-parity-ii/description/)
class Solution:
    def sortArrayByParityII(self, nums: List[int]) -> List[int]:
        n=len(nums)
        even=0
        odd=1
        while even<n and odd<n:
            if (nums[n-1]&1)==1:
                nums[n-1],nums[odd]=nums[odd],nums[n-1]
                odd+=2
            else:
                nums[n-1],nums[even]=nums[even],nums[n-1]
                even+=2
        return nums
```

# 20.操作次数问题

## 1.小根堆

```python
#3066(https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/description/)
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        heapify(nums)
        t=0
        while nums[0]<k:
            x=heappop(nums)
            heapreplace(nums,2*x+nums[0])
            t+=1
        return t
```

# 21.特殊题目的结论

## 1.(nums[i]|nums[j])&nums[k]

**该表达式在求异或和时由于对称性会转化成求数组的异或和**

```python
#2527(https://leetcode.cn/problems/find-xor-beauty-of-array/description/)
#nums[i]|nums[j]=nums[j]|nums[i],因此只有i=j时才对答案有贡献,原式化简为nums[j]&nums[k]
#同理nums[j]&nums[k]=nums[k]&nums[j],异或后消掉,因此只有j=k时对答案有贡献
#综上只有i=j=k时才对答案有贡献,即ans=(num[i]|nums[i])&nums[i]的异或和,即nums[i]的异或和
class Solution:
    def xorBeauty(self, nums: List[int]) -> int:
        return reduce(xor,nums)
```

## 2.nums[i] AND (nums[i] XOR x)

**该表达式等价于求or和**

```python
#2317(https://leetcode.cn/problems/maximum-xor-after-operations/)
def maximumXOR(self, nums: List[int]) -> int:
    return reduce(or_, nums)
```

# 22.恰好类问题

## 1.优先考虑动态规划

```python
#多维dp+划分型dp
min=lambda x,y:x if x<y else y
class Solution:
    def minTravelTime(self, l: int, n: int, k: int, position: List[int], time: List[int]) -> int:
        @cache
        #i代表下标,k代表剩余次数,pre代表上一段时间,cur代表当前段时间
        #为什么要记录pre,因为如果合并,那么当前段的时间要继承上一段的
        #注意是恰好k次,因此终点k必须=0
        def f(i,k,pre,cur):
            if i==n-1:
                return 0 if k==0 else inf
            #不合并,那么当前段就用cur,下一段的pre更新成cur,下一段的cur就是正常的time[i+1]
            res=f(i+1,k,cur,time[i+1])+cur*(position[i+1]-position[i])
            #合并,当前段就用pre,下一段的pre还是pre,下一段的cur变成当前的cur+time[i+1],即时间合并
            if i>0 and k>0:
                res=min(res,f(i+1,k-1,pre,cur+time[i+1])+pre*(position[i+1]-position[i]))
            return res
        return f(0,k,inf,time[0])

```

# 23.回文

**回文串中至多只有一种字符出现奇数次,其他字符一定出现偶数次,因此可以用状压考虑**
