# 1.python跑汇编

此题为力扣[1283. 使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/)

```python
# Author: hqztrue
# https://github.com/hqztrue/LeetCodeSolutions
from ctypes import *
import mmap

buf=mmap.mmap(-1,mmap.PAGESIZE,prot=mmap.PROT_READ|mmap.PROT_WRITE|mmap.PROT_EXEC)
ftype=CFUNCTYPE(c_int,POINTER(c_int),c_int,c_int)
fpointer=c_void_p.from_buffer(buf)
f=ftype(addressof(fpointer))
buf.write(
    b'\x89\xd3'  # mov ebx,edx
    b'\xb9\x00\x00\x00\x00'  # mov ecx,0
    b'\x48\x8d\x34\xb7'  # lea rsi,[rsi*4+rdi]
    # begin:
    b'\x8b\x07'  # mov eax,DWORD PTR [rdi]
    b'\xba\x00\x00\x00\x00'  # mov edx,0
    b'\xf7\xfb'  # idiv ebx
    b'\x01\xc1'  # add ecx,eax
    b'\x48\x8d\x7f\x04'  # lea rdi,0x4[rdi]
    b'\x48\x39\xf7'  # cmp rdi,rsi
    b'\x74\x02'  # jz end
    b'\xeb\xea'  # jmp begin
    # end:
    b'\x89\xc8'  # mov eax,ecx
    b'\xc3'  # ret
)

class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        l, r = ceil(sum(nums) / threshold), ceil(max(nums) / floor(threshold / n))
        #nums = [x-1 for x in nums]
        a=(c_int*n)()
        for i in range(n): a[i]=nums[i]-1
        while l < r:
            mid = (l + r) >> 1
            #cur = sum(n // mid for n in nums) + n
            cur = f(a,n,mid) + n
            if cur > threshold:
                l = mid + 1
            else:
                r = mid
        return l
```



```python
# Author: hqztrue
# https://github.com/hqztrue/LeetCodeSolutions
from ctypes import *
import mmap

#https://defuse.ca/online-x86-assembler.htm#disassembly2
def translate(s):
    res=b''
    for l in s.split('\n'):
        if (not ':' in l) or (not '   ' in l): continue
        l=l[l.find(':')+1:l.find('   ')].strip()
        for b in l.split(' '):
            res+=int(b,16).to_bytes(1,byteorder='little')
    return res

def compile_asm(s,ftype):
    global buf
    buf=mmap.mmap(-1,mmap.PAGESIZE,prot=mmap.PROT_READ|mmap.PROT_WRITE|mmap.PROT_EXEC)
    fpointer=c_void_p.from_buffer(buf)
    buf.write(translate(s))
    return ftype(addressof(fpointer))

'''
int sum(int *a,int n,int d){
    int s=0;
    for (int i=0;i<n;++i)s+=a[i]/d;
    return s;
}
'''
asm_sum_div=compile_asm('''
0:  89 d3                   mov    ebx,edx
2:  b9 00 00 00 00          mov    ecx,0x0
7:  48 8d 34 b7             lea    rsi,[rdi+rsi*4]
000000000000000b <begin>:
b:  8b 07                   mov    eax,DWORD PTR [rdi]
d:  48 83 c7 04             add    rdi,0x4
11: 99                      cdq
12: f7 fb                   idiv   ebx
14: 01 c1                   add    ecx,eax
16: 48 39 f7                cmp    rdi,rsi
19: 75 f0                   jne    b <begin>
1b: 89 c8                   mov    eax,ecx
1d: c3                      ret
''',CFUNCTYPE(c_int,POINTER(c_int),c_int,c_int))

class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        l, r = ceil(sum(nums) / threshold), ceil(max(nums) / floor(threshold / n))
        #nums = [x-1 for x in nums]
        a=(c_int*n)()
        for i in range(n): a[i]=nums[i]-1
        while l < r:
            mid = (l + r) >> 1
            #cur = sum(n // mid for n in nums) + n
            cur = asm_sum_div(a,n,mid) + n
            if cur > threshold:
                l = mid + 1
            else:
                r = mid
        return l
```

# 2.python存在被卡哈希的可能

为了避免这点,需要在哈希前转化成字符串或tuple.

如,代替使用d[5]=8

使用d[str(5)]=8或d[(5,)]=8
