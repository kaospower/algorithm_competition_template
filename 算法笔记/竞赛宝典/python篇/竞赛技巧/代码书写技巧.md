[TOC]

**本专题解决的是,在已知思路的情况下,针对一些棘手的情况,如何用代码优雅的实现**

# 1.遍历

**遍历是算法的入门课,如何高效地遍历,是一门进阶课,掌握高效遍历的技巧,是成为算法大师的第一步**

## 1.直接遍历

### 1.循环选择

**遍历时恰当地选择用for还是while是十分重要的**

```python
#1656(https://leetcode.cn/problems/design-an-ordered-stream/description/)
```

### 2.从右到左

```python
#513(https://leetcode.cn/problems/find-bottom-left-tree-value/description/)
```

### 3.二叉树的反中序遍历

```python
#538(https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)
```

### 4.遍历时迭代求最大值

```python
#1043(https://leetcode.cn/problems/partition-array-for-maximum-sum/description/)
```

### 5.延迟修改

当我们求i位置最大值需要依赖i-1位置甚至i-2位置的值时,可以用延迟修改的写法,类似一维dp空间压缩版本的迭代过程

```python
#2874(https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/)
```

```python
#930(https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```

```python
#523(https://leetcode.cn/problems/continuous-subarray-sum/)
```

```python
#3026(https://leetcode.cn/problems/maximum-good-subarray-sum/)
```



## 2.分组遍历

### 1.通过条件分组

```python
#2144(https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/)
```

```python
#605(https://leetcode.cn/problems/can-place-flowers/)
```

### 2.通过带步长切片分组

**当切片碰上遍历,会碰出不一样的火花**

```python
#561(https://leetcode.cn/problems/array-partition/)
```

```python
#2578(https://leetcode.cn/problems/split-with-minimum-sum/)
```

```python
#2895(https://leetcode.cn/problems/minimum-processing-time/)
```

### 3.通过双指针分组

```python
#881(https://leetcode.cn/problems/boats-to-save-people/)
```

```python
#1417(https://leetcode.cn/problems/reformat-the-string/)
```

### 4.通过封装函数分组

**函数式编程,是一种重要的思想**

```python
#2934(https://leetcode.cn/problems/minimum-operations-to-maximize-last-elements-in-arrays/description/)
```

### 5.通过分组循环分组

**分组循环,简单题模拟题大杀器**

```python
#2982(https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/description/)
```

```python
#2038(https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/)
```

```python
#3499(https://leetcode.cn/problems/maximize-active-section-with-trade-i/)
```

### 6.通过正负号分组

**正负号分组,解决01比特串问题利器**

```python
#525(https://leetcode.cn/problems/contiguous-array/description/)
```

```python
#1221(https://leetcode.cn/problems/split-a-string-in-balanced-strings/)
```

```python
#2488(https://leetcode.cn/problems/count-subarrays-with-median-k/)
```

### 7.通过计数变量分组

```python
#2027(https://leetcode.cn/problems/minimum-moves-to-convert-string/)
```

### 8.通过groupby分组

**groupby可以将数组中连续且值一样的子数组提取出来,对于处理同值连续子数组问题很有用**

```python
#3499(https://leetcode.cn/problems/maximize-active-section-with-trade-i/)
```

```python
#2419(https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/)
```

# 2.实现层级技巧

**对于同一个子问题,有些实现方式效率极高,值得学习**

## 1.计算差集大小

**计算两个数组查集**

```python
ans=0
for x in d.values():
    diff=defaultdict(int)
    for i in x:
        diff[target[i]]+=1
        diff[source[i]]-=1
    ans+=sum(v for v in diff.values() if v>0)
```

```python
#示例题:1722(https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/)
```

**计算两个哈希表查集**

```python
d=defaultdict(int) #每轮预处理清空哈希表
for j in range(m):
    cur=s[i+j*w:i+(j+1)*w]
    d[cur]+=1
#判断两个哈希表是否相等的常用技巧,直接比较的话复杂度过高
#这种做差的方法可以极大降低复杂度
#对于words中的每个单词,一律在d中进行次数-1,对于不存在于d中的word,会产生负数
#只有频数是0才删除key,负数的相当于赊账
for word in words: 
    d[word]-=1
    if d[word]==0:
        del d[word]
```

```python
#示例题:30(https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)
```

## 2.SortedList二分

**对SortedList二分时,应使用其内置的bisect_left,不要用外部bisect_left**

```python
#2426(https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/)
#平衡树
```

## 3.逻辑表达式短路

**对于二叉树类型的变量做逻辑运算,返回的是二叉树类型而不是布尔类型,遵循短路法则**

```python
#1379(https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/)
```

## 4.格式化字符串

```python
#606(https://leetcode.cn/problems/construct-string-from-binary-tree/)
```

## 5.max减少讨论

当返回值可能出现-inf或inf时,可以将其和0取max或min减少讨论

## 6.三元表达式归并

对于形如以下的三元表达式:

y>x=>1

y=x=>0

y<x=>-1

可以用(y>x)-(x<y)统一描述

## 7.字符串构造

对于字符串问题,可以将两个字符串连接,然后就可以用z函数等方法解决了

## 8.python字符串比较性能

python字符串比较底层用c语言高效实现,效率极高,能让O(n^2)级别的算法跑成类似O(n)级别的速度

## 9.二进制枚举

在解决情况是所有子集(2^n种情况)模型回溯的问题时,可以使用二进制枚举

在解决不是所有子集(即组合,只含有一部分子集)的问题时,使用递归更佳

## 10.反向建图

**对于DAG问题,有时候反向建图,可以大大减小题目难度**

```python
#3387(https://leetcode.cn/problems/maximize-amount-after-two-days-of-conversions/)
#原题可以抽象成两个图,第一天可以从start出发,到达a,b,c,d...等点,到达每个点时有一个值
#第二天反向思考,依然从start出发,到达这些点有相应的值,令t=第一天到达点x的值除以第二天到达点x的值,所有t的最大值即为答案
```

## 11.利用哈希表减少代码量

**某些题目直观写法可能有大量重复代码,如果用哈希表建立映射,可以大大减少代码量**

```python
#935(https://leetcode.cn/problems/knight-dialer/)
```

## 12.镜像翻转

**当处理逻辑类似的代码时,有时候可以用数组反转,同时左右端点l,r=-r,-l的方法,避免重写一遍代码**

## 13.排序后tuple

**对于顺序无关的key,可以在排序后将其转成tuple,从而保证键值相同**

````python
#1128(https://leetcode.cn/problems/number-of-equivalent-domino-pairs/description/)
#枚举右,维护左,排序后tuple处理键值
````

## 14.判断区间重叠

判断两个区间[a,b] [c,d]是否重叠
d>a and c>b

## 16.同步枚举

**常用于双序列问题**

```python
#87(https://leetcode.cn/problems/scramble-string/)
```

## 17.判断完全平方数

1.sqrt(x)%1==0,当x较大时可能出现精度问题

2.t=isqrt(x),判断t*t是否等于x

## 18.最大值与最小值之差

一个序列最大值最小值之差可以转化为:排序后相邻项差值求和

即当a1<a2<a3<a4时,a4-a1=a4-a3+a3-a2+a2-a1

## 19.二叉树遍历顺序

遍历顺序的不同可以极大决定解决题目的难易度

一种常见的遍历方式是,先遍历右孩子,然后根,然后左孩子,即反中序遍历,这种一般应用于dfs

在dfs层序遍历中,如果想得到从右往左的顺序,也可以采用先遍历右孩子,然后左孩子的操作

## 20.按照自定义函数排序

**在调用排序API时,可以按照自己定义的规则进行排序**

```python
#1387(https://leetcode.cn/problems/sort-integers-by-the-power-value/)
```

## 21.集合的键值

当(a,b)和(b,a)可以看成一个key时,将(a,b)排序当成key即可

## 22.分段

```python
#817(https://leetcode.cn/problems/linked-list-components/)
```

## 23.三元逻辑写法

```python
return 'Even' if even>odd else 'Odd' if even<odd else 'Tie'
```

## 24.多重赋值

```python
#2807(https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/)
```

## 25.将数组中的值绑定原始下标后排序

```python
arr=sorted(zip(arr,range(n))) #n为arr长度
```

## 26.合并多种情况

**有些时候,一行精妙的代码可以合并多种情况**

```python
#1818(https://leetcode.cn/problems/minimum-absolute-sum-difference/)
```

```python
#2244(https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/)
```

```python
#3154(https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/)
```

```python
#3366(https://leetcode.cn/problems/minimum-array-sum/description/)
```

```python
#3402(https://leetcode.cn/problems/minimum-operations-to-make-columns-strictly-increasing/)
```

```python
#1422(https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)
```

```python
#3371(https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/)
```

```python
#3361(https://leetcode.cn/problems/shift-distance-between-two-strings/description/)
```

```python
#1523(https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/)
```

```python
#1003(https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/)
```

```python
#735(https://leetcode.cn/problems/asteroid-collision/)
```

```python
#2462(https://leetcode.cn/problems/total-cost-to-hire-k-workers/)
```

```python
#1372(https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)
```

```python
#2423(https://leetcode.cn/problems/remove-letter-to-equalize-frequency/)
```

## 27.枚举回文数

枚举回文数时,我们只需要枚举一半,然后将其反转再拼到后面即可

```python
#866(https://leetcode.cn/problems/prime-palindrome/description/)
```

## 28.代码逻辑顺序

优秀的逻辑顺序可以减少冗余代码

```python
#2522(https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/)
```

```python
#2696(https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/description/)
```

```python
#1021(https://leetcode.cn/problems/remove-outermost-parentheses/)
```

## 29.数学公式

记录一些题目中推导出的数学公式

```python
#1486(https://leetcode.cn/problems/xor-operation-in-an-array/)
```

## 29.dp求子数组最值

```python
@cache
def f(i,j):
    if i==j:
        return nums[i]
    return max(f(i+1,j),f(i,j-1),g[i][j])
return [f(l,r) for l,r in queries]
```

## 30.字符串掩码

当字符串涵盖的字符种类较少时,我们可以用掩码表示字符串所含字符种类

```python
#2506(https://leetcode.cn/problems/count-pairs-of-similar-strings/)
```

```python
#1930(https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/)
```

```python
#1177(https://leetcode.cn/problems/can-make-palindrome-from-substring/)
```

## 31.判断两个字符是否是对应的大小写

```python
class Solution:
    def makeGood(self, s: str) -> str:
        st=[]
        for x in s:
            #两个字母是对应的大小写,那么它们的异或值为32
            if st and ord(x)^ord(st[-1])==32:
                st.pop()
            else:
                st.append(x)
        return ''.join(st)   
```

## 32.判断字符是否是整数

```python
#150(https://leetcode.cn/problems/evaluate-reverse-polish-notation/)
```

## 33.if...else精简化

**当逻辑中需要使用多个if...else时,如何精简它们的数量,是我们需要考虑的**

```python
#676(https://leetcode.cn/problems/implement-magic-dictionary/description/)
```

```python
#2331(https://leetcode.cn/problems/evaluate-boolean-binary-tree/description/)
```

## 34.两个串都含有1或者都不含有1

```python
('1' in a)==('1' in b)
```

## 35.更高效的深拷贝

g=deepcopy(grid),效率很低,因此需要使用更高效的拷贝方式

```python
g=list(map(list,grid))
#或者
g=[row[:] for row in grid]
```

# 3.剪枝

**巧妙的剪枝可以提高算法的效率**

## 1.可行性剪枝

删除不符合题意的情况

下面这题必须限制t<=1000,否则超时,此为可行性剪枝

```python
#2019(https://leetcode.cn/problems/the-score-of-students-solving-math-expression/)
```

## 2.排除等效冗余

当几个分支代表相同情况时,只走一个

## 3.最优性剪枝

搜索到一半发现该解法不如当前最优解,立即停止搜索,进行回溯

## 4.顺序剪枝

一般和贪心结合,比如求最大字典序,那我们就可以从最大字母开始枚举,避免搜索到最后节点才出现最优解

## 5.记忆化

发现重复状态直接返回

```python
#1292(https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/)
```

```python
#3459(https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/)
```

# 4.黑客代码

## 1.使任意AC代码的运行时间显示为0ms

```python
__import__("atexit").register(lambda: open("display_runtime.txt", "w").write("0"))
```
