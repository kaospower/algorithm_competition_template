三指针题目千变万化

**核心技巧:枚举右端点,思考左端点位置,本质是枚举右,维护左思想的另一种体现**

广义的三指针也包含类似三数之和,以及恰好型滑窗(用双指针求解两次,然后做差)

此题单中涵盖的三指针往往移动情况比较复杂,且可能出现相向或者同向等各种复杂的情况,无法用上面的做差方法解决

注意三指针和双指针使用条件类似,必须在满足单调性的情况下才能使用

**2367 等差三元组的数目**

这道题是三指针的入门题目,虽然用枚举右,维护左的方法也可以做,但是本题渗透的三指针思想是非常重要的

题目是求三个数,且它们成等差数列递增.枚举最右边的数x,那么如果中间的数+diff<x,中间数对应的指针就要右移,

同理如果最左边的数+2diff<x,最左边的数对应的指针也要右移,在结束循环后如果满足差刚好为diff,就更新答案.

写法和不定长滑窗有类似之处.

```python
#2367(https://leetcode.cn/problems/number-of-arithmetic-triplets/description/)
#三指针,可以做到O(n)时间,O(1)空间
#由于数组严格递增,具有单调性,因此可以用三指针求解
#三指针,i,j,k分别表示三元组第一个数,第二个数,第三个数
#如果第二个数+diff<x,j向右移动
#同理如果第一个数+2*diff<x,i向右移动
#注意当j=k时,nums[j]+diff>=x一定成立
#同理当i=k时,nums[i]+diff>=x一定成立
#因此i,j下标一定不会超过,因此一定不会越界
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        i=j=ans=0
        for x in nums:
            while nums[j]+diff<x:
                j+=1
            if nums[j]+diff>x:continue
            while nums[i]+2*diff<x:
                i+=1
            if nums[i]+2*diff==x:ans+=1
        return ans
```

**2563 统计公平数对的数目**

这道题其实和上面的题目类似,将原表达式移项整理,枚举nums[j],发现nums[i]要>=lower-nums[j]同时要<=upper-nums[j]

如果计算出左右边界,那么将两者做差就可以求出当前nums[j]对应的nums[i]范围

首先r指针从右向左移动,直到找到右指针的上界,同时l指针从右向左移动,直到找到左指针的下界

为了避免重复,需要保证i的位置在j的左侧,因此求出的l,r都要和j取min

```python
#2563(https://leetcode.cn/problems/count-the-number-of-fair-pairs/)
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        l=r=len(nums)
        ans=0
        for j,x in enumerate(nums):
            while r and nums[r-1]>upper-x:
                r-=1
            while l and nums[l-1]>=lower-x:
                l-=1
            ans+=min(r,j)-min(l,j)
        return ans
```

**795 区间子数组个数**

这道题核心关注子数组最大值

题目要求最大值要落在[left,right]区间内的子数组数目,这可以转化成>right的数目减去>=left的数目

枚举右端点,考虑左端点的位置

用一个指针i1维护最新的大于right的位置,另一指针i0维护最新的>=left的位置,i0-i1即是答案

注意为了防止i1>i0,当一个位置的数>right时,i1,i0都要移动到这个位置,如果只是>=left,那么就只移动i0
```python
#795(https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/)
class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        ans=0
        i0=i1=-1
        #i1维护上一个大于right的位置,i0维护上一个在[left,right]的元素的位置
        #i0-i1即可计算出当前元素左边满足题意的子数组数目
        #为了防止i1下标超过i0,如果当前元素>right,同时更新i1,i0
        #如果当前元素>=left且<=right,就只更新i0
        for i,x in enumerate(nums):
            if x>right:i1=i
            if x>=left:i0=i
            ans+=i0-i1
        return ans
```

**2444 统计定界子数组的数目**

此题也是三指针的一道经典题目,和上面题目思想有一定类似

此题要求子数组中的最小值,最大值均为给定值

因此直观思路还是枚举右端点,考虑左端点位置

容易想到要记录最大值,最小值等于定值的位置min_i,max_i,

但是有一个容易忽略的点,就是如果在这两个位置右侧出现一个在题目给定值域范围外的数怎么办,之前记录的位置似乎就失效了

解决思路很简单,用另一个指针i0维护不合法位置,如果当前位置不合法,i0直接移动到当前位置

更新答案时,用min_i,max_i中的较小值,减去i0,由于i0可能在min_i,max_i右侧,造成负值,因此最后要和0取max

```python
class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        ans=0
        min_i=max_i=i0=-1
        for i,x in enumerate(nums):
            if x==minK:
                min_i=i #最近的minK位置
            if x==maxK:
                max_i=i #最近的maxK位置
            if not minK<=x<=maxK: #注意维护在[minK,maxK]范围外的元素的最近位置
                i0=i
            ans+=max(min(min_i,max_i)-i0,0)
        return ans
```

