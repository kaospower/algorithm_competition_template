**424.替换后的最长重复字符**

此题引入了特殊滑窗的技巧,这种技巧利用窗口内信息的单调性

窗口大小只可能不变或者变大,不会变小,因此只需要记录历史最大值即可

```python
#424(https://leetcode.cn/problems/longest-repeating-character-replacement/)
max=lambda x,y:x if x>y else y
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        l=ans=maxv=0
        cnt=defaultdict(int)
        for r,c in enumerate(s):
            cnt[c]+=1
            maxv=max(maxv,cnt[c])
            if r-l+1-maxv>k:
                cnt[s[l]]-=1
                l+=1
        return r-l+1
```

**2831.找出最长等值数组**

这道题引入了分组滑窗的技巧

```python
#2831(https://leetcode.cn/problems/find-the-longest-equal-subarray/description/)
class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        d=defaultdict(list)
        #预处理,哈希表数组中存放实际下标与在分组中下标的差值
        for i,x in enumerate(nums):
            d[x].append(i-len(d[x]))
        
        ans=0
        #遍历每个分组
        for arr in d.values():
            #分组长度比ans还小,直接跳过,最优性剪枝
            if len(arr)<=ans:
                continue
            l=0
            for r,v in enumerate(arr):
                while v-arr[l]>k:
                    l+=1
                ans=max(ans,r-l+1) #对应的原数组中[l,r]那一段
        return ans
```

思维拓展:**特殊滑窗**

这种方法类似424题,利用维护信息的单调性,类似双指针的题目

```python
class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        cnt=defaultdict(int)
        ans=l=0
        for r,x in enumerate(nums):
            cnt[x]+=1
            #这里用到一个放缩
            #设窗口内出现最多的数字对应的频数是mx,有r-l+1-cnt[nums[l]]>=r-l+1-mx
            #令p=r-l+1-cnt[nums[l]],q=r-l+1-mx
            #我们正常应该维护的是q>k,但是由于q不好求,我们换成维护p>k
            #如果nums[l]不满足q>k,窗口就会右移,直到nums[l]对应的频数是mx为止
            #所以通过这种方式遍历,我们不会错过最优解
            while r-l+1-cnt[nums[l]]>k:
                cnt[nums[l]]-=1
                l+=1
            #同理,在右边界抵达r位置时,cnt[nums[r]]第一时间进行了更新,我们用cnt[nums[r]]更新答案也一定不会错过最优解
            ans=max(ans,cnt[nums[r]])
        return ans
```



**2779.数组的最大美丽值**

排序后将该题转化成寻找最大值和最小值之差<=2k的最长子数组问题,可以用滑动窗口解决

```python
#2779(https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/)
class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        n=len(nums)
        nums.sort()
        l,r=0,1
        maxv=1
        while r<n:
            while nums[r]-nums[l]>2*k:
                l+=1
            if (cur:=r-l+1)>maxv:
                maxv=cur
            r+=1
        return maxv
```

思维拓展:将该题转成求最大重叠区间数,然后用堆处理

```python
class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        arr=sorted([[num-k,num+k] for num in nums],key=lambda x:x[1])
        pq=[]
        maxv=0
        for x in arr:
            while pq and pq[0][1]<x[0]:
                heappop(pq)
            heappush(pq,x)
            if (cur:=len(pq))>maxv:
                maxv=cur
        return maxv
```



**2271.毯子覆盖的最多白色砖块数**

本题是滑动窗口的经典题目,揭示了滑动窗口和区间问题的联系

不定长滑窗+排序+贪心
贪心点在于毯子右端点时刻都要和瓷砖右端点重合(和左端点重合也可以,这里我们一律和右端点重合)

```python
#2271(https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/)
max=lambda x,y:x if x>y else y
class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        tiles.sort()
        ans=d=l=0
        for x,y in tiles:
            d+=y-x+1 #覆盖长度增加当前瓷砖宽度,d为毯子能碰到的所有瓷砖的宽度和
            #毯子时刻都和瓷砖右端点对齐,计算毯子左端点位置,如果最左瓷砖的右边界<右端点,说明最左瓷砖该右移了
            while tiles[l][1]<y-carpetLen+1:
                d-=tiles[l][1]-tiles[l][0]+1
                l+=1
            #计算毯子没覆盖部分,和0取max,防止毯子左边界溢出最左瓷砖的左边界
            w=max(y-carpetLen+1-tiles[l][0],0)
            ans=max(ans,d-w)
        return ans
```

**2106.摘水果**

本题也是滑动窗口的经典题目,揭示了滑动窗口如何处理折返问题

```python
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        left = bisect_left(fruits, [startPos - k])  # 向左最远能到 fruits[left][0]
        ans = s = 0
        for pos, amount in fruits[left:]:
            if pos > startPos + k: break
            s += amount
            while pos * 2 - fruits[left][0] - startPos > k and \
                  pos - fruits[left][0] * 2 + startPos > k:
                s -= fruits[left][1]  # fruits[left][0] 无法到达
                left += 1
            ans = max(ans, s)  # 更新答案最大值
        return ans
```

思维拓展:更简洁的双指针解法

```python
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        ans=i=s=0
        for j,(p,v) in enumerate(fruits):
            s+=v
            while i<=j and p-fruits[i][0]+min(abs(startPos-fruits[i][0]),abs(startPos-fruits[j][0]))>k:
                s-=fruits[i][1]
                i+=1
            ans=max(ans,s)
        return ans
```



**2555.两个线段获得的最多奖品**

本题通过下标差就可以计算出奖品数量,但是计算线段距离与值挂钩,因此可以通过不定长滑窗来实现

**枚举+不定长滑动窗口+维护前缀最大值**
设左边的线段为a,右边的线段为b
设b的左右端点分别为left,right
为了尽量覆盖更多的奖品,right要与有奖品的端点重合,left则是左侧能覆盖的最远的奖品位置
因此枚举b的右端点的位置,计算出其能覆盖的奖品数,再加上线段a能覆盖的奖品数,就是答案
由于线段a和线段b的长度相同,因此可以枚举b的同时,记录其途中经过的所有位置的最大值
用mx[i+1]表示0~i范围线段能覆盖的最大奖品数,其中mx[i+1]=max(mx[i],r-left+1)
mx的更新方式和前缀最大值的更新方式类似,只不过这里是用滑动窗口代替了数字
这样最终答案即为mx[left]+right-left+1,

```python
#2555(https://leetcode.cn/problems/maximize-win-from-two-segments/)
class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        n=len(prizePositions)
        #剪枝,如果两个线段能覆盖全部prizePositions,则直接返回数组长度n
        #这里是2k+1是因为长度为k的线段覆盖点数为k+1,两个线段端点不重合时覆盖的最大点数为2k+2
        #这里因为直接用起点减去终点,得到的是总点数-1,因此左边就是2k+1
        if 2*k+1>=prizePositions[-1]-prizePositions[0]:
            return n
        mx=[0]*(n+1)
        ans=l=0
        for r,x in enumerate(prizePositions):
            #注意这里的l,r均是指prizePositions中的下标位置
            while prizePositions[r]-prizePositions[l]>k:
                l+=1
            ans=max(ans,r-l+1+mx[l])
            mx[r+1]=max(mx[r],r-l+1)
        return ans
```

思维拓展:另一种解法

**枚举中间,思想和上面解法类似,但是做到了O(1)空间**

```python
class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        n=len(prizePositions)
        if 2*k+1>=prizePositions[-1]-prizePositions[0]:
            return n
        ans=mx=l=r=0
        for mid,x in enumerate(prizePositions):
            #更新右边线段的右边界
            while r<n and prizePositions[r]-x<=k:
                r+=1
            #循环结束后,r对应长度大于k的右端点,r-1即为长度<=k的线段的有边界
            #因此右边线段覆盖的奖品数量为r-1-mid+1=r-mid
            ans=max(ans,mx+r-mid)
            #更新左边线段的左边界
            while x-prizePositions[l]>k:
                l+=1
            #更新左边的线段覆盖最大礼品数
            #注意必须先更新ans,后更新mx,这样mid才不会被算两次
            mx=max(mx,mid-l+1)
        return ans 
```

**2009.使数组连续的最少操作数**

本题的滑窗思路还是比较难想到的,有一点反直觉.

从题意容易看出,最终要形成一个值在mn~mx范围的数组,同时mx-mn==n-1

本题的一个误区是去寻找最长连续数组,但是这个思路对于1,2,3,5,6这个样例就很难解决了,因为最长连续数组是1,2,3,长度是3,但是可以将6替换成4,后面的5,4虽然不是连续的,但是1,2,3,5,4整体是连续的.

既然正向构造连续数组很困难,那么反向思考,考虑哪些元素可以留下来.

对原数组排序去重后,后面的数字一定比前面大,具有单调性.

此时维护一个滑动窗口,窗口内最大最小元素之差必须<=n-1.求出最大的窗口大小,就是要留下的最多元素,最后用n减去这个值,就得到最少要替换的元素数量,即答案.

可以注意到排序后,窗口的左右边界分别就是窗口内最小值,最大值,大大简化了实现难度

此题引申出一个重要思想,如果a比较难求,可以考虑求a的补集

同时本题题干中提到了最大最小,可以想到单调队列,单调队列是和滑动窗口绑定在一起的,而本题排序后最大最小值可以直接得到,因此去掉单调队列,只用滑动窗口就可以解决.

```python
#2009(https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n=len(nums)
        diff=n-1
        nums=sorted(set(nums))
        l=ans=0
        for r,x in enumerate(nums):
            while x-nums[l]>diff:
                l+=1
            ans=max(ans,r-l+1)
        return n-ans
```

**1610.可见点点最大数目**

本题是计算几何与滑窗的结合

将坐标转化成弧度制形式的极坐标后,就可以转化成滑窗问题

```python
#1610(https://leetcode.cn/problems/maximum-number-of-visible-points/)
class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
        cnt=0
        arr=[]
        for p in points:
            if p==location:
                cnt+=1
            else:
                arr.append(atan2(p[1]-location[1],p[0]-location[0]))
        arr.sort()
        n=len(arr)
        arr+=[x+2*pi for x in arr] #加上360度
        mx=r=0
        degree=angle*pi/180 #转弧度制
        for i in range(n):
            while r<n*2 and arr[r]<=arr[i]+degree:
                r+=1
            mx=max(mx,r-i)
        return cnt+mx
```

**3410.最长乘积等价子数组**

滑窗+质因数分解
当子数组长度为2时,数组一定满足条件,当子数组长度>2时,必须满足两两互质

```python
#3411(https://leetcode.cn/problems/maximum-subarray-with-equal-products/)
class Solution:
    def maxLength(self, nums: List[int]) -> int:
        s=1
        ans=2
        l=0
        for r,x in enumerate(nums):
            while gcd(s,x)>1:
                s//=nums[l]
                l+=1
            s*=x
            ans=max(ans,r-l+1)
        return ans
```



**3413.收集连续 K 个袋子可以获得的最多硬币数量**

本题就是带权重版本的2271题
由于本题带权重,因此需要正反两次遍历
第一遍从左往右,第二遍从右往左
实际实现时,可以将第一遍的数组反转,然后l,r变成-r,-l,实现代码复用
思路拓展,如果区间有重叠,用哈希表形式的差分数组,就可以处理成不重叠区间(3453题)

```python
#3413(https://leetcode.cn/problems/maximum-coins-from-k-consecutive-bags/)
max=lambda x,y:x if x>y else y
class Solution:
    def maximumCoins(self, coins: List[List[int]], k: int) -> int:
        coins.sort()
        a=[(-y,-x,z) for x,y,z in coins[::-1]]
        res1=self.maximumWhiteTiles(coins,k)
        res2=self.maximumWhiteTiles(a,k)
        return max(res1,res2)

    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        ans=d=l=0
        for x,y,z in tiles:
            d+=(y-x+1)*z #覆盖长度增加当前瓷砖宽度,d为毯子能碰到的所有瓷砖的宽度和
            #毯子时刻都和瓷砖右端点对齐,计算毯子左端点位置,如果最左瓷砖的右边界<右端点,说明最左瓷砖该右移了
            while tiles[l][1]<y-carpetLen+1:
                d-=(tiles[l][1]-tiles[l][0]+1)*tiles[l][2]
                l+=1
            #计算毯子没覆盖部分,和0取max,防止毯子左边界溢出最左瓷砖的左边界
            w=max((y-carpetLen+1-tiles[l][0])*tiles[l][2],0)
            ans=max(ans,d-w)
        return ans
```

