**2069.模拟行走机器人II**

此题经过分析不难发现机器人运动轨迹是环形,但是具体实现时有很多细节

这里采取将运动距离映射到1～2\*(w+h-2)范围

可以注意到,面对这类模拟问题,不要盲目将题目中的信息映射成习惯的写法,这样往往会增加实现难度

比如这题的横纵坐标和通常二维数组的横纵坐标刚好是反的,如果盲目映射成二维数组,下标转化会异常繁琐,增加实现难度.

```python
class Robot:

    def __init__(self, width: int, height: int):
        self.w, self.h, self.s = width, height, 0

    def step(self, num: int) -> None:
        # 为了避免对原点进行讨论,将距离s范围控制在1~tot,而不是0~tot-1
        # 因此在更新距离时,需要-1之后取模,再+1
        # 如果绕了一圈回到原点,原点对应s就是tot,开始位置虽然在原点,但是因为没有经过step函数修改s,因此初始时刻s=0,从而避免特判初始时刻
        # s=1对应原点右边第一个点,s=2对应原点右边第二个点...以此类推
        self.s = (self.s + num - 1) % (2 * (self.w + self.h - 2)) + 1

    # 将走的距离s映射到下标,方向
    # 注意对于每条边[l,r)的点的方向是相同的,l,r分别代表边的左右端点
    def get(self):
        s, w, h = self.s, self.w, self.h
        # 下边,第一段距离为w
        if s < w:
            return s, 0, "East"
        # 右边,前两段距离为w+h-1
        # 从0~s总计s+1距离,减去w即为纵坐标
        if s < w + h - 1:
            return w - 1, (s + 1) - w, "North"
        # 上边,前三段为2*w+h-2
        # 从0~s-1总计s距离,前三段距离和-s,得到0~当前点距离,由于计算下标,还要额外-1
        if s < 2 * w + h - 2:
            return 2 * w + h - 2 - s - 1, h - 1, "West"
        # 左边,四段距离和为2(w+h-2)
        # 前四段距离和-s,就是当前下标的纵坐标
        return 0, 2 * (w + h - 2) - s, "South"

    def getPos(self) -> List[int]:
        x, y, d = self.get()
        return [x, y]

    def getDir(self) -> str:
        return self.get()[2]
```

**2018.判断单词是否能放入填字游戏内**

模拟,将每一行的字符串按照'#'分隔开来,然后考虑word,word[::-1]和分隔开来的字符串能否匹配,列同理

```python
#2018(https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/?envType=problem-list-v2&envId=NYf6Nvxg)
class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        def match(x,y):
            return all(a==' ' or a==b for a,b in zip(x,y))
        for row in chain(board,zip(*board)):
            for s in ''.join(row).split('#'):
                if len(s)==len(word) and (match(s,word) or match(s,word[::-1])):return True
        return False
```

**3433.统计用户被提及情况**

难点在于读题

按照时间戳排序+模拟
从题意可知要按时间顺序排序,当同一时间既有离线时间又有消息时间时,先处理离线事件
因此要对events数组排序,第一维度按时间,时间相同时离线时间排前面
由于OFFLINE第三个字母比MESSAGE第三个字母小,因此排序时可以写成$p[0][2]$
维护s数组表示每个人的最新上线时间
遍历所有事件,分四种情况讨论:
1.如果当前事件是离线事件,将s[i]修改成当前时间+60
2.如果当前事件是在线事件且提及所有用户,即$events[2][0]='A'$,将所有人的次数+1
#实际实现时可以用alls记录执行这个操作的次数,最后遍历一遍答案数组,将每个元素都加上这个次数
3.如果当前事件是在线事件且提及所有在线用户,即$events[2][0]='H'$,将满足s[i]<当前时间t的那些人的次数+1
4.否则,将指定那些id的人的次数+1

```python
#3433(https://leetcode.cn/problems/count-mentions-per-user/)
class Solution:
    def countMentions(self, n: int, events: List[List[str]]) -> List[int]:
        s=[0]*n
        ans=[0]*n
        events.sort(key=lambda p:(int(p[1]),p[0][2]))
        alls=0
        for x,y,z in events:
            t=int(y)
            if x[0]=='O':
                s[int(z)]=t+60
            elif z[0]=='A':
                alls+=1
            elif z[0]=='H':
                for i,x in enumerate(s):
                    if x<=t:
                        ans[i]+=1
            else:
                for x in z.split():
                    ans[int(x[2:])]+=1
        return [x+alls for x in ans]
```

