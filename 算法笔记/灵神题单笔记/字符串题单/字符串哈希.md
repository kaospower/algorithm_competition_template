**2156.查找给定哈希值的子串**

这题虽然不是正经的字符串哈希,但是引入了字符串哈希的概念,对理解字符串哈希非常有帮助

字符串哈希+定长滑窗

本质是一个长度为k的定长滑窗
设字符串为abcde,k=3,当左边界l=0时,哈希值$h1=a+b*p+c*p^2$,当l=1时,哈希值$h2=b+c*p+d*p^2$
可以发现$h1=a+h2*p-d*p^3$,因此维护从右到左的倒序定长滑窗,每次按照这个式子用秦九韶算法更新即可
由于每次都要减去一个数乘上$p^k$,因此可以预先将$p^k$计算出来
对于字母x(a~z),ord(x)&31,可以将其映射到1~26,等价于ord(x)-ord('a')+1
同时计算多项式可以使用秦九韶算法升幂,即$a+b*p+c*p^2=a+p*(b+c*p)$
注意寻找的是第一个子串,因此要一直遍历到最后

```python
#2156(https://leetcode.cn/problems/find-substring-with-given-hash-value/)
class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        h=0
        n=len(s)
        for i in range(n-1,n-k-1,-1):
            h=(h*power+(ord(s[i])&31))%modulo
        ans=n-k if h==hashValue else 0
        pk=pow(power,k,modulo)
        for l in range(n-k-1,-1,-1):
            h=(h*power+(ord(s[l])&31)-pk*(ord(s[l+k])&31))%modulo
            if h==hashValue:
                ans=l
        return s[ans:ans+k]
```

# 3213.最小代价构造字符串

单模哈希

```c++
//3213(https://leetcode.cn/problems/construct-string-with-minimum-cost/)
class Solution {
public:
    int minimumCost(string target, vector<string>& words, vector<int>& costs) {
        int n = target.length();

        // 多项式字符串哈希（方便计算子串哈希值）
        // 哈希函数 hash(s) = s[0] * base^(n-1) + s[1] * base^(n-2) + ... + s[n-2] * base + s[n-1]
        const int MOD = 1'070'777'777;
        mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
        const int BASE = uniform_int_distribution<>(8e8, 9e8)(rng); // 随机 base，防止 hack
        vector<int> pow_base(n + 1); // pow_base[i] = base^i
        vector<int> pre_hash(n + 1); // 前缀哈希值 pre_hash[i] = hash(s[:i])
        pow_base[0] = 1;
        for (int i = 0; i < n; i++) {
            pow_base[i + 1] = (long long) pow_base[i] * BASE % MOD;
            pre_hash[i + 1] = ((long long) pre_hash[i] * BASE + target[i]) % MOD; // 秦九韶算法计算多项式哈希
        }

        // 计算 target[l] 到 target[r-1] 的哈希值
        auto sub_hash = [&](int l, int r) {
            return ((pre_hash[r] - (long long) pre_hash[l] * pow_base[r - l]) % MOD + MOD) % MOD;
        };

        map<int, unordered_map<int, int>> min_cost; // 长度 -> 哈希值 -> 最小成本
        for (int i = 0; i < words.size(); i++) {
            long long h = 0;
            for (char b : words[i]) {
                h = (h * BASE + b) % MOD;
            }
            int m = words[i].length();
            if (!min_cost[m].contains(h)) {
                min_cost[m][h] = costs[i];
            } else {
                min_cost[m][h] = min(min_cost[m][h], costs[i]);
            }
        }

        vector<int> f(n + 1, INT_MAX / 2);
        f[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (auto& [len, mc] : min_cost) {
                if (len > i) {
                    break;
                }
                auto it = mc.find(sub_hash(i - len, i));
                if (it != mc.end()) {
                    f[i] = min(f[i], f[i - len] + it->second);
                }
            }
        }
        return f[n] == INT_MAX / 2 ? -1 : f[n];
    }
};
```

