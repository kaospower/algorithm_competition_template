**2014.重复k次的最长子序列**

核心突破点在于条件n<k*8

注意题目中的条件n<k*8,因此n/k<8,即每个循环节最长为7,即答案字符串最长为7

同时由于有k个循环节,所以循环节中字母至少出现k次,因此只需考虑出现次数>=k的字母

首先计算出每个字母的频数v,对于字母c,将v//k个c加入数组a,注意数组a的长度不会超过7

对a按照字典序倒序排序,这样后面通过回溯生成的字符串就是按照字典序从大到小

因为如果超过7,说明有长度超过7的答案,这就和条件相悖了

长度范围为1~7,倒序枚举长度,即从a中选7,6,...,1个字母组成排列作为循环节,然后将循环节重复k次得到字符串t,

判断t是否是s的子序列

**写法1:双指针判断子序列**

```python
#2014(https://leetcode.cn/problems/longest-subsequence-repeated-k-times/description/)
class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        #判断子序列
        def f(s,t):
            t = iter(t)
            return all(c in t for c in s)
        cnt=Counter(s)
        #将所有出现次数大于k的字母筛出来,用其出现次数除以k,得到这个字母在每组中最多出现j次
        #在数组中加入j个这个字母,注意a的长度至多为7
        a=[c for c,v in cnt.items() for _ in range(v// k)]
        a.sort(reverse=True)  # 排序后,下面会按照字典序从大到小枚举排列
        for i in range(len(a),0,-1):  # 长的优先
            for perm in permutations(a,i):  # 枚举 a 的长为 i 的排列
                seq =''.join(perm)
                if f(seq * k,s):  # seq*k 是 s 的子序列
                    return seq
        return ''
```

**写法2:子序列自动机优化**

```python
class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        s = [ord(c) - ord('a') for c in s]  # 转成 0 到 25，这样下面无需频繁调用 ord

        # 392. 判断子序列（进阶做法）
        n = len(s)
        nxt = [[n] * 26 for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            nxt[i][:] = nxt[i + 1]
            nxt[i][s[i]] = i

        def isSubsequence(seq: Tuple[int, ...]) -> bool:
            i = -1
            for _ in range(k):
                for c in seq:
                    i = nxt[i + 1][c]
                    if i == n:  # c 不在 s 中，说明 seq*k 不是 s 的子序列
                        return False
            return True  # seq*k 是 s 的子序列

        cnt = Counter(s)
        a = [ch for ch, freq in cnt.items() for _ in range(freq // k)]
        a.sort(reverse=True)  # 排序后，下面会按照字典序从大到小枚举排列

        for i in range(len(a), 0, -1):  # 长的优先
            for seq in permutations(a, i):  # 枚举 a 的长为 i 的排列
                if isSubsequence(seq):  # seq*k 是 s 的子序列
                    return ''.join(ascii_lowercase[c] for c in seq)
        return ''
```

