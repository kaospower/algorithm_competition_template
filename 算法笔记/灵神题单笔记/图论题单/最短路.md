# 1.单源最短路:Dijkstra

**1514.概率最大的路径**

本题是堆优化Dijkstra变形

众所周知Dijkstra可以求正权图最短路,而本题是求最长路
对于正权图,如果存在正环,最长路无解,因为可以绕着正环无限走下去
如果不存在正环,则可以将边权取反变成负数
用spfa/Bellman-Ford/floyd等可以求负权最短路的算法求最短路,最后再次取反即可得到最长路
但是本题权重的累积不是加法而是乘法,不能随便取反



回顾原始Dijkstra求最短路,它利用了加法不会变小的性质,优先松弛短的边,从而得到最短路
而本题边权全是介于0~1之间的数,且为乘法,一个数乘上<=1的数不可能变大,只会不变或变小
因此本题的乘法不会变大,贪心地优先松弛大的边,就可以得到最长路
由于是维护最大边,维护一个大根堆,使用Dijkstra即可

```python
#1514(https://leetcode.cn/problems/path-with-maximum-probability/)
class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:
        def Dijkstra(start):
            g=[[] for _ in range(n)]
            for (x,y),w in zip(edges,succProb):
                g[x].append((y,w))
                g[y].append((x,w))
            dis=[0]*n
            dis[start]=1
            pq=[(-1,start)]
            #python大根堆需要将数值取反
            while pq:
                dis_u,u=heappop(pq)
                if u==end_node:
                    return -dis_u
                if -dis_u<dis[u]:
                    continue
                for v,w in g[u]:
                    dis_v=-dis_u*w
                    if dis_v>dis[v]:
                        dis[v]=dis_v
                        heappush(pq,(-dis_v,v))
            return 0
        return Dijkstra(start_node)
                
```

**1631.最小体力消耗路径**

网格图Dijkstra
注意本题四个方向都可以走,不满足无后效性,不能用dp,由于带权,且是求最短路,因此用Dijkstra

```python
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        def Dijkstra(grid, sx, sy):
            move = [(1, 0), (-1, 0), (0, -1), (0, 1)]
            n, m = len(grid), len(grid[0])
            dis = [[inf] * m for _ in range(n)]
            dis[sx][sy] = 0
            pq = [(0, sx, sy)]
            while pq:
                dis_u, x, y = heappop(pq)
                if x==n-1 and y==m-1:
                    return dis_u
                if dis_u > dis[x][y]:
                    continue
                for dx, dy in move:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < n and 0 <= ny < m:
                        dis_v = max(dis_u,abs(grid[nx][ny]-grid[x][y]))
                        if dis_v < dis[nx][ny]:
                            dis[nx][ny] = dis_v
                            heappush(pq, (dis_v, nx, ny))
        return Dijkstra(heights,0,0)
```

**1786.从第一个节点出发到最后一个节点的受限路径数**

容易想到,用Dijkstra求出终点到其他点的最短路作为点权,再用dp求从1到n降序点权的路径数即可

```python
#1786(https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/)
mod=1_000_000_007
class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        g=[[] for _ in range(n+1)]
        for x,y,w in edges:
            g[x].append((y,w))
            g[y].append((x,w))
        def Dijkstra(edges,n,start):
            dis=[inf]*n
            dis[n-1]=0
            pq=[(0,n-1)]
            while pq:
                dis_u,u=heappop(pq)
                if dis_u>dis[u]:
                    continue
                for v,w in g[u]:
                    dis_v=dis_u+w
                    if dis_v<dis[v]:
                        dis[v]=dis_v
                        heappush(pq,(dis_v,v))
            return dis
        dis=Dijkstra(edges,n+1,1)
        @cache
        def f(u):
            if u==n:
                return 1
            ans=0
            for v,w in g[u]:
                if dis[v]<dis[u]:
                    ans=(ans+f(v))%mod
            return ans
        return f(1)

```

另一种写法是比较巧妙的,在计算最短路的同时结算从终点到每个点的路径数

这种写法容易引起的一点疑惑就是,某一点还没达到该点的最短路时,就去更新数量,是否会产生错误.

这种疑虑是多余的.设终点为n,当前点为u,更新cnt的点为v(即u的邻居),u到v路径为t,对于当前路径,dv=du+t

dv>du成立(di表示从n到i的最短路),当前的路径为n-u-v.设未来有一个到u更短的路径dj,那么du会更新为dj,dv会随之更新为dj+t,此时dv>du依然成立,所以原来的n-u-v路径依然成立.

可以发现提前计算数量是没有关系的.因为dv=du+t,当du变化时,dv也会随之变化,始终保持dv>du,原来的路径也始终都是成立的.

```python
mod=1_000_000_007
class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        def Dijkstra(edges,n,start):
            g=[[] for _ in range(n)]
            for x,y,w in edges:
                g[x].append((y,w))
                g[y].append((x,w))
            dis=[inf]*n
            dis[n-1]=0
            cnt=[0]*n
            cnt[n-1]=1
            pq=[(0,n-1)]
            while pq:
                dis_u,u=heappop(pq)
                if dis_u>dis[u]:
                    continue
                for v,w in g[u]:
                    dis_v=dis_u+w
                    if dis_v<dis[v]:
                        dis[v]=dis_v
                        heappush(pq,(dis_v,v))
                    if dis[v]>dis[u]:
                        cnt[v]=(cnt[v]+cnt[u])%mod
            return cnt[1]
        return Dijkstra(edges,n+1,1)
```

**3123.最短路径中的边**

Dijksta+倒序dfs

注意如果dis[v]+w=dis[u],那么说明w在从0出发的某条最短路上(不一定到达终点)

经典结论,设$d_i表示从0到i的最短路,b_i表示从n-1到i的最短路$
对于边(u,v),设其边权为w,若$d_u+w+b_v=d_{n-1},则说明(u,v)在0到n-1的最短路上$

实际实现时可以通过两次Dijkstra,也可以通过Dijkstra+dfs/bfs实现
在dfs的过程中,只有dis[v]+w=dis[u]时,才访问v,这样就能保证走的一定是最短路
同时用vis数组标记访问过的点,这样dfs的过程中,会将所有边都访问一遍,

如果当前边满足条件,就更新答案,但是所有点只访问一次,这样就保证了只遍历一遍全图,而不是回溯

```python
#3123(https://leetcode.cn/problems/find-edges-in-shortest-paths/)
class Solution:
    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:
        g=[[] for _ in range(n)]
        for i,(x,y,w) in enumerate(edges):
            g[x].append((y,w,i))
            g[y].append((x,w,i))
        dis=[inf]*n
        dis[0]=0
        pq=[(0,0)]
        while pq:
            dis_u,u=heappop(pq)
            if dis_u>dis[u]:
                continue
            for v,w,i in g[u]:
                dis_v=dis_u+w
                if dis_v<dis[v]:
                    dis[v]=dis_v
                    heappush(pq,(dis_v,v))
        min_d=dis[-1]
        m=len(edges)
        ans=[False]*m
        if min_d==inf:
            return ans
        vis=[False]*n
        def f(u):
            vis[u]=True
            for v,w,i in g[u]:
                if dis[v]+w!=dis[u]:
                    continue
                ans[i]=True
                if not vis[v]:
                    f(v)
        f(n-1)
        return ans
```

