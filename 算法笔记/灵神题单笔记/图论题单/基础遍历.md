# 1.dfs基础

# 2.bfs基础

**2039.网络空闲的时刻**

本质是bfs求最短路,同时需要逆向思考

由题目要求可知需要求出其他点到0号点的最短路
逆向思考,转化成求0号点到其他点的最短路
这样就可以一次bfs同时求出0号点到其他所有点的最短路
这里采用用类似Dijkstra的方法进行实现,即用dis数组代替vis数组
dis数组记录起点到其他点的最短路,只有将访问的点<其历史最短路时,才访问该点,同时更新最短路和答案
答案的更新方式本质是数学公式
即计算出子服务器最后一次发送信息的时间,加上来回距离得到子服务器最后一个信息到达根服务器的时间t
对所有t取最大值,最后再+1,即为答案

```python
#2039(https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/)
max=lambda x,y:x if x>y else y
class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        #无权最短路
        def bfs(start,edges,n):
            g=[[] for _ in range(n)]
            for x,y in edges:
                g[x].append(y)
                g[y].append(x)
            dis=[inf]*n
            dis[start]=0
            q=deque([start])
            level=1
            ans=0
            while q:
                size=len(q)
                for _ in range(size):
                    u=q.popleft()
                    for v in g[u]:
                        if level<dis[v]:
                            q.append(v)
                            dis[v]=level
                            ans=max(ans,(2*level-1)//patience[v]*patience[v]+2*level+1)
                level+=1
            return ans
        return bfs(0,edges,len(patience))
```

**815.公交路线**

非常有意思的题

特殊bfs/本题也用仙人掌,圆方树解决
本题和一般bfs的区别是,一般bfs每次访问点的邻居,这些邻居还是点
而本题这些邻居是一个集合,将本题中的集合当成点,就和正常题目一样了

```python
#815(https://leetcode.cn/problems/bus-routes/)
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        #将站映射到公交,然后再将公交映射到站
        #bfs的每层将同一个路线中没访问过的站全部加入队列
        g=defaultdict(list)
        for i,route in enumerate(routes):
            for x in route:
                g[x].append(i)
        #起点或者终点不在公交路线中,如果起点和终点不等,返回-1,否则返回0
        if source not in g or target not in g:
            return -1 if source!=target else 0

        dis={source:0}
        q=deque([source])
        while q:
            u=q.popleft()
            for i in g[u]:
                if routes[i]:
                    for v in routes[i]:
                        if v not in dis:
                            dis[v]=dis[u]+1
                            q.append(v)
                    routes[i]=None
        return dis.get(target,-1)
```

