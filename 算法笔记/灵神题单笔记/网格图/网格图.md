# 1.网格图DFS

# 2.网格图BFS

# 3.网格图01BFS

# 4.网格图Dijkstra

# 5.综合应用

**2814.避免淹死并到达目的地的最短时间**

双集合多源bfs模版题,简称双龙出海

和常规多源bfs相比,本题相当于有两个多源bfs,需要对它们进行区分
也可以先预处理出每块地被水淹没的时间,再计算人扩散到终点的时间

```python
#2814(https://leetcode.cn/problems/minimum-time-takes-to-reach-destination-without-drowning/)
class Solution:
    def minimumSeconds(self, grid: List[List[str]]) -> int:
        move=[(1,0),(-1,0),(0,1),(0,-1)]
        n,m=len(grid),len(grid[0])

        #集合a,标记洪水走过的单元格
        a=set()
        #集合b,空地或者S,洪水和人可以扩展的区域
        b=set()
        #集合c,标记人走过的所有单元格
        c=set()
        #p,洪水最外围单元格
        p=deque()
        #q,人最外围单元格
        q=deque()
        
        #初始化a,b,c,p,q
        for i,row in enumerate(grid):
            for j,x in enumerate(row):
                if x=='*':
                    a.add((i,j))
                    p.append((i,j))
                if x=='.':
                    b.add((i,j))
                if x=='S':
                    b.add((i,j))
                    c.add((i,j))
                    q.append((i,j))
            
        ans=0
        #当人无路可走时,结束循环
        while q:
            #洪水扩散
            size1=len(p)
            for _ in range(size1):
                x,y=p.popleft()
                for dx,dy in move:
                    nx,ny=x+dx,y+dy
                    if 0<=nx<n and 0<=ny<m and (nx,ny) not in a and (nx,ny) in b:
                        a.add((nx,ny))
                        b.remove((nx,ny))
                        p.append((nx,ny))
            #人扩散
            ans+=1
            size2=len(q)
            for _ in range(size2):
                x,y=q.popleft()
                for dx,dy in move:
                    nx,ny=x+dx,y+dy
                    if 0<=nx<n and 0<=ny<m and (nx,ny) not in c:
                        if grid[nx][ny]=='D':
                            return ans
                        if (nx,ny) in b:
                            c.add((nx,ny))
                            q.append((nx,ny))
        return -1
```

**2258.逃离火灾**

解法1:二分+网格图多源bfs

这种写法用到了双集合多源bfs扩散的技巧,简称双龙出海

```python
#2258(https://leetcode.cn/problems/escape-the-spreading-fire/)
class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        n,m=len(grid),len(grid[0])
        #二分check函数,判断等待k分钟是否可行
        def check(k):
            #等价于深拷贝,但是速度更快,也可以写成g=[row[:] for row in grid]
            g=list(map(list,grid))
            #等k分钟意味着火扩散k圈,用bfs模拟即可
            q=deque()
            for i,row in enumerate(g):
                for j,x in enumerate(row):
                    if x==1:
                        q.append((i,j))
            for _ in range(k):
                size=len(q)
                if size==0:
                    break
                for _ in range(size):
                    x,y=q.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m and g[nx][ny]==0:
                            g[nx][ny]=1
                            q.append((nx,ny))
            #每次火先走一圈,然后人再走,这样保证下一步走的地方不会被烧到
            #同时走过的位置标记成3,防止重复访问
            #注意右下角的位置需要特殊处理,因为人到达右下角就不怕火烧了
            #因此需要记录火到达右下角的时间,人到达右下角时间<=火到达右下角的时间时,说明这个k可行
            p=deque([(0,0)])
            t=0
            flag=inf
            while p:
                size=len(q)
                #火先走,这些位置人不能走,否则下一分钟会被烧到,0,3都是草地
                for _ in range(size):
                    x,y=q.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m and (g[nx][ny]==0 or g[nx][ny]==3):
                            if nx==n-1 and ny==m-1:
                                flag=t
                            g[nx][ny]=1
                            q.append((nx,ny))
                #人后走
                size=len(p)
                for _ in range(size):
                    x,y=p.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m:
                            if nx==n-1 and ny==m-1:
                                return flag<t
                            if g[nx][ny]==0:
                                g[nx][ny]=3
                                p.append((nx,ny))
                t+=1
            return True
        return bisect_left(range(1_000_000_001),True,key=check)-1



```



