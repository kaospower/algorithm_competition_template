# 1.枚举右,维护左

## 1.基础

**核心技巧:枚举右边的数,同时利用哈希表维护左边访问过的数**

**小技巧:|a-b|最大值的维护,延时修改,最值下标的维护**



枚举的基本题目以两数之和为代表,当遇到类似$a_i+a_j=t$的表达式时,可以将式子移项变形,整理成$a_j=t-a_i$的形式,每遍历到一个位置,将当前位置的数加入哈希表,这样在枚举$a_j$时,就可以用到过往位置的信息.注意要先更新答案,后更新哈希表信息,这样在访问哈希表时,就不会调用当前位置的信息,只会调用过往位置的信息.这稍微渗透了部分延时修改的思想.

这部分的题目大多是两数之和换皮,有部分题目在将题目中的表达式移项整理后,也可以变成类似两数之和的形式,如$a_i-a_j=i-j$,移项整理后可以变成$a_i-i=a_j-j$,将$a_k-k$看成一个整体,就是两数之和换皮.

枚举这一节本质还是考察对哈希表的熟练使用,通过记录过往信息实现$O(n)$时间复杂度解决问题

**1.两数之和**

```python
#1(https://leetcode.cn/problems/two-sum/)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d={}
        for i,x in enumerate(nums):
            if target-x in d:
                return [i,d[target-x]]
            d[x]=i
```

这部分也有几道需要深度思考的题目:

**121.买卖股票的最佳时机**

这道题采用的思想是贪心+延时修改,有关延时修改,将在下部分详细阐释

**624.数组列表中的最大距离**

这道题主要思想是贪心,同时引入了一种计算两个数差距离最大值$|a-b|$的技巧

绝对值处理起来是比较棘手的,换位思考,$|a-b|的最大值=max(cur\_mx-mn,mx-cur\_min)$

即转化成$max(当前最大值-历史最小值,历史最大值-当前最小值)$

**2905.找出满足差值条件的下标II**

这道题考查的更深一些,它要求维护[0,i-diff]范围的最值,通常想法容易想到线段树维护区间最值,但是由于本题左端点固定是0,因此可以通过枚举实现.从下标为diff开始枚举,当遍历到下标i时,才将i-diff位置的数加入哈希表,然后更新最值,这样就实现了题目要求.同时本题由于要返回下标而不是值,因此实际维护的也再是最值,而是最值对应的下标.

这道题目也可以看成另一种形式的延时修改,即i下标的数,在i+diff位置才加入哈希表.

可以看到,这部分难度较高的几道题目都使用了延时修改,这是一种重要的枚举技巧,同时一定程度上渗透了动态规划的思想.

## 2.进阶

**核心技巧:延时修改(位置越前,越晚更新),循环拆解(三重循环拆分成二重)**

**小技巧:字符串状压,不定长滑窗,枚举中间,折半枚举+状压,数学运算代替数位交换,数位交换的性质,值域代替下标枚举**



进阶的枚举题目开始使用一些较复杂的技巧,这里将一一阐释

**2506.统计相似字符串对的数目**

这道题考查如何将包含相同字符集合的字符串映射到同一个键

直观做法是将字符串用set去重后,排序,然后转成tuple(即可哈希类型)

另一种更加高效的做法是使用掩码,即将26个字母分别映射到0~25总计26个二进制位,使用状压的思想解决问题.这是一种更加高效的做法.

**2874.有序三元组中的最大值II**

这道题可以当作延时修改模版题

延时修改的核心思想就是当更新当前位置i的答案时,可能会用到i-1位置甚至i-2位置的最值.

这看似比较棘手,但是如果我们稍微调整一下变量更新的顺序,就可以办到

拿此题举例,题目要求出$(nums[i]-nums[j])*nums[k]$的最大值,同时要求i<j<k

直观思路就是遍历2~n范围内的下标,即nums[k],然后乘上对应位置最大的$nums[i]-nums[j]$即可

想求出这个式子的最大值,也不难,在来到一个新位置j时,用过往最大值减去当前位置的值,即可

整理思路后,可以发现,更新当前位置k的答案,需要用到0~k-1范围的$(nums[i]-nums[j])$的最大值,

而更新0~k-1范围的最大值,又需要0~k-2范围$nums[i]$的最大值,因此需要错位修改这几个变量

即先修改ans,再修改max_diff(即nums[i]-nums[j]的最大值),最后修改max_pre(即nums[i]的最大值)

这样就保证了在k位置更新的max_pre,直到k+1位置才会被用来更新max_diff,而k+1位置更新的max_diff,

直到k+2位置才会被用来更新ans,这样就实现了题目的目标.

简言之,就是用到的越靠前的变量,更新时要越靠后,即位置越前,越晚更新

```python
#2874(https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/)
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        ans=max_diff=pre_max=0
        for x in nums:
            ans=max(ans,max_diff*x)
            max_diff=max(max_diff,pre_max-x)
            pre_max=max(pre_max,x)
        return ans
```

思维拓展,注意本题也可以用枚举中间+前后缀分解的思路解决,这种思路更容易想到,写起来也更简单

```python
#枚举中间+前后缀分解
#注意nums中的数都为正数,因此目标表达式如果>0,nums[i]-nums[j],及nums[k]都要>0
#因此枚举中间,考虑前后缀的最大值即可
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        pre=list(accumulate(nums,max))
        suf=list(accumulate(nums[::-1],max))[::-1]
        ans=0
        for i in range(1,len(nums)-1):
            ans=max(ans,(pre[i-1]-nums[i])*suf[i+1])
        return ans
```

**1031.两个非重叠子数组的最大和**

本题实际是两数之和的变体,只不过这里维护的不再是数,而是子段和

考虑a在前,b在后的情况,遍历到i位置时,用s[i-b]-s[i-b-a]更新a的最大字段和,b在前,a在后同理

此题从另一个角度看仍然是延时修改的一个变体,即i位置才调用i-b-a~i-b范围的子段和,和上一节的2874题有异曲同工之处

```python
#1031(https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/)
class Solution:
    def maxSumTwoNoOverlap(self, nums: List[int], a: int, b: int) -> int:
        s=list(accumulate(nums,initial=0))
        n=len(s)
        ans=max_sa=max_sb=0
        for i in range(a+b,n):
            #a在前
            max_sa=max(max_sa,s[i-b]-s[i-b-a])
            #b在前
            max_sb=max(max_sb,s[i-a]-s[i-a-b])
            ans=max(ans,max_sa+s[i]-s[i-b],max_sb+s[i]-s[i-a])
        return ans
```

**2555.两个线段获得的最多奖品**

这道题是枚举和不定长滑窗相结合的题目,由于是两个线段,因此可以用类似两数之和的枚举技巧,同时因为是线段,表示一个区间信息,因此要用滑动窗口来维护.

本题容易产生的误区是,将相同位置的奖品合并,但这会增加处理难度.

原数组中的下标代表了有奖品的位置,通过下标做差就可以求出区间内奖品数量,通过下标对应的值做差可以求出区间实际长度.

如果将同一位置的奖品合并,值就变成了某个点的奖品数量,相当于要维护(位置,数量)的二元组,这是画蛇添足的行为.

另一个误区是盲目使用二分,这种区间变化的题目,使用二分复杂度相当高,因为线段每移动一次,就更换边界,就要再二分一次.同时由于边界关系比较复杂,二分很容易出错.正确做法是利用数组值的差就是线段长度,下标之差就是奖品数这一性质,采取不定长滑窗来维护线段长度,使其不超过k.

把握清楚这些性质后,此题和1031题相比并无明显差异.

```python
#解法1:枚举+不定长滑动窗口+维护前缀最大值
#设左边的线段为a,右边的线段为b
#设b的左右端点分别为left,right
#为了尽量覆盖更多的奖品,right要与有奖品的端点重合,left则是左侧能覆盖的最远的奖品位置
#因此枚举b的右端点的位置,计算出其能覆盖的奖品数,再加上线段a能覆盖的奖品数,就是答案
#由于线段a和线段b的长度相同,因此可以枚举b的同时,记录其途中经过的所有位置的最大值
#用mx[i+1]表示0~i范围线段能覆盖的最大奖品数,其中mx[i+1]=max(mx[i],r-left+1)
#mx的更新方式和前缀最大值的更新方式类似,只不过这里是用滑动窗口代替了数字
#这样最终答案即为mx[left]+right-left+1,
class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        n=len(prizePositions)
        #剪枝,如果两个线段能覆盖全部prizePositions,则直接返回数组长度n
        #这里是2k+1是因为长度为k的线段覆盖点数为k+1,两个线段端点不重合时覆盖的最大点数为2k+2
        #这里因为直接用起点减去终点,得到的是总点数-1,因此左边就是2k+1
        if 2*k+1>=prizePositions[-1]-prizePositions[0]:
            return n
        mx=[0]*(n+1)
        ans=l=0
        for r,x in enumerate(prizePositions):
            #注意这里的l,r均是指prizePositions中的下标位置
            while prizePositions[r]-prizePositions[l]>k:
                l+=1
            ans=max(ans,r-l+1+mx[l])
            mx[r+1]=max(mx[r],r-l+1)
        return ans
```

**1995.统计特殊四元组**

这题直观解法是O(n^4),即四重循环枚举a,b,c,d,这种写法效率很低

优化的想法是将原式变形成nums[a]+num[b]==nums[d]-nums[c]

这样枚举a,b,nums[a]+nums[b]就变成定值,可以用类似两数之和的处理方法,在O(n^3)时间内解决此题

但是以上解法都没有充分用到题目中给出的a<b<c<d的性质

倒序从n-3开始枚举b,同时从b+2开始正序枚举d,中间给c留出空位

在b不断减小的过程中,留给c的空位会逐渐增加,可以发现,当b左移时,只有b+1位置是新的c的位置,因此每一轮只需考虑b+1位置的c即可,没有必要重新枚举一遍其他位置的c

这样,一个成型的算法就完成了.外层倒序枚举b,内层正序枚举d,将nums[b+1\](即nums[c])+num[d]加入哈希表

枚举d结束后,在内层枚举a,计算nums[a]+nums[b\](nums[b]就是外层正在枚举的),如果其存在于哈希表中,更新答案

可以发现,这种算法将嵌套的三重循环变成了内层有两个循环的二重循环,从而实现了从O(n^3)到O(n^2)的优化

同时可以发现,这种解法实际是枚举中间的思想:

即外层枚举中间的数b,内层第一重循环枚举右侧数d,同时推出c的位置,内层第二重循环枚举左侧数a.枚举中间的思想可以隐式地在枚举a,b,c,d的同时满足a<b<c<d,十分巧妙

当变量较多,3个或者4个时,枚举中间的写法往往比枚举两边更简单



循环拆解是一种朴素的枚举技巧,通过巧妙的方式实现了时间复杂度的优化.

这种方式和动态规划中利用各种优化方式将O(n^2)的的解法优化成O(n)有异曲同工之处

同时从此题可以衍生出O(n^2)复杂度求四数之和求方案数问题.

即nums[a]+nums[b]+nums[c]+nums[d]=target

枚举nums[a],nums[b],将v=nums[a]+nums[b]加入哈希表

然后原问题就转化成了nums[c]+nums[d]=target-v,这可以用两数之和的方法求解,

这种思路也可以看成值域代替下标枚举

**454 四数相加II**就是用到了这个思想

注意这个是求方案数,如果求具体方案,只能用常规方法O(n^3)枚举

```python
#1995(https://leetcode.cn/problems/count-special-quadruplets/)
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n=len(nums)
        cnt=defaultdict(int)
        ans=0
        for b in range(n-3,0,-1):
            for d in range(b+2,n):
                cnt[nums[d]-nums[b+1]]+=1
            for a in range(b):
                ans+=cnt[nums[a]+nums[b]]
        return ans
```

**3404.统计特殊子序列的数目**

本题就是上一题换皮,式子变形后用上一题方法即可

注意本题要求a,b,c,d之间至少隔一个数,因此枚举时注意要间隔1

从这两道题可以总结出O(n^2)枚举四元组的套路:

即外层枚举2号元素位置,内层第一重循环枚举4号元素位置,根据题意推导出3号元素位置,内层第二重循环枚举1号元素位置

```python
class Solution:
    def numberOfSubsequences(self, nums: List[int]) -> int:
        n=len(nums)
        cnt=defaultdict(int)
        ans=0
        #外层枚举第二个数
        for q in range(n-5,1,-1):
            #内层第一重循环枚举第4个数,增加的第3个数可以推导出来
            for s in range(q+4,n):
                cnt[nums[s]/nums[q+2]]+=1
            #内层第二重循环枚举第1个数
            for p in range(q-1):
                ans+=cnt[nums[p]/nums[q]]
        return ans
```

**3267 统计近似相等数对II**

本题主要考查枚举,最优解集合了多种枚举优化方法.

直观思路:枚举一个数交换两次能得到的所有数字,判断这些数字是否在哈希表中,用枚举右,维护左的思想即可求解

这里着重讲最终优化的版本,即折半枚举+状压+用数学公式代替实际数位交换

正常做法就是朴素的交换两个数位,但是这种做法需要转化成字符串交换,效率很低.从数学角度思考,交换两个数,本质就是它们十进制幂次发生了对调,因此一个数i,j数位交换后,数值增量为$(a[j]-a[i])*(10^i-10^j)$

预处理出10的幂,就很可以用数学公式O(1)时间计算出交换后的数值

交换两次本质是交换一次之后,再交换一次,因此如果过往的数交换一次可以得到a,当前数交换一次也可以得到a,那么就相当于过往数交换两次可以得到当前数,这样我们只需要1次交换就可以求解了.

实际实现时,用哈希表保存通过一次交换可以得到数v的下标集合,即如果d[v]=s,那么s表示一系列下标状压后的集合,

这个集合里的下标对应的数经过一次数位交换后可以得到v.通过状压和折半枚举的方法,大大提高了枚举效率



同时注意如果是朴素做法(非折半枚举),第二次交换时要从i+1枚举而不是i,

这里用到了数位交换的性质:交换0和1,再交换0和2,等价于交换0和2,再交换1和2

```python
#3267(https://leetcode.cn/problems/count-almost-equal-pairs-ii/description/)
P=[10**i for i in range(7)] #预处理10的幂
class Solution:
    def countPairs(self, nums: List[int]) -> int:
        ans=0
        d=defaultdict(int) #d[x]表示数x可以由哪些下标的数交换一次得到,存储这些下标的状压集合
        n=len(str(max(nums))) #nums中最大的数有几位
        for p,x in enumerate(nums):
            vis={x} #交换0次,即自身
            s=list(map(int,str(x).zfill(n))) #补前导0
            s.reverse() #反转保证低位在左边
            n=len(s)
            for i in range(n):
                for j in range(i+1,n):
                    if s[i]==s[j]:continue
                    vis.add(x+(s[j]-s[i])*(P[i]-P[j]))
            ids=0 #所有经过<=2次交换能变成x的数的集合
            bp=1<<p
            #枚举x交换一次产生的数v
            for v in vis:
                ids|=d[v] #在哈希表中查找所有可以映射到v的下标,将它们或到ids中
                d[v]|=bp #v可以由下标p的数交换1次得到,更新交换一次能得到v的下标集合
            #ids中置位数即为能通过<=2次交换变成x的元素个数
            ans+=ids.bit_count()
        return ans
```

**3265 统计近似相等数对I**

这是上一题的初级版本,这里主要是探讨3265和3267题的内在联系

3265题要求最多交换一次,3267是最多交换两次,从3267题最优解折半枚举出发,可以发现,3265题是集合映射到数,

而3267是集合映射到集合.

因为交换一次能得到当前数,本质是集合a中的数交换一次得到当前数.即目标集合到当前数的映射.

而交换两次得到当前数,可以理解成,我们首先对当前数交换一次,得到集合b,

如果集合a中的数经过一次交换可以得到集合b,那么a中的数经过两次交换就可以得到当前数.即目标集合到当前集合的映射.

因此哈希表中记录的是数v可以由哪些位置的数交换一次而得到,相当于保存的是一个反向映射,最终对这些反向映射求并集,就可以得到经过两次交换可以得到当前数的那些数的集合

```python
#3265(https://leetcode.cn/problems/count-almost-equal-pairs-i/)
P=[10**i for i in range(7)] #预处理10的幂
class Solution:
    def countPairs(self, nums: List[int]) -> int:
        ans=0
        d=defaultdict(int) #d[x]表示数x可以由哪些下标的数交换一次得到,存储这些下标的状压集合
        n=len(str(max(nums))) #nums中最大的数有几位
        for p,x in enumerate(nums):
            vis={x} #交换0次,即自身
            s=list(map(int,str(x).zfill(n))) #补前导0
            s.reverse() #反转保证低位在左边
            n=len(s)
            for i in range(n):
                for j in range(i+1,n):
                    if s[i]==s[j]:continue
                    vis.add(x+(s[j]-s[i])*(P[i]-P[j]))
            #此题和3267的区别在于,本题是一个集合映射到一个数,即集合中所有数经过一次交换可以得到当前数
            #3267是,集合映射到集合(折半枚举的思想),因此处理起来更加复杂,需要用或运算实现集合的并
            ans+=sum(d[v] for v in vis)
            d[x]+=1
        return ans
```

**2964 可被整除的三元组数量**

这道题目是1995题的简单版本,本质是三数之和求方案数

这里同样使用枚举中间的技巧

可以发现,面对这种枚举n元组的问题,外层倒序枚举中间的数,内层正序枚举两边的数,可以实现全程都只用一个哈希表,大大提高了枚举的效率

```python
#枚举中间,用到了和1995题类似的技巧
#通过外层枚举中间,内层枚举两边,从而满足下标有序
#原式等价于(-nums[a]-nums[b])%d=nums[c]%d
class Solution:
    def divisibleTripletCount(self, nums: List[int], d: int) -> int:
        n=len(nums)
        cnt=defaultdict(int)
        ans=0
        #从n-2开始倒序枚举中间的数nums[b],右边的空位留给nums[c]
        #随着b减小,右侧的数nums[c]可以占据的位置逐渐增加,且每次增加的位置即为b+1
        #在哈希表中存储nums[c](即b+1位置)模d的值
        #同时0到b范围内正序枚举a,如果(-nums[a]-nums[b])%d在哈希表中出现,说明找到了一组a,b,c,更新答案
        for b in range(n-2,0,-1):
            cnt[nums[b+1]%d]+=1
            for a in range(b):
                ans+=cnt[(-nums[a]-nums[b])%d]
        return ans
```

# 2.枚举中间

对于三个或者四个变量的问题，枚举中间的变量往往更好算。

枚举中间问题往往不是孤立存在,往往要同时结合以下技巧求解.

**小技巧:字符串状压,前后缀分解,枚举右,维护左,索引排序,三指针,枚举边(四元组枚举中间两个变量)**

**2909.元素和最小的山形三元组II**

本题是枚举中间模版题,枚举中间元素时,显然需要前缀,后缀的信息,因此枚举中间往往结合前后缀分解

```python
#2909(https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/)
#枚举中间+前后缀分解
class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        n=len(nums)
        #前缀最小值
        pre=list(accumulate(nums,min))
        #后缀最小值
        suf=list(accumulate(nums[::-1],min))[::-1]
        ans=inf
        for i in range(1,n-1):
            if pre[i-1]<nums[i]>suf[i+1]:
                ans=min(ans,pre[i-1]+nums[i]+suf[i+1])
        return ans if ans<inf else -1
```

**3583.统计特殊三元组**

本题同样时枚举中间+前后缀分解,只不过这里用的是哈希表实现类似前后缀信息的维护

```python
#3583(https://leetcode.cn/problems/count-special-triplets/)
mod=1_000_000_007
class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        suf=Counter(nums)
        ans=0
        pre=defaultdict(int)
        for x in nums:
            suf[x]-=1
            ans=(ans+pre[2*x]*suf[2*x])%mod
            pre[x]+=1
        return ans
```

思维拓展,本题也可以用枚举右,维护左+延时修改的方法一次遍历解决问题

第k轮更新的第一个数的信息cnt1,第k+1轮才会被用来更新第二个数cnt2的信息,而cnt2第k+2轮才会被用来更新cnt3(即答案)的信息,这种解法巧妙地应用延时修改的特性,只不过这次是在哈希表上.

```python
#枚举右,维护左+延时修改
mod=1_000_000_007
class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        cnt1=defaultdict(int)
        cnt2=defaultdict(int)
        cnt3=0
        #枚举第三个数
        for x in nums:
            if x&1==0:
                cnt3+=cnt2[x//2]
            cnt2[x]+=cnt1[2*x]
            cnt1[x]+=1
        return cnt3%mod
```

**1930.长度为3的不同回文子序列**

这道题目容易想到枚举中间,然后前后缀分解.但是优化的做法是比较难想的.

先说第一种优化方法,前后缀信息保存出现字母的集合,用状压记录

然后遍历原字符串,计算每个位置前后缀的交集,然后将这个集合或到该位置的字母的答案集合中

最后扫描一遍答案数组,对所有元素(注意元素是集合,以状压形式保存)的置位数求和就是答案

这种状压技巧,使得字符串和位运算联系起来,大大提高了算法速度

```python
#常规解法,枚举中间+前后缀分解+状压
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n=len(s)
        #利用字符串掩码存储前缀及后缀出现了哪些字母
        pre=[0]*n
        for i,x in enumerate(s):
            j=ord(x)-ord('a')
            pre[i]=(pre[i-1] if i else 0)|1<<j
        suf=[0]*n
        for i in range(n-1,-1,-1):
            x=s[i]
            j=ord(x)-ord('a')
            suf[i]=(suf[i+1] if i<n-1 else 0)|1<<j
        #枚举中间字母c,对前缀和后缀取交集,然后或到以c为中心的答案数组中
        #最后对答案数组中的每个元素求置位数再求和即可
        ans=[0]*26
        for i in range(1,n-1):
            x=s[i]
            j=ord(x)-ord('a')
            ans[j]|=pre[i-1]&suf[i+1]
        return sum(x.bit_count() for x in ans)
```

第二种优化方法就不容易想到了,虽然也是前后缀分解思想,但是这种解法是枚举两侧,利用字符串查找api,快速找到该字符在两侧第一次出现的位置l,r,然后检查l,r之间的字符的种类数

同时注意这种解法使用的find,rfind,切片,in等原语都是用C写的高效实现,因此效率非常高

```python
#击败100%解法,枚举两边
#枚举两侧字母x(26种可能性)
#然后在s串中利用find,rfind函数分别找到从左往右,从右往左第一个等于该字符的位置l,r
#利用[l+1:r]将(l,r)之间的字符切出来,里面字符串的种类即为两侧字母为x时的答案
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        ans=0
        for x in ascii_lowercase:
            l,r=s.find(x),s.rfind(x)
            if r>l+1:
                t=s[l+1:r]
                #注意这种写法比用len(set(t))更快
                #因为下面这种做法是近似O(26)复杂度,len(set(t))要遍历字符串t,是O(n)复杂度
                ans+=sum(c in t for c in ascii_lowercase)
        return ans
```

**3128.直角三角形**

此题容易看出枚举中间,即直角三角形的直角定点,再结合乘法原理即可求解

注意枚举时预处理行列的变量名不要和枚举的变量名混淆

```python
#3128(https://leetcode.cn/problems/right-triangles/)
#枚举中间
#rows,cols分别记录行,列的和(提前减1)
#枚举所有为1的位置,用其在rows,cols对应的值相乘求和即可
class Solution:
    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        rows=[sum(r)-1 for r in grid]
        cols=[sum(c)-1 for c in zip(*grid)]
        return sum(a*b for row,a in zip(grid,rows) for x,b in zip(row,cols) if x)
```

**447.回旋镖的数量**

此题容易看出枚举中间,但是如何高效地实现是需要思考的.

在枚举中间点a之后,剩下的就是计算到点a距离相同的点对的数量,可以发现,这就是类似两数之和的问题,因此内层循环中用枚举右,维护左的思想即可.注意点对是有序的,因此更新答案时要乘2

```python
#447(https://leetcode.cn/problems/number-of-boomerangs/)
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        ans=0
        for x1,y1 in points:
            cnt=defaultdict(int)
            for x2,y2 in points:
                d=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)
                ans+=cnt[d]*2
                cnt[d]+=1
        return ans
```

**456.132模式**

注意此题最优解是单调栈,这里主要阐述枚举中间+有序表的解法

题目本质是寻找这样的三元组,中间的数b大于两边的数,同时左侧的数a<右侧的数c

直观思路就是找到左边最小的数a,和右边最大的且小于中间数b的数c比较,如果c>a,那么找到一组解

寻找最大的小于x的数,很容易想到二分,但是二分需要数组有序,因此引入有序表,此题即可轻松解决

第一次遍历处理出前缀最小值,第二次遍历处理出后缀中小于当前数的最大值,本质仍是前后缀分解的思想

```python
#456(https://leetcode.cn/problems/132-pattern/)
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        pre=list(accumulate(nums,min))
        s=SortedList()
        n=len(nums)
        for i in range(n-1,-1,-1):
            x=nums[i]
            if 0<i<n-1:
                idx=s.bisect_left(x)-1
                if idx!=-1 and s[idx]>pre[i-1]:
                    return True
            s.add(x)
        return False
```

**3067.在带权树网络中统计可连接服务器对数目**

本题本质就是统计三元组数量,容易想到枚举中间,但是本题是树,因此枚举中间需要换根,即用到换根dfs.

在求出每个根的分支数组后,利用枚举右,维护左+前缀和的思想计数即可,这和447题是一样的

```python
#3067(https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/)
class Solution:
    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
        n=len(edges)+1
        g=[[] for _ in range(n)]
        for x,y,z in edges:
            g[x].append((y,z))
            g[y].append((x,z))
        def f(u,fa,d):
            ans=d%signalSpeed==0
            for v,w in g[u]:
                if v==fa:continue
                ans+=f(v,u,d+w)
            return ans
        ans=[0]*n
        for u,sons in enumerate(g):
            if len(sons)==1:continue #剪枝,至少有两个孩子才有计算的意义
            s=0
            #计算每个分支的数量
            #然后用枚举右,维护左+前缀和计数
            for v,w in sons:
                x=f(v,u,w)
                ans[u]+=s*x
                s+=x
        return ans
```

**1534.统计好三元组**

本题O(n^2)解法是比较难想到的

首先说枚举中间的写法

这种方法首先利用索引排序,将下标0~n-1按照值的大小排序,得到ids数组

需要用到索引排序的原因是因为题目中要求i<j<k,即在枚举三元组时必须满足下标大小关系

之后枚举中间的数的下标j,遍历ids数组,注意此时ids数组中下标对应的数是有序的,

求出满足题目条件且<j的前缀数组,同理,处理出后缀数组,这两个数组分别对应下标i,k的可能取值范围

此时题目中前两个条件都已满足,只差第三个条件

这里我们用三指针的方法来求出满足第三个条件的i,k

首先枚举i,题目中条件三可以转化为arr[i]-c<=arr[k]<=arr[i]+c,这就变成了三指针经典问题,用两个指针k1,k2寻找上界和下界,即可求解,注意到left中的数x是从小到大,具有单调性,当x变大时,原本<=x+c的数依然成立,因此k1,k2是不会回退的,这样就用总体O(n^2)的时间复杂度解决了本题.

可以看到,这种解法是多种技巧的结合,是值得反复琢磨的.

```python
#解法2:索引排序+枚举中间+前后缀分解+三指针
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        n=len(arr)
        ids=sorted(range(n),key=lambda p:arr[p])
        ans=0
        for j in ids:
            v=arr[j]
            left=[arr[i] for i in ids if i<j and abs(arr[i]-v)<=a]
            right=[arr[k] for k in ids if k>j and abs(arr[k]-v)<=b]
            k1=k2=0
            for x in left:
                while k2<len(right) and right[k2]<=x+c:
                    k2+=1
                while k1<len(right) and right[k1]<x-c:
                    k1+=1
                ans+=k2-k1
        return ans
```

思维扩展,另一种思考量更少,但是仅适用于值域较小情况下的解法

对前两个条件进行变形,可以得到arr[j]-a<=arr[i]<=arr[j]+a,arr[k]-c<=arr[i]<=arr[k]+c,同时arr中的数还需要满足

0<=arr[i]<=max(arr),

对这三个不等式求交集,即可求出i的值域范围:[max(arr[j]-a,arr[k]-c,0),min(arr[j]+a,arr[k]+c,max(arr))]

枚举j,k,即可求出i的值域,问题转化成已知id的值域,如何求出数量.容易想到,可以利用前缀和求解

如果值域是[l,r],当知道<=r的数量,及<=l-1的数量,两者做差就可求出i的数量,因此可以维护值域的前缀和

但是可以注意到,这个前缀和随着j,k的变化是动态变化的,常规方法行不通.

而题目要求i<j<k,这里用到了类似之前四数之和求方案数的方法,随着j变大,留给i的空位逐渐增加s,i能取到的值也逐渐增加.因此在遍历中间数y的过程中,考虑它对前缀和数组的贡献,可以发现从y~mx+1范围都有y的贡献.因此在每轮外层循环遍历y的最后,更新y对前缀和数组的贡献,就实现了动态更新前缀和,给下一轮新的y使用,同时保证前缀和数组中计算得到的i,下标一定小于j.注意:前缀和s[i+1]表示的是值<=i的数量,之所以下标有一个偏移,是因为arr[i]可以取到0,因此0下标不能存储实际信息,必须存储0,这样在用前缀和做差时,才不会出现下标越界.

可以发现,这种解法虽然是枚举后两个数,但是间接地用到了枚举中间的性质,可以说非常巧妙

```python
#解法1:枚举+贡献法+前缀和
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        ans=0
        mx=max(arr)
        s=[0]*(mx+2) #注意s[i+1]表示值<=i的数量
        for j,y in enumerate(arr):
            for z in arr[j+1:]:
                if abs(y-z)>b:continue
                #上下界
                l=max(y-a,z-c,0)
                r=min(y+a,z+c,mx)
                #注意l<=r时,才有合法的i
                if l<=r:
                    ans+=s[r+1]-s[l]
            #y可以贡献给s中下标范围在y+1~mx+1的位置
            #可以发现这里不是通常意义前缀和的求法,而是利用类似贡献法的方法
            for v in range(y+1,mx+2):
                s[v]+=1
        return ans
```

**2242.节点序列的最大得分**

这道题是一道图论问题,在图论问题中,常见做法是枚举点,但是这道题如果枚举点时间复杂度很高,会超时,如果枚举边,就可以高效解决.

题目要求四个相邻点的最大和,4这个数很特殊,因为它有三条边,如果枚举中间边(即枚举中间两个点)的话,就变成了一个对称的问题,求出端点邻居的最大值即可.

但是不能只处理最大值,考虑下面的情况.

如果只保留邻居最大值x,可能出现x与当前边另一个端点重合的情况
如果只保留邻居最大和次大,可能出现一个与另一个端点重合,一个与另一个端点邻居的最大值重合
因此只有保留邻居前三大,才能覆盖全部情况

前三大可以用堆,快速选择,手动比较等处理,处理完全部点邻居的前三大需要把所有边遍历一遍,即O(n)复杂度

这里用python heapq库中的nlargest函数求前三大,这个函数在k较小的时候有特殊优化,和手写三元比较求前三大复杂度是近似的.

实际求解前三大时比较的是二元组,即(值,点),保留点的信息是因为要确定当前选出的点是否和端点重合

枚举b的前三大中不等于c的点a,枚举c的前三大中不等于b且不等于a的点d,计算a,b,c,d四点分数和最大的即可
注意不能找到一组答案就返回
因为s前三大大小可能相同,比如b的邻居是5,5,5,c的邻居是5,4,4,且b和c都连同一个5
如果当b=5,c=4就返回,就会错过b=5,c=5的情况,因此必须遍历完全部情况求最大



可以发现,本题用到的枚举技巧比较特殊,需要特殊记忆.

```python
max=lambda x,y:x if x>y else y
class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
        n=len(scores)
        g=[[] for _ in range(n)]
        for x,y in edges:
            g[x].append((scores[y],y))
            g[y].append((scores[x],x))
        for i,s in enumerate(g):
            if len(s)>3:
                g[i]=nlargest(3,s)
        ans=-1
        # for b,c in edges:
        #     for va,a in g[b]:
        #         if a!=b and a!=c:
        #             for vd,d in g[c]:
        #                 if d!=a and d!=b:
        #                     ans=max(ans,va+scores[b]+scores[c]+vd)

        #另一种写法
        for b,c in edges:
            for va,a in g[b]:
                for vd,d in g[c]:
                    #这个式子等价于c!=a and a!=d and d!=b
                    #即b的邻居a不能等于c,c的邻居d不能等于b,同时a和d不能相等
                    if c!=a!=d!=b:
                        ans=max(ans,va+scores[b]+scores[c]+vd)
        return ans
```

**2867.统计树中的合法路径数目**

题目要求只含一个质数的路径数目,容易想到枚举质数做根.统计该质数根的所有非质数孩子,以这些孩子为根dfs求出所有不经过质数点能到达的点,即非质数连通块,然后就转化成了类似3067的问题.求连通块也可以用并查集来实现.本题还有换根dp/树形dp等解法,但是均不如本解法简洁,因此不再赘述.

可以看到本题枚举的方法比较特殊,是遍历所有点,但同时做到了O(n)复杂度.核心在于用size数组标记访问过的非质数连通块.

本题其实是用遍历每个质数根的方式实现了类似换根dp的效果,即隐式换根.每次以新的质数点做根时,其连接的非质数连通块大小是不变的,因此就产生了重复子问题,用size数组保存非质数连通块大小,就实现了换根时重复利用访问过的信息,从而高效解决问题

具体实现流程,遍历所有质数编号点当作树根,同时求出其连接的所有非质数连通块,把这个连通块当作类似链的东西的话,本题就转化成类似求树的直径或者3067那种问题,用枚举右,维护左即可实现计数,最后还要加上从根到非质数点的路径,即树根连接的所有非质数连通块的和

连通块的求法就是普通dfs,从树根的每个非质数孩子出发,遇到非质数点就继续dfs,从而求出每个孩子对应的连通块.

遍历同时记录连通块中所有点,遍历结束后,将这些点在size数组中的值都标记为连通块大小

可以发现,这种解法本质用的是枚举思想和图论dfs求连通块思想,和通常树的题目有一定区别.

```python
#枚举中间+dfs求连通分量+枚举右,维护左计数
N=100_000
p=[True]*(N+1)
p[0]=p[1]=False
for i in range(2,isqrt(N)+1):
    if p[i]:
        for j in range(i*i,N+1,i):
            p[j]=False
class Solution:
    def countPaths(self, n: int, edges: List[List[int]]) -> int:
        g=[[] for _ in range(n+1)]
        for x,y in edges:
            g[x].append(y)
            g[y].append(x)
        nodes=[]
        def f(u,fa):
            nodes.append(u)
            for v in g[u]:
                if v!=fa and not p[v]:
                    f(v,u)

        ans=0
        size=[0]*(n+1)
        for u in range(1,n+1):
            if not p[u]:continue
            s=0
            for v in g[u]:
                if p[v]:continue
                if size[v]==0:
                    nodes.clear()
                    f(v,u)
                    for node in nodes:
                        size[node]=len(nodes)
                ans+=s*size[v]
                s+=size[v]
            ans+=s
        return ans
```

**2552.统计上升四元组**

这题比较容易想到的解法是枚举中间两个数,然后让剩下两个数满足条件即可,容易想到前后缀分解.

枚举中间两个数j,k,保证nums[j]>nums[k].

这个思想在2242题有用到,那题是枚举中间的边,同样是中间两个点,同时nums[i]需要满足<nums[k],nums[l]需要满足>nums[j].

nums[i]的数量统计更新方式套用1534题的贡献法更新前缀和的方式即可,nums[l]的数量统计稍微复杂些,因为要处理出k位置右侧比nums[j]大的元素数量,这需要用一个二维数组预处理出来

本质仍是前后缀分解的思想

```python
#2552(https://leetcode.cn/problems/count-increasing-quadruplets/)
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n=len(nums)
        #great[i][v]表示i位置右侧(不包含i)>v的数
        #由于k的范围在2~n-2,因此只需更新这个范围
        great=[None]*n
        great[-1]=[0]*(n+1)
        for k in range(n-2,0,-1):
            great[k]=great[k+1][:]
            #值域范围在1~n
            #更新方式同1534题
            for x in range(1,nums[k+1]):
                great[k][x]+=1
        ans=0
        less=[0]*(n+1) #less[v]表示j左侧<v的数量
        for j in range(1,n-1):
            for v in range(nums[j-1]+1,n+1):
                less[v]+=1
            for k in range(j+1,n-1):
                if nums[j]>nums[k]:
                    ans+=less[nums[k]]*great[k][nums[j]]
        return ans
```

上面的解法有一个小优化,就是利用题目中的条件,原数组是一个1~n的排列,因此可以通过数学变化去掉less数组

设x=nums[k],那么great[j][x]表示j右侧比x大的数,j右侧总计有n-1-j个数,那么j右侧<=x的数=n-1-j-great\[j][x]
数组中<=x的数总计有x个,因此j左侧<=x的数量=x-j右侧<=x的数量=x-(n-1-j-great\[j][x])
由于x:nums[k]在j右边,因此j左侧<=x的数量即为j左侧<x的数量即为x-(n-1-j-great\[j][x])
这样就优化掉了less数组

```python
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n=len(nums)
        great=[None]*n
        great[-1]=[0]*(n+1)
        #注意此时求less要用到great[1],因此循环下界和优化之前相比改到了1
        for k in range(n-2,0,-1):
            great[k]=great[k+1][:]
            for x in range(1,nums[k+1]):
                great[k][x]+=1
        ans=0
        for j in range(1,n-1):
            y=nums[j]
            for k in range(j+1,n-1):
                x=nums[k]
                if y>x:
                    less=x-(n-1-j-great[j][x])
                    ans+=less*great[k][y]
        return ans
```

另一种解法是基于动态规划的思想,将原问题分解成若干子问题求解,这种解法堪称一绝

本题是456题:132模式的进阶,可以理解成1324模式,这个可以分解成子问题:枚举4,求132的个数
而132又可以分解成子问题:枚举3,加上12模式的个数

这样用3个变量分别维护12,132,1324的个数,迭代更新,就可完成求解

```python
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        cnt4=0 #1324模式
        n=len(nums)
        cnt3=[0]*n #cnt3[j]表示3的下标为j的132模式的个数
        #枚举第四个数
        for l in range(2,n):
            #cnt2统计右端点为l的12模式的个数
            #l从2开始枚举就是为了照顾12模式
            #本题符合条件的1324模式中的2至少下标为2
            cnt2=0
            #枚举第二个数
            for j in range(l):
                if nums[j]<nums[l]:
                    cnt4+=cnt3[j] #cnt4加上3的下标为j的132模式的数量
                    cnt2+=1 #2的下标为l的12模式数量+1
                #nums[j]>nums[l],j,l可以看成132模式的3,2
                else:
                    #此时用2的下标为l的12模式的数量更新3的下标为j的132模式的数量
                    cnt3[j]+=cnt2
        return cnt4
```

**3257.放三个车的价值之和最大**

本题列和行的数据范围很大,O(n^3)的算法是无法通过的.因此需要想一个更加简洁的做法.

考虑枚举中间行的车,那么它上面的车,下面的车及这个车本身如果分布在不同的三列,就是一种可行的方案.

因此维护前缀前三大,后缀前三大,且这三个元素不在同一列,就可以轻松解决此题.

这个思路和2242题十分类似.

前缀最大的实现是需要一定技巧的,难点在于要维护列不同的前三大,这需要用pair实现

本题和2242有一点不同,就是枚举上下前三大两两匹配时,找到可行解即可返回,因为本题左右前三大是互斥的,不会出现一个点既在前缀中,又在后缀中的情况,因此可以剪枝,找到一组可行的就返回.

```python
#3257(https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/)
#枚举中间+前后缀分解
class Solution:
    def maximumValueSum(self, board: List[List[int]]) -> int:
        #取前i列的前三大值,且这三个不能在同一列
        #取前三大的原因和2242题类似
        def update(row):
            for j,x in enumerate(row):
                #如果当前点的值比最大值大,更新最大值
                #同时要确定原来的最大值能否更新成次大值
                #以及原来大最大值能否更新成第三大值
                #判定依据是是否满足不在同一列
                if x>p[0][0]:
                    if p[0][1]!=j:
                        if p[1][1]!=j:
                            p[2]=p[1]
                        p[1]=p[0]
                    p[0]=(x,j)
                elif x>p[1][0] and j!=p[0][1]:
                    if p[1][1]!=j:
                        p[2]=p[1]
                    p[1]=(x,j)
                elif x>p[2][0] and j!=p[0][1] and j!=p[1][1]:
                    p[2]=(x,j)
        n=len(board)
        suf=[None]*n
        p=[(-inf,-1)]*3 #前三大值
        #更新后缀前三大
        #后缀更新到第三行即可
        for i in range(n-1,1,-1):
            update(board[i])
            suf[i]=p[:]
        ans=-inf
        p=[(-inf,-1)]*3
        #前缀更新到倒数第三行即可
        for i,row in enumerate(board[:-2]):
            update(row)
            for j2,y in enumerate(board[i+1]): #中间行的车
                for x,j1 in p:
                    for z,j3 in suf[i+2]:
                        if j1!=j2 and j1!=j3 and j2!=j3: #三个车都不同列
                            #此题和2242题略有不同,可以剪枝
                            #因此前缀和后缀前三大是互相隔离的,不连通
                            #因此找到第一对不等的j1,j3即可返回
                            ans=max(ans,x+y+z)
                            break
        return ans
```

