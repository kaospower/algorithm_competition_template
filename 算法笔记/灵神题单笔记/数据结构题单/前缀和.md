# 1.前缀和基础

# 2.前缀和与哈希表

# 3.距离和

# 4.前缀异或和

# 5.其他一维前缀和

**3445.奇偶频次间的最大差值**

枚举+不定长滑窗+前缀和

此题容易想到滑动窗口,但是由于有多种字符,每种字符都可能贡献给最大值,直接维护难以操作
由于最大值必然由两种不同字符贡献而来,因此可以枚举两种不同字符,这样只需要同时维护两种字符的出现次数
同时由于设计到奇偶性,因此可以分类讨论,长度为偶数的子串必定是异或值为0的两个前缀和做差而来
同理,长度为奇数的子串必定是异或值为1的两个前缀和做差而来

$s[i+1][j]表示0~i范围数字j出现的次数$
$设下标区间为[l,r),a出现次数为s[r][x]-s[l][x],b出现次数为s[r][y]-s[l][y]$
$那么目标就是求(s[r][x]-s[l][x])-(s[r][y]-s[l][y])=(s[r][x]-s[r][y])-(s[l][x]-s[l][y])的最大值$
$设ti=s[i][x]-s[i][y],由于是求tr-tl的最大值,枚举右,维护左,枚举右端点r,维护ti的历史最小值即可$
同时由于要满足奇偶性,因此需要维护四种历史最小值,即x偶,y偶;x偶,y奇;x奇y偶;x奇y奇

```python
#3445(https://leetcode.cn/problems/maximum-difference-between-even-and-odd-frequency-ii/)
fmax=lambda x,y:x if x>y else y
fmin=lambda x,y:x if x<y else y
class Solution:
    def maxDifference(self, s: str, k: int) -> int:
        s=list(map(int,s))
        cnt=[0]*5
        ans=-inf
        #枚举x,y的所有可能情况
        for x in range(5):
            for y in range(5):
                #如果x和y相等,那么不满足x出现奇数次,y出现偶数次的情况,continue
                if y==x:
                    continue
                cur_s=[0]*5
                pre_s=[0]*5
                #min_s[p][q]表示x出现次数奇偶性为p,y出现次数奇偶性为q时差的最小值
                min_s=[[inf,inf],[inf,inf]]
                l=0
                for i,v in enumerate(s):
                    cur_s[v]+=1
                    #由于前缀和s[i+1]表示0~i范围的累加和,因此为了简化书写,提前将右边界+1
                    r=i+1
                    #不定长滑窗
                    #子串长度至少为k
                    #同时需要x出现次数为非0奇数,y出现次数为非0偶数
                    #因此cur_s[x]需要>pre_s[x]并且差为奇数
                    #cur_s[y]需要>pre_s[y]并且差为偶数
                    #固定右端点,左端点右移,滑窗内的左端点都是满足r-l>=k的,注意r=i+1,因此r-l代表子串长度
                    #求出以r为右端点所有满足条件的ti=s[i][x]-s[i][y]的历史最小值(注意是四种)
                    while r-l>=k and cur_s[x]>pre_s[x] and cur_s[y]>pre_s[y]:
                        #p,q判断奇偶性
                        p,q=pre_s[x]&1,pre_s[y]&1
                        min_s[p][q]=fmin(min_s[p][q],pre_s[x]-pre_s[y])
                        pre_s[s[l]]+=1
                        l+=1
                    #更新答案,注意cur_s[x]^pre_s[x]需要异或值为1,才能保证差是奇数
                    #同理,cur_s[y]^pre_s[y]需要异或值为0,才能保证差是偶数
                    if r>=k:
                        ans=fmax(ans,cur_s[x]-cur_s[y]-min_s[cur_s[x]&1^1][cur_s[y]&1])
        return ans
```

# 6.二维前缀和

