# 1.基础

# 2.设计

# 3.双端队列

# 4.单调队列

**1438. 绝对差不超过限制的最长连续子数组**

本题是双单调队列同时维护滑动窗口最大最小值的经典题目

```python
#1438(https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        q_max=deque()
        q_min=deque()
        l=ans=0
        for r,x in enumerate(nums):
            while q_max and x>=nums[q_max[-1]]:
                q_max.pop()
            q_max.append(r)
            while q_min and x<=nums[q_min[-1]]:
                q_min.pop()
            q_min.append(r)
            while nums[q_max[0]]-nums[q_min[0]]>limit:
                l+=1
                if q_max[0]<l:
                    q_max.popleft()
                if q_min[0]<l:
                    q_min.popleft()
            ans=max(ans,r-l+1)
        return ans
```

有序表解法

```python
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        s=SortedList()
        ans=l=0
        for r,x in enumerate(nums):
            s.add(x)
            while s[-1]-s[0]>limit:
                s.remove(nums[l])
                l+=1
            ans=max(ans,r-l+1)
        return ans
```

**3589.计数质数间隔平衡子数组**

这道题容易想到用两个单调队列同时维护滑动窗口内素数最大最小值,难点在于同时维护质数个数

可以用两个指针last2,last同时维护倒数第一个质数,倒数第二个质数的位置

从而简化实现,这和树上滑窗有异曲同工之处

**双单调队列+双指针写法**

```python
N=50_000
p=[True]*(N+1)
p[0]=p[1]=False
for i in range(2,isqrt(N)+1):
    if p[i]:
        for j in range(i*i,N+1,i):
            p[j]=False
class Solution:
    def primeSubarray(self, nums: List[int], k: int) -> int:
        q=deque()
        q_max=deque()
        q_min=deque()
        last=last2=-1
        l=ans=0
        for r,x in enumerate(nums):
            if p[x]:
                last2,last=last,r
                while q_max and x>=nums[q_max[-1]]:
                    q_max.pop()
                q_max.append(r)
                while q_min and x<=nums[q_min[-1]]:
                    q_min.pop()
                q_min.append(r)
                while nums[q_max[0]]-nums[q_min[0]]>k:
                    l+=1
                    if q_max[0]<l:
                        q_max.popleft()
                    if q_min[0]<l:
                        q_min.popleft()
            #当窗口内只有一个质数时,l=last2+1,即恰好将倒数第二个质数排除在外
            #此时last2-l+1=0,不会影响结果
            ans+=last2-l+1
        return ans
```

**有序表+队列写法**

```python
N=50_000
p=[True]*(N+1)
p[0]=p[1]=False
for i in range(2,isqrt(N)+1):
    if p[i]:
        for j in range(i*i,N+1,i):
            p[j]=False
class Solution:
    def primeSubarray(self, nums: List[int], k: int) -> int:
        q=deque()
        s=SortedList()
        ans=l=0
        for r, x in enumerate(nums):
            if p[x]:
                q.append(r)
                s.add(x)
                while s[-1]-s[0]>k:
                    i=q.popleft()
                    s.remove(nums[i])
                    l=i+1
            if len(q)>=2:
                ans+=q[-2]-l+1
        return ans
```

