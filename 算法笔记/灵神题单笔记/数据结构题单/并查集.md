# 1.基础



# 2.进阶

**1970.你能穿过矩阵的最后一天**

网格图并查集

本题使用了洪水填充+时光倒流的写法,这是解决网格图问题的一种常用手段,常配合并查集或者dfs使用

陆地最后一天会全部被水淹没,如果从后往前遍历,最后一天就全是水域
我们的目标是第一行和最后一行连通,因此添加两个特殊点,源点和汇点
当遍历到第一行的点时,将其与源点合并,当遍历到最后一行的点时,将其与汇点合并
标记数组g初始化成二维数组,每个点的值都是False,代表是水域
对于cells[i],其在前一天还没被水淹没,是陆地,因此将其在g中标记成True
然后考虑这个点的四个邻居,如果下标不越界并且是陆地,则将其与当前点合并
如果发现源点1和汇点n+1连通,返回前一天作为答案,由于天数从1开始,cells下标从0开始,直接返回当前下标i即可
这种从后往前思考的方法是解决网格图问题的一种常用技巧,即洪水填充+时光倒流



数组并查集写法
使用数组并查集时,需要将二维下标映射到一维下标

```python
#1970(https://leetcode.cn/problems/last-day-where-you-can-still-cross/)
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        #将二维下标映射到一维下标,比如对于3*3矩阵,(1,1)映射到1,(2,3)映射到6
        def f(x,y):
            return (x-1)*col+y
        n=row*col
        #总共n个点,外加0作为源点,n+1作为汇点,因此并查集大小要开成n+2
        u=UnionFind(n+2)
        #g标记水域,由于我们倒序遍历,初始时刻全是水域,每个格点都是False
        #对于每个cells[i],其前一天没有被淹没,是陆地,因此遍历到cells[i]时,将其对应的点标记成True,即陆地
        g=[[False]*(col+1) for _ in range(row+1)]
        for i in range(len(cells)-1,-1,-1):
            x,y=cells[i]
            g[x][y]=True
            #如果格点在第一行,与源点合并
            if x==1:
                u.union(f(x,y),0)
            #如果格点在最后一行,与汇点合并
            if x==row:
                u.union(f(x,y),n+1)
            #将当前格点与周围的陆地点合并
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                nx,ny=x+dx,y+dy
                if 1<=nx<=row and 1<=ny<=col and g[nx][ny]:
                    u.union(f(x,y),f(nx,ny))
            #如果发现源点和汇点连通,返回前一天,由于天数从1开始,下标i从0开始,因此直接返回i
            if u.find(0)==u.find(n+1):
                return i


# 带标签和返回值的并查集,存储形式为数组
class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.cc = n

    def separate(self, x, y):
        self.father[x], self.father[y] = x, y
        self.cc += 1
```



哈希并查集+集合写法
原理和数组并查集类似,只不过并查集用哈希表实现,存储的是(x,y)坐标元组
源点,汇点分别用0,1代替
不需要将二维坐标转化成一维,同时用集合代替了二维标记数组

```python
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        u=UnionFind()
        for i in range(1,row+1):
            for j in range(1,col+1):
                u.father[(i,j)]=(i,j)
        u.father[0]=0
        u.father[1]=1
        s=set()
        for i in range(len(cells)-1,-1,-1):
            x,y=cells[i]
            s.add((x,y))
            if x==1:
                u.union((x,y),0)
            if x==row:
                u.union((x,y),1)
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                nx,ny=x+dx,y+dy
                if 1<=nx<=row and 1<=ny<=col and (nx,ny) in s:
                    u.union((x,y),(nx,ny))
            if u.find(0)==u.find(1):
                return i

#哈希并查集
class UnionFind:
    def __init__(self):
        self.father = {}

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        return True
```

思维扩展:二分答案解法

二分答案求最大

由于如果第k天连通,第k-1天也一定连通,具有单调性,因此可以二分
check函数写法为多源bfs,将第一行加入到队列中,然后看能否扩散到最后一行即可
可以发现,二分答案解决这种复杂问题有天然优势,思维难度也比上面解法低很多

```python
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        def f(k):
            g=[[1]*col for _ in range(row)]
            for x,y in cells[:k]:
                g[x-1][y-1]=0
            q=deque()
            for j,x in enumerate(g[0]):
                if x:
                    q.append((0,j))
                    g[0][j]=0
            while q:
                x,y=q.popleft()
                for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nx,ny=x+dx,y+dy
                    if 0<=nx<row and 0<=ny<col and g[nx][ny]:
                        if nx==row-1:
                            return False
                        g[nx][ny]=0
                        q.append((nx,ny))
            return True
        return bisect_left(range(0,row*col),True,key=f)-1
```

**1631.最小体力消耗路径**

网格图并查集

注意如果在网格图上使用数组并查集,需要将二维坐标转化成一维.

将相邻点的绝对值做差看成边权,将所有边权及其两个顶点加入数组进行排序.然后将这些边依次取出来,用并查集进行合并,同时更新最大权值,如果发现左上角顶点和右下角顶点连通,返回答案.

```python
#1631(https://leetcode.cn/problems/path-with-minimum-effort/)
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        n,m=len(heights),len(heights[0])
        tot=n*m
        u=UnionFind(tot)
        def f(x,y):
            return x*m+y
        edges=[]
        for i in range(n):
            for j in range(m):
                for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                    nx,ny=i+dx,j+dy
                    if 0<=nx<n and 0<=ny<m:
                        edges.append((abs(heights[nx][ny]-heights[i][j]),f(i,j),f(nx,ny)))
        edges.sort()
        ans=0
        for w,x,y in edges:
            u.union(x,y)
            ans=max(ans,w)
            if u.find(0)==u.find(tot-1):
                return ans
        return ans

# 带标签和返回值的并查集,存储形式为数组
class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.cc = n

    def separate(self, x, y):
        self.father[x], self.father[y] = x, y
        self.cc += 1
```



