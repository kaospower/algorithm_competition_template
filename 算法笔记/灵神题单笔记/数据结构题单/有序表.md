# 3510.移除最小数对使数组有序

```python
#3510(https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-ii/)
#双有序表
class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        sl=SortedList() #有序表,保存二元组,(相邻元素和,左边数的下标)
        idx=SortedList(range(len(nums))) #剩余下标
        dec=0 #递减的元素对的个数
        for i,(x,y) in enumerate(pairwise(nums)):
            if x>y:
                dec+=1
            sl.add((x+y,i))
        ans=0
        #一直执行操作直到递减对清0,这样整个数组就是非递减的
        while dec>0:
            ans+=1
            s,i=sl.pop(0)
            k=idx.bisect_left(i)
            #i,nxt分别代表合并前相邻的两个下标,合并后nxt会被删除,i被它们的和取代
            nxt=idx[k+1]
            if nums[i]>nums[nxt]:
                dec-=1
            #k>0说明pre存在
            if k>0:
                pre=idx[k-1]
                #如果pre>i,合并后i消失,递减元素对-1,dec-1
                if nums[pre]>nums[i]:
                    dec-=1
                #如果pre>s,产生一个新的递减元素对,dec+1
                if nums[pre]>s:
                    dec+=1
                #移除旧的对
                sl.remove((nums[pre]+nums[i],pre))
                #加上合并后产生新的对
                sl.add((nums[pre]+s,pre))
            #k+2<len(idx)说明nxt2存在
            if k+2<len(idx):
                nxt2=idx[k+2]
                #合并后nxt2消失,递减对-1,dec-1
                if nums[nxt]>nums[nxt2]:
                    dec-=1
                #合并后产生新的递减对,dec+1
                if s>nums[nxt2]:
                    dec+=1
                #移除旧的递减对
                sl.remove((nums[nxt]+nums[nxt2],nxt))
                #添加新的递减对
                sl.add((s+nums[nxt2],i))
            nums[i]=s
            idx.remove(nxt)
        return ans
```

