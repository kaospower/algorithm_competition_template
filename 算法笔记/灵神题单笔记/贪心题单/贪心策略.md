# 1.从最小/最大开始贪心

**核心技巧:关键字排序**

**小技巧:nsmallest/nlargest函数**

从最小/最大开始贪心,是最常见的贪心策略.这种贪心往往需要对原数组按照某种关键字进行排序,如数值/差/绝对值等等.

**2279.装满石头的背包的最大数量**

从最小开始贪心模版题

由于想尽可能装满背包,因此将容量和已经使用的容量做差,从小到大排序.之后依次装满每个背包即可

实现时有两种写法,一种是维护计数变量,不断增加,直到抵达阈值

也可以在原变量上不断减少,直到一个临界点

为了代码简洁,通常使用后面这种写法

```python
#2279(https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/description/)
class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], s: int) -> int:
        arr=sorted(x-y for x,y in zip(capacity,rocks))
        for i,x in enumerate(arr):
            if s<x:
                return i
            s-=x
        return i+1
```

**3010.将数组分成最小总代价的子数组I**

这道题经过分析,可以发现,我们要求出num[1:]中最小的两个值

常规想法可能是迭代求前2小,但是python的heapy库中提供了nsmallest方法,可以高效的求出前k小,同时该方法底层进行了优化,当k较小时,使用的不再是堆,而是更高效的方法.因此面对求前k小/前k大的问题,可以直接使用nsmallest/nlargest函数,这是这道题给我们的启发.

注:nsmallest(k,arr),求出数组中前k小,k参数要写在前面

```python
#3010(https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        n=len(nums)
        return nums[0]+sum(nsmallest(2,nums[1:]))
```

手动求前两小的写法

```python
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        n=len(nums)
        mn1=mn2=inf
        for i in range(1,n):
            #注意无需特判等于mn1的情况,当nums[i]>=mn1时,只需考虑其是否<mn2即可
            if nums[i]<mn1:
                mn1,mn2=nums[i],mn1
            elif nums[i]<mn2:
                mn2=nums[i]
        return nums[0]+mn1+mn2
```

**3301.高度互不相同的最大塔高和**

比较有意思的题,利用了高度的传递性.

题目要求塔高互不相同且每个塔都有高度上限,为了实现总高度最大,从高到矮安排塔.

设上一个塔的高度为limit,那么当前塔的高度不能超过limit-1

同时当位置塔的高度不能超过其本身上限,因此当位置的高度上限limit=min(limit-1,h)

如果发现limit==0,那么无法继续安排塔,返回-1

第一个塔之前没有塔,不受前一座塔的高度限制,因此limit初始设为inf

```python
#3301(https://leetcode.cn/problems/maximize-the-total-height-of-unique-towers/)
class Solution:
    def maximumTotalSum(self, arr: List[int]) -> int:
        arr.sort(reverse=True)
        ans,limit=0,inf
        for h in arr:
            limit=min(limit-1,h)
            if limit==0:return -1
            ans+=limit
        return ans
```

**2141.同时运行N台电脑的最长时间**

注意本题也可以用二分答案做,但贪心是最优解

将电池从大到小排序
先计算所有电池总电量s
t=s//n即为每个电脑可以运行时间的上界
遍历所有电池,如果当前电池电量x>t,将s减去x,同时n减去1,变成s-x电量供给n-1台电脑的子问题
如果当前电池电量x<=t,直接返回t

```python
#2141(https://leetcode.cn/problems/maximum-running-time-of-n-computers/)
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        batteries.sort(reverse=True)
        s=sum(batteries)
        for x in batteries:
            if x<=s//n:
                return s//n
            s-=x
            n-=1
```

# 2.单序列配对

# 3.双序列配对

# 4.从最左/最右开始贪心

从最右开始贪心
自底向上思考,对于每个非叶子节点,它的左右孩子到它的距离和应该相等
左右孩子cost差的绝对值就是应该增加的,同时将当前节点的cost增加左右孩子cost的最大值

```python
#2673(https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/?envType=problem-list-v2&envId=NYf6Nvxg)
class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:
        #注意cost下标从0开始
        ans=0
        #从最后一个非叶子节点遍历s
        for i in range(n//2,0,-1):
            ans+=abs(cost[2*i-1]-cost[2*i])
            cost[i-1]+=max(cost[2*i-1],cost[2*i])
        return ans
```

# 5.划分型贪心

# 6.先枚举,再贪心

# 7.交换论证法

交换论证法（exchange argument）用于证明一类贪心算法的正确性，也可以用来启发思考。做法如下:

1.对于题目，猜想按照「某种顺序」处理数据，可以得到最优解。

2.交换顺序中的两个元素 $a_i 和 a_j$，计算交换后的答案。

3.对比交换前后的答案。如果交换后，答案没有变得更优，则说明猜想成立。

**3273.对Bob造成的最少伤害**

通过尝试可以发现,最优消灭序列和敌人伤害及消灭敌人需要的时间都有关,比较复杂
因此需要使用交换论证法推导最优顺序
设当前有两个敌人i,j,i的伤害为di,消灭i需要的时间为ti,j的伤害为dj,消灭j需要的时间为tj
先处理i,后处理j受到的总伤害为:s1=ti\*di+ti\*dj+tj\*dj
先处理j,后处理i受到的总伤害为:s2=tj\*dj+tj\*di+ti\*di
如果先处理i受到的伤害更少,则有s1<s2,即ti\*di+ti\*dj+tj\*dj<tj\*dj+tj\*di+ti\*di
两边消去相同项,得到ti\*dj<tj\*di,即ti/di<tj/dj
因此需要按照t/d顺序从小到大排序

此题引申出复杂贪心的思考方式,值得反复思考

```python
#3273(https://leetcode.cn/problems/minimum-amount-of-damage-dealt-to-bob/?envType=problem-list-v2&envId=hgtpjpHr)
class Solution:
    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:
        n=len(damage)
        arr=[((h+power-1)//power,d) for d,h in zip(damage,health)]
        arr.sort(key=lambda p:p[0]/p[1])
        ans=s=0
        #一遍计算t的前缀和,一边更新每个敌人贡献的伤害
        for t,d in arr:
            s+=t
            ans+=d*s
        return ans  
```

**2895.最小处理时间**

此题贪心的严格证明

设当前有两个处理器,它们最早空闲时间分别为t1,t2,当前有两组任务,每组有4个任务,这两组的最大值分别为v1,v2

设t1<=t2,v1<=v2,如果将v1分配给t1,v2分配给t2,那么总时间为T1=max(t1+v1,t2+v2)=t2+v2

如果将v1分配给t2,v2分配给t1,那么总时间为T2=max(t1+v2,t2+v1),而t1+v2<=t2+v2,t2+v1<=t2+v2,因此T2=max(t1+v2,t2+v1)<=max(t2+v2,t2+v2)=t2+v2=T1,即T2<=T1

因此将大任务分配给空闲时间更早的处理器,总时间T更短

```python
#2895(https://leetcode.cn/problems/minimum-processing-time/)
class Solution:
    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        tasks.sort(reverse=True)
        processorTime.sort()
        return max(x+y for x,y in zip(processorTime,tasks[::4]))
```

# 8.相邻不同

## 1.计数型问题

如果数组以频数形式给出,则无需再用Counter计数,只需要求一下总和即可

比如频数数组[2,5,5],可以看成有三种不同的数,频数分别为2,5,5,比如[1,1,4,4,4,4,4,8,8,8,8,8]

这样就和标准的相邻不同问题一样了

**2335.装满杯子需要的最短总时间**

```python
#2335(https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/)
fmax=lambda x,y:x if x>y else y
class Solution:
    def fillCups(self, amount: List[int]) -> int:
        tot=sum(amount)
        return fmax((tot+1)//2,max(amount))
```

**1753.移除石子的最大得分**

```python
#1753(https://leetcode.cn/problems/maximum-score-from-removing-stones/)
fmin=lambda x,y:x if x<y else y
class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        tot=a+b+c
        m=max(a,b,c)
        return fmin(tot//2,tot-m)
```

## 2.构造型问题



# 9.反悔贪心

