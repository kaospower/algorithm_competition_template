# 1.从特殊到一般

# 2.脑筋急转弯

**2733.既不是最小值也不是最大值**

答案一定在前三个数当中

```python
#2733(https://leetcode.cn/problems/neither-minimum-nor-maximum/)
class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        return -1 if len(nums)<3 else sorted(nums[:3])[1]
```

**3432.统计元素和差值为偶数的分区方案**

如果nums总和是奇数,所有分割都不满足,返回0,否则,所有分割都符合题意,返回n-1

```python
#3432(https://leetcode.cn/problems/count-partitions-with-even-sum-difference/)
class Solution:
    def countPartitions(self, nums: List[int]) -> int:
        return 0 if sum(nums)&1 else len(nums)-1
```

**2680.最大或值**

本题核心在于贪心,将k次均摊到不同的数不如集中到一个数

因为集中到一个数可以使这个数变得更长更大
解决这点,计算前后缀的或和即可

```python
#2680(https://leetcode.cn/problems/maximum-or/description/?envType=problem-list-v2&envId=NYf6Nvxg)
class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        pre=list(accumulate(nums,or_))
        suf=list(accumulate(nums[::-1],or_))[::-1]
        n=len(nums)
        return max((pre[i-1] if i else 0)|x<<k|(suf[i+1] if i+1<n else 0) for i,x in enumerate(nums))
```

思维扩展,另一种空间复杂度更低的解法

如果能从所有数的或和all_or中去掉nums[i]的贡献,就可以省去求前后缀或和的步骤

首先尝试用all_or异或nums[i],这可能存在错误,因为可能其他位也有贡献

因此需要修正这个错误,如果至少两个数在同一个比特位出现1,那么这个位置就恒为1

恒为1的位是不会受异或操作影响的,因此fixed就是收集所有恒为1的位,即至少出现两次1的位

```python
class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        all_or=fixed=0
        for x in nums:
            #all_or&x中的1出现了两次,或到fixed中,这里用到了枚举右,维护左的思想
            fixed|=all_or&x
            all_or|=x
        return max((all_or^x)|fixed|(x<<k) for x in nums)
```

**2731.移动机器人**

两个机器人碰撞,可以看成两个机器人在碰撞点互换,然后继续按原来方向行动
由于机器人都是一样的,因此可以完全忽略碰撞,直接计算d秒后所有机器人的位置
然后用枚举右,维护左计数的方法计算答案即可

```python
#2731(https://leetcode.cn/problems/movement-of-robots/?envType=problem-list-v2&envId=NYf6Nvxg)
mod=1_000_000_007
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        nums=[x+(d if y=='R' else -d)for x,y in zip(nums,s)]
        nums.sort()
        s=ans=0
        for i,x in enumerate(nums):
            #i=0时,i*s-s是0,不会影响结果
            ans=(ans+i*x-s)%mod
            s+=x
        return ans
```

**2311.小于等于K的最长二进制子序列**

取最大的<=k的后缀,然后在前面尽可能补0

```python
class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        n,m=len(s),k.bit_length()
        if n<m:
            return n
        #注意int函数可以将二进制串转十进制
        ans=m if int(s[-m:],2)<=k else m-1
        return s[:-m].count('0')+ans
```

**3702.按位异或非零的最长子序列**

考虑全部元素的异或和,如果不为0,返回n,如果为0,剔除一个非0元素,结果为n-1,如果全为0,结果为0

```python
#3702(https://leetcode.cn/problems/longest-subsequence-with-non-zero-bitwise-xor/)
class Solution:
    def longestSubsequence(self, nums: List[int]) -> int:
        if all(x==0 for x in nums):
            return 0
        s=reduce(xor,nums)
        return len(nums)-(s==0)
```

**cf49d.game**

每次只能修改两个相邻且相同的位置,问多少次可以将原串变成01交替

想改成01交替,要么是0101...,要么是1010...

因此检查当前位置是否等于目标值即可

```python
#cf49d(https://codeforces.com/problemset/problem/49/D)
ans=sum(int(x)^i&1 for i,x in enumerate(a))
```

# 3.逆向思维

**3609.到达目标点的最小移动次数**

本题核心突破点是逆向考虑,可以发现只有几种固定情况,分类讨论即可

假设x>y,那么进行第一种操作,会变成2x,y,进行第二种操作,会变成x,x+y
注意到2x>y,x+y>x,即被操作的位置在操作完成后会变成两者中最大值
如果从(x,y)向前会退一步,只会让x和y中较大值发生变化
因此,只考虑x,y中较大值即可,如果x<y,交换x,y以及sx,sy的值,问题就转化成了x>y的情况
对于x=y的情况,其要么从(0,y)转移而来,要么从(x,0)转移而来,讨论sx,sy的初始值即可
对于x>y,看似有两种选择,即从x/2翻倍或者x-y加上y
但是仔细分析,可以发现
若选择翻倍,需要满足x/2>y,即x>2y
若选择加上y,需要满足x-y<y,即x<2y,这两种选择是互斥的
因此讨论x>2y和x<2y即可,x=2y算到任意一种情况都可以

```python
#3609(https://leetcode.cn/problems/minimum-moves-to-reach-target-in-grid/)
class Solution:
    def minMoves(self, sx: int, sy: int, x: int, y: int) -> int:
        ans=0
        while x!=sx or y!=sy:
            if x<sx or y<sy: #当前位置比初始位置还小
                return -1
            ans+=1
            if x==y:
                if sy>0:
                    x=0
                else:
                    y=0
                continue
            if x<y: #保证x>y
                x,y=y,x
                sx,sy=sy,sx
            if x>y*2:
                if x%2>0:
                    return -1
                x//=2
            else:
                x-=y
        return ans
```

# 4.等价转换

