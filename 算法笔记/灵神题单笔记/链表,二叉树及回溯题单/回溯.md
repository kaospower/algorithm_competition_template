# 1.入门回溯

# 2.子集型回溯

# 3.划分型回溯

# 4.组合型回溯

# 5.排列型回溯

# 6.有重复问题的回溯

# 7.搜索

爆搜+记忆化搜索(带路径递归),本质仍是回溯问题
注意本题不是dp,因为不满足无后效性,正确写法是带着乘积递归

cache承担爆搜算法哈希表的功能,用来记录一棵搜索树已经访问过的状态
本题可以用爆搜却不会超时是因为:
在乘积不为0且不超过limit的情况下,交错和的绝对值其实远小于nums的元素和,不同交错和的个数不超过1e3数量级,同时本题nums[i]最大只有12,150 个[1,12]中的数相乘,只有394个不同乘积,可以发现,其远远小于上限limit
为了减少状态数量,只能记录有效乘积状态,因此需要使用哈希表记录状态,python的@cache在本题中就承担了这种功能

```python
#3509(https://leetcode.cn/problems/maximum-product-of-subsequences-with-an-alternating-sum-equal-to-k/)
fmin=lambda x,y:x if x<y else y
fmax=lambda x,y:x if x>y else y
class Solution:
    def maxProduct(self, nums: List[int], k: int, limit: int) -> int:
        #可行性剪枝:nums总和都比abs(k)小,无法实现
        if sum(nums)<abs(k):
            return -1
        n=len(nums)
        #记录全局最优解
        ans=-1
        #i表示下标,s表示交错和,t表示乘积,odd表示奇偶性,empty表示当前选的子序列是否为空
        #odd为False,表示下一个要选的数是偶数下标,odd为True,表示下一个要选的数是奇数下标
        #odd初始为False,因为下标从0开始
        @cache
        def f(i,s,t,odd,empty):
            nonlocal ans
            #最优性剪枝
            #由于乘积最大为limit,因此如果ans已经可以取到limit,再次访问limit状态不会使ans变大
            #当乘积>limit时,唯一可能的合法状态是遇到0,此时乘积为0,因此如果ans已经为0,这种情况也不会使ans变大
            #因此这两种情况直接返回即可
            #搜索到一半发现该解法不如当前最优解,立即停止搜索,进行回溯,这种即为最优性剪枝
            if ans==limit or t>limit and ans>=0:
                return 
            #边界
            #选出的子序列如果满足交错和为k,子序列不空,并且乘积不超过limit,就更新最优解
            if i==n:
                if not empty and s==k and t<=limit:
                    ans=fmax(ans,t)
                return
            #选或不选当前元素
            #不选
            f(i+1,s,t,odd,empty)
            #选
            x=nums[i]
            #优化点,如果乘积>limit,一律视作limit+1,减少状态数量
            f(i+1,s+(-x if odd else x),fmin(t*x,limit+1),not odd,False)
        f(0,0,1,False,True)
        f.cache_clear()
        return ans
```

# 8.折半枚举



