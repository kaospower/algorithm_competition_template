# 1.判断质数

# 2.预处理质数(筛质数)

# 3.质因数分解

**2507.使用质因数之和替换后可以取到的最小值**

如果n是质数,n经过题目中处理不变
如果n不是质数,n不会变大,根据对勾函数性质,n只会变小

```python
#2507(https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/)
#注意本题时间复杂度为O(sqrt(n))
class Solution:
    def smallestValue(self, n: int) -> int:
        while True:
            x,s,i=n,0,2
            while i<=isqrt(x):
                while x%i==0:
                    s+=i
                    x//=i
                i+=1
            if x>1:s+=x #质因数分解到最后得到一个素数x,将x加到累加和s中s
            if s==n:return n #如果s==n,说明n经过处理后不变,即n为素数,返回n
            n=s
```

**3326.使数组非递减的最少除法操作次数**

预处理最小质因数LPF+从右到左贪心,和3301贪心方式类似

除以最大真因数,留下的就是最小质因子,因此预处理最小质因子即可

```python
#3326(https://leetcode.cn/problems/minimum-division-operations-to-make-array-non-decreasing/)
N=1_000_000
p=[0]*(N+1)
for i in range(2,N+1):
    if p[i]==0:
        for j in range(i,N+1,i):
            if p[j]==0:
                p[j]=i
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans=0
        for i in range(len(nums)-2,-1,-1):
            if nums[i]>nums[i+1]:
                nums[i]=p[nums[i]]
                if nums[i]>nums[i+1]:
                    return -1
                ans+=1
        return ans
```

**2584.分割数组使乘积互质**

欧拉筛预处理lpf+质因数分解+跳跃游戏

本题是一道相当经典的题,利用欧拉筛预处理lpf进行质因数分解,大大提高了解法效率

同时转化成跳跃游戏的思路也是妙不可言

处理出每个质因子对应的最左,最右位置
然后问题就转化成了有一系列区间[l,r],它们可能互相重叠,求分界点
分界点将所有区间分隔在两侧,即没有任何一个区间横跨分界点
直观做法是用区间贪心解决,即按照左端点排序,然后找分隔点,但是本题有更妙的解法
用55题跳跃游戏的思想解决这个问题
将区间[l,r]看成是从l可以向右跳跃,最多能跳到r
两个区间重叠,就代表从第一个区间的左端点可以跳到第二个区间的右端点
那么原问题就变成了你可以跳的最远位置
比如有三个区间[0,3],[2,5],[6,8],那么显然最远只能跳到5,因为[2,5]和[6,8]之间没有区间相连,无法跳跃
实际实现时,不需要分别记录每个质因子对应的区间
只需要用哈希表记录质因子p第一次出现的下标l,即左端点,以及左端点能到达的最远右端点
比如质因子2第一次出现在下标2,最后一次出现在下标5,质因子7第一次出现在下标2,最后一次出现在下标10
那么从2出发,最远可以跳到10,即right[2]=10
这样最终就得到一个right数组,right[i]=j表示从下标i出发最远可以跳到下标j
我们求从0出发最远可以跳到哪里即可,这显然和55题跳跃游戏是一样的

```python
#2584(https://leetcode.cn/problems/split-the-array-to-make-coprime-products/)
fmax = lambda x, y: x if x > y else y
#欧拉筛预处理lpf
N=1_000_000
lpf=[0]*(N+1)
primes=[]
for i in range(2,N+1):
    if lpf[i]==0:
        lpf[i]=i
        primes.append(i)
    for x in primes:
        if (j:=x*i)>=N+1:
            break
        lpf[j]=x
        if i%x==0:
            break
class Solution:
    def findValidSplit(self, nums: List[int]) -> int:
        left={} #left记录每个质因子第一次出现的下标,即最左下标
        right=[0]*len(nums)
        #遍历nums,对每个数分解质因子(这里利用lpf分解质因子,效率更高)
        for i,x in enumerate(nums):
            while lpf[x]:
                p=lpf[x]
                if p in left:
                    right[left[p]]=i
                else:
                    left[p] = i
                x//=lpf[x]
        #转化成跳跃游戏,复用55题代码即可
        max_r=0 #历史能跳跃到的最远位置
        for l,r in enumerate(right):
            if l>max_r: #当前下标>历史最远位置,后面都不可达,返回max_r
                return max_r
            max_r=fmax(max_r,r) #当前下标<=历史最远位置,可达,更新max_r为max(max_r,r)
        return -1
```

# 4.阶乘分解

# 5.因子

# 6.最大公约数

**1250.检查[好数组]**

裴蜀定理
对于不全为0的任意整数a,b,令g=gcd(a,b),则对于任意整数x,y都满足ax+by是g的倍数
特别地,存在整数x,y满足ax+by=g
裴蜀定理也可以拓展到n个数

如果nums的子集中的数a1,a2,a3,...,an的gcd=1,那么存在一些数x1,x2,...,xn
使a1x1+a2x2+...+anxn=g=1成立
即如果想得到这个等式,需要满足gcd(a1,a2...an)=1,如果满足这个条件,nums中所有数的gcd也为1
因此检验gcd(*nums)是否为1即可

```python
#1250(https://leetcode.cn/problems/check-if-it-is-a-good-array/)
class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        return gcd(*nums)==1
```

**365.水壶问题**

裴蜀定理
每次倒水变化量只能是x或者y,即ax+by=z,a,b分别代表对两个水壶执行的次数,z代表target
根据裴蜀定理,该方程有解当且仅当z是gcd(x,y)的倍数

```python
#365(https://leetcode.cn/problems/water-and-jug-problem/)
class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        #目标比两个水壶总量还大,返回False
        if x+y<z:
            return False
        #特判有水壶为0的情况,简洁写法
        if x==0 or y==0:
            return z==0 or x+y==z
        return z%gcd(x,y)==0
```

**2607.使子数组元素和相等**

中位数贪心+裴蜀定理
对于在同一个分组内的数,根据中位数贪心,将它们变成中位数需要的次数是最少的
根据题意可知周期为k的数是相等的,同时由于是循环数组,因此下标间隔为n的数也是相等的
因此a[i]=a[i+kx+ny],即下标加上若干周期k和若干间隔n得到的数和原数相等
根据裴蜀定理,可得出以下结论:对于一个长度为n的环,如果环上所有间隔为k的元素都要相等,那么环上所有间隔为gcd(n,k)的元素都要相等(证明见蛙佬题解)
因此将间隔gcd(n,k)的数分到一组,然后应用中位数贪心即可

```python
#2607(https://leetcode.cn/problems/make-k-subarray-sums-equal/)
class Solution:
    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:
        k = gcd(k, len(arr))
        ans = 0
        for i in range(k):
            #从下标i到n切片,步长为k
            b = sorted(arr[i::k])
            mid = b[len(b) // 2]
            ans += sum(abs(x - mid) for x in b)
        return ans  
```

**1625.执行操作后字典序最小的字符串**

```python
#1625(https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/)
#裴蜀定理
fmin=lambda x,y:x if x<y else y
class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        #将字符串转化成整数数组
        s=list(map(int,s))
        n=len(s)
        #step代表轮转步长
        step=gcd(b,n)
        #g代表不轮转执行加法时的步长
        g=gcd(a,10)
        ans=[inf] #ans是字符串数组
        def modify(start):
            ch=t[start]
            inc=ch%g-ch
            #当inc不为0时,对所有奇数位置的数都加上inc
            if inc:
                for j in range(start,n,2):
                    t[j]=(t[j]+inc)%10
        for i in range(0,n,step):
            t=s[i:]+s[:i]
            modify(1)
            if step%2:
                modify(0)
            ans=fmin(ans,t)
        return ''.join(map(str,ans))
```

# 7.最小公倍数

# 8.互质

# 9.同余

