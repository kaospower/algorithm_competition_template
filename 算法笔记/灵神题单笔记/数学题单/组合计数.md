# 1.乘法原理

# 2.组合计数

# 3395.唯一中间众数子序列I

容斥原理+前后缀分解+枚举+组合计数+乘法原理,O(n^2)

合法序列不好求,考虑求不合法序列数量t,然后用总序列数量减去t就是答案

实际实现时枚举中间,然后讨论两侧情况即可

```python
#3395(https://leetcode.cn/problems/subsequences-with-a-unique-middle-mode-i/)
mod=1_000_000_007
class Solution:
    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:
        n=len(nums)
        #总方案数即C(n,5)
        ans=comb(n,5)
        #前后缀哈希表
        suf,pre=Counter(nums),Counter()
        #枚举中间数字出现次数,如果中间数字出现>=3次,一定合法
        #不合法的是,中间数字只出现一次,以及中间数字出现两次,同时另一个数字也出现两次,用总数减去不合法的就是合法的
        for l,x in enumerate(nums[:-2]):
            suf[x]-=1
            if l>=2:
                r,px,sx=n-l-1,pre[x],suf[x]
                #中间数字只出现1次,即两侧的两个数都不等于x
                ans=(ans-comb(l-px,2)*comb(r-sx,2))%mod
                #中间数字x只出现两次,设另一个出现两次的数字为y
                #枚举y,注意suf的key涵盖nums中所有数,只不过有些数的value清0了,但是key还是存在
                for y,sy in suf.items():
                    if y!=x:
                        py=pre[y]
                        #有以下四种情况
                        #情况1:yy|x|x,左边两个y,右边一个x,右边第二个数可以等于y
                        ans=(ans-comb(py,2)*sx*(r-sx))%mod
                        #情况2:x|x|yy,右边两个y,左边一个x,左边第二个数可以等于y
                        ans=(ans-comb(sy,2)*px*(l-px))%mod
                        #情况3:yx|x|y,左右各有一个y,左边第二个数为x,右边第二个数不等于y,否则和上面情况2重复
                        ans=(ans-py*sy*px*(r-sx-sy))%mod
                        #情况4:y|x|xy,左右各有一个y,右边第二个数为x,左边第二个数不等于y,否则和上面情况1重复
                        ans=(ans-py*sy*sx*(l-px-py))%mod     
            pre[x]+=1
        return ans
```

思维扩展

解法2:利用数学变换优化成O(n)
即将表达式拆分化简,本质是基于前缀和的优化

```python
mod=1_000_000_007
class Solution:
    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:
        n=len(nums)
        ans=comb(n,5)
        suf,pre=Counter(nums),defaultdict(int) #defaultdict(int)比Counter更快
        #cp表示C(py,2)求累加和,ps表示py*sy求累加和,p2s=(py)^2*sy求累加和,ps2=py*(sy)^2求累加和
        cp=ps=p2s=ps2=0
        #cs表示C(sy,2)求累加和
        cs=sum(comb(x,2) for x in suf.values())
        for l,x in enumerate(nums[:-2]):
            suf[x]-=1
            r,px,sx=n-l-1,pre[x],suf[x]
            cs-=sx
            ps-=px
            p2s-=px*px
            ps2-=(2*sx+1)*px
            ans=(ans-comb(l-px,2)*comb(r-sx,2))%mod

            ans=(ans-(cp-comb(px,2))*sx*(r-sx))%mod
            ans=(ans-(cs-comb(sx,2))*px*(l-px))%mod
            ans=(ans-px*((r-sx)*(ps-px*sx)-(ps2-px*sx*sx)))%mod
            ans=(ans-sx*((l-px)*(ps-px*sx)-(p2s-px*px*sx)))%mod

            cp+=px
            ps+=sx
            ps2+=sx*sx
            p2s+=(2*px+1)*sx
            pre[x]+=1
        return ans
```

# 3518.最小回文排列II

```python
#3518(https://leetcode.cn/problems/smallest-palindromic-rearrangement-ii/)
#试填法+组合数学
fmin=lambda x,y:x if x<y else y
class Solution:
    def smallestPalindrome(self, s: str, k: int) -> str:
        n=len(s)
        #只考虑字符串前半部分
        m=n//2
        cnt=[0]*26
        for b in s[:m]:
            cnt[ord(b)-ord('a')]+=1
        #组合数公式
        #C(n,m)=n!/(m!*(n-m)!)
        def comb(n,m):
            m=fmin(m,n-m)
            res=1
            for i in range(1,m+1):
                res=res*(n+1-i)//i
                if res>=k:
                    return k
            return res
        #计算长度为sz的字符串的排列个数
        def perm(sz):
            res=1
            for c in cnt:
                if c==0:
                    continue
                res*=comb(sz,c)
                if res>=k:
                    return k
                sz-=c
            return res
        #k太大,返回空串
        if perm(m)<k:
            return ""
        #构造回文串的左半部分
        left_s=['']*m
        for i in range(m):
            for j in range(26):
                if cnt[j]==0:
                    continue
                cnt[j]-=1
                p=perm(m-i-1)
                if p>=k:
                    left_s[i]=ascii_lowercase[j]
                    break
                k-=p
                cnt[j]+=1
        ans=left_s=''.join(left_s)
        if n&1:
            ans+=s[n//2]
        return ans+left_s[::-1]
```

