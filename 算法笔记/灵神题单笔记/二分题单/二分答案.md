# 1.求最小

**1631.最小体力消耗路径**

注意本题最优解是网格图Dijkstra

当答案为k时,代表相邻点绝对差不能超过k,因此从左上角开始dfs爆搜
只访问和自己绝对差<=k的邻居,看能否到达右下角
由于本题是找最小答案,因此如果能以k体力值到达右下角,返回True

```python
#1631(https://leetcode.cn/problems/path-with-minimum-effort/)
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        n,m=len(heights),len(heights[0])
        def check(k):
            vis=[[False]*m for _ in range(n)]
            vis[0][0]=True
            def f(x,y):
                if x==n-1 and y==m-1:
                    return True
                for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                    nx,ny=x+dx,y+dy
                    if 0<=nx<n and 0<=ny<m and not vis[nx][ny] and abs(heights[nx][ny]-heights[x][y])<=k:
                        vis[nx][ny]=True
                        if f(nx,ny):
                            return True
                return False
            return f(0,0)
        return bisect_left(range(1_000_000),True,key=check)
```

# 2.求最大

**1970.你能穿过矩阵的最后一天**

注意本题最优解是并查集

二分检查第k天第一行和最后一行是否连通
检查方式为多源bfs,将第一行加入到队列中,然后看能否扩散到最后一行即可

由于本题是求最大答案,因此如果连通返回False,不连通返回True,搜索第一个不连通的天数,然后减去1即是答案

可以发现,二分答案解决这种复杂问题有天然优势,思维难度也比上面解法低很多

```python
#1970(https://leetcode.cn/problems/last-day-where-you-can-still-cross/)
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        def f(k):
            g=[[1]*col for _ in range(row)]
            for x,y in cells[:k]:
                g[x-1][y-1]=0
            q=deque()
            for j,x in enumerate(g[0]):
                if x:
                    q.append((0,j))
                    g[0][j]=0
            while q:
                x,y=q.popleft()
                for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nx,ny=x+dx,y+dy
                    if 0<=nx<row and 0<=ny<col and g[nx][ny]:
                        if nx==row-1:
                            return False
                        g[nx][ny]=0
                        q.append((nx,ny))
            return True
        return bisect_left(range(0,row*col),True,key=f)-1
```

**2861.最大合金数**

二分答案求最大
注意题目中说明所有合金都需要由同一台机器制造
check函数检查是否能造t个合金即可

```python
#2861(https://leetcode.cn/problems/maximum-number-of-alloys/)
fmax=lambda x,y:x if x>y else y
class Solution:
    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:
        #检查是否能制造t个合金
        def f(t):
            for x in composition:
                s=0
                for y,z,c in zip(x,stock,cost):
                    s+=fmax(y*t-z,0)*c
                    #可行性剪枝,如果当前费用>budget,说明当前机器不可行,直接break
                    if s>budget:
                        break
                #由于是求最大,因此如果当前数量t可行,返回False
                if s<=budget:
                    return False
            return True
        return bisect_left(range(budget+min(stock)+1),True,key=f)-1
```

**2141.同时运行N台电脑的最长时间**

二分答案求最大

当前目标为运行k分钟,每个电池最多可以供电时间为min(batteries[i],x)

对所有电池的供电时间求和,如果其>=n*k,那么可以完成运行k分钟的目标

由于是求最大,因此满足目标时返回False

```python
#2141(https://leetcode.cn/problems/maximum-running-time-of-n-computers/)
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        def f(k):
            return n*k>sum(min(x,k) for x in batteries)
        return bisect_left(range(sum(batteries)//n+1),True,key=f)-1
```

思维拓展:贪心解法

从最大开始贪心,将电池从大到小排序,先计算所有电池总电量s,t=s//n即为每个电脑可以运行时间的上界
遍历所有电池,如果当前电池电量x>t,将s减去x,同时n减去1,变成s-x电量供给n-1台电脑的子问题
如果当前电池电量x<=t,直接返回t

```python
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        batteries.sort(reverse=True)
        s=sum(batteries)
        for x in batteries:
            if x<=s//n:
                return s//n
            s-=x
            n-=1
```

**2258.逃离火灾**

网格图多源bfs+二分

核心是双扩散型多源bfs,套一个二分,注意右下角的特殊处理方式

```python
#2258(https://leetcode.cn/problems/escape-the-spreading-fire/)
class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        n,m=len(grid),len(grid[0])
        #二分check函数,判断等待k分钟是否可行
        def check(k):
            #等价于深拷贝,但是速度更快,也可以写成g=[row[:] for row in grid]
            g=list(map(list,grid))
            #等k分钟意味着火扩散k圈,用bfs模拟即可
            q=deque()
            for i,row in enumerate(g):
                for j,x in enumerate(row):
                    if x==1:
                        q.append((i,j))
            for _ in range(k):
                size=len(q)
                if size==0:
                    break
                for _ in range(size):
                    x,y=q.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m and g[nx][ny]==0:
                            g[nx][ny]=1
                            q.append((nx,ny))
            #每次火先走一圈,然后人再走,这样保证下一步走的地方不会被烧到
            #同时走过的位置标记成3,防止重复访问
            #注意右下角的位置需要特殊处理,因为人到达右下角就不怕火烧了
            #因此需要记录火到达右下角的时间,人到达右下角时间<=火到达右下角的时间时,说明这个k可行
            p=deque([(0,0)])
            t=0
            flag=inf
            while p:
                size=len(q)
                #火先走,这些位置人不能走,否则下一分钟会被烧到,0,3都是草地
                for _ in range(size):
                    x,y=q.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m and (g[nx][ny]==0 or g[nx][ny]==3):
                            if nx==n-1 and ny==m-1:
                                flag=t
                            g[nx][ny]=1
                            q.append((nx,ny))
                #人后走
                size=len(p)
                for _ in range(size):
                    x,y=p.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m:
                            if nx==n-1 and ny==m-1:
                                return flag<t
                            if g[nx][ny]==0:
                                g[nx][ny]=3
                                p.append((nx,ny))
                t+=1
            return True
        return bisect_left(range(1_000_000_001),True,key=check)-1
```

思维扩展

通过两次多源bfs解决

两次bfs,第一遍计算人到每个点的时间,第二遍计算火到每个点的时间
由于右下角情况比较复杂,因此需要分情况考虑
情况1:
对于右下角点的两个邻点a(n-1,m-2)和b(n-2,m-1)之一,人比火先到,这样人火可以同时到右下角
这时返回人和火到达右下角的时间差d=tf-tp即可
情况2:
火会同时烧到a,b点,如果继续等,右下角会被火包围,人无法到达
因此这种情况只能等d-1分钟

```python
class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        n,m=len(grid),len(grid[0])
        #多源bfs,q代表起点集合
        def bfs(q):
            vis=[[-1]*m for _ in range(n)]
            for x,y in q:
                vis[x][y]=0
            t=1
            while q:
                size=len(q)
                for _ in range(size):
                    x,y=q.popleft()
                    for dx,dy in [(1,0),(-1,0),(0,-1),(0,1)]:
                        nx,ny=x+dx,y+dy
                        if 0<=nx<n and 0<=ny<m and grid[nx][ny]==0 and vis[nx][ny]<0:
                            vis[nx][ny]=t
                            q.append((nx,ny))
                t+=1
            #返回值为三个,第一个为bfs到达右下角的时间,第二,第三为bfs到达右下角两个邻居的时间
            return vis[-1][-1],vis[-1][-2],vis[-2][-1]
        #人先走一遍bfs
        qp=deque([(0,0)])
        tp,p1,p2=bfs(qp)
        if tp<0: #人无法走到右下角
            return -1
        qf=deque([(i,j) for i,row in enumerate(grid) for j,x in enumerate(row) if x==1])
        tf,f1,f2=bfs(qf)
        if tf<0: #火无法烧到右下角
            return 1_000_000_000
        d=tf-tp
        if d<0: #火比人先到安全屋
            return -1
        #情况1
        if p1!=-1 and p1+d<f1 or p2!=-1 and p2+d<f2:
            return d
        #情况2
        return d-1
        
```



# 3.二分间接值

**3143.正方形中的最多点数**

二分间接值
本题直接二分数量不好操作,二分边长一半更简单

同时本题用到了在check函数中更新全局变量的技巧

```python
#3143(https://leetcode.cn/problems/maximum-points-inside-the-square/)
class Solution:
    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
        ans=0
        #用全局变量维护最值
        #在二分同时更新全局变量
        def f(k):
            d=set()
            for (x,y),z in zip(points,s):
                if abs(x)<=k and abs(y)<=k:
                    if z in d:
                        return True
                    d.add(z)
            nonlocal ans
            ans=len(d)
            return False
        bisect_left(range(1_000_000_001),True,key=f)
        return ans
```

思维拓展

维护最小,次小切比雪夫距离的解法
一个点x,y是否在以原点为中心的正方形内,取决于其横纵坐标到原点(0,0)距离的最大值
即max(abs(x-0),abs(y-0))=max(abs(x),abs(y)),即(x,y)到(0,0)的切比雪夫距离
由于每种标签都只能保留一个,即不能取到次小的,每种标签都有自己的次小切比雪夫距离
实际实现时,无需单独维护每种标签切比雪夫距离的最小值,直接维护总的最小值即可
设所有标签的次小切比雪夫距离的最小值为min_d2,维护min_d2
最后遍历一遍每种标签的最小切比雪夫距离x,如果x<min_d2,那么这个点可以计入答案

```python
fmax=lambda x,y:x if x>y else y
fmin=lambda x,y:x if x<y else y
class Solution:
    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
        min_d=defaultdict(lambda:inf)
        min_d2=inf
        for (x,y),z in zip(points,s):
            d=fmax(abs(x),abs(y))
            #当前点距离<其对应标签的最小切比雪夫距离
            #更新min_d2,同时更新min_d[z]
            if d<min_d[z]:
                min_d2=fmin(min_d2,min_d[z])
                min_d[z]=d
            ##当前点距离>=其对应标签的最小切比雪夫距离
            #更新次小切比雪夫距离
            else:
                min_d2=fmin(min_d2,d)
        return sum(d<min_d2 for d in min_d.values())
```

**1648.销售价值减少的颜色球**

本题直观想法就是贪心,但是贪心实现起来比较复杂,贪心+二分答案的写法就简单一些

二分check函数参数为k,同时维护全局变量ans更新答案
对于每种颜色的球,只卖出数量>k的那部分,比如当前颜色有x个球,就卖掉x-k个球
计算这些球的数量和s,如果s>orders,直接返回False
否则,对于数量>=k的组,每组各拿出最多一个,看能否凑到orders-s
如果能凑到,更新ans,返回True,否则直接返回True
ans实际最多更新两次,从y轴扫描线的角度来看,即最优选择上面那条线和最优选择这条线

```python
#1648(https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/)
mod=1_000_000_007
fmax=lambda x,y:x if x>y else y
class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        ans=0
        def f(k):
            res=s=t=0
            for x in inventory:
                if x>k:
                    s+=x-k
                    if s>orders:
                        return False
                    res=(res+(x+k+1)*(x-k)//2)%mod
                if x>=k:
                    t+=1
            left=orders-s
            if left>t:
                return True
            nonlocal ans
            ans=(res+left*k)%mod
            return True
        bisect_left(range(max(inventory)),True,key=f)
        return ans
```

# 4.最小化最大值

**410.分割数组的最大值**

本题是二分答案求最小化最大值模版题

```python
#410(https://leetcode.cn/problems/split-array-largest-sum/)
class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        #二分check函数,检查是否能将数组分成k段,且所有段和的最大值<=mx
        #实际实现时采用贪心的方法,即每段在不超过mx的情况下和尽可能大
        #最后检查分成的段数是否超过k
        #由于段数分的越多,所有子段最大和越小
        #因此如果分成t段,满足子段最大和<=mx,那么分成>t段,也一定满足这个条件
        def f(mx):
            cnt=1
            s=0
            for x in nums:
                if s+x<=mx:
                    s+=x
                    continue
                if cnt==k:
                    return False
                cnt+=1
                s=x
            return True
        return bisect_left(range(sum(nums)),True,lo=max(nums),key=f)
```

思维拓展

划分型dp解法

```python
#约束型划分型dp,O(k(n-k)^2)
fmax = lambda x, y: x if x > y else y
fmin = lambda x, y: x if x < y else y
class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        def solve(nums,K):
            n=len(nums)
            f=[[inf]*(n+1) for _ in range(K+1)]
            f[0][0]=0
            for k in range(1,K+1):
                for i in range(k,n-(K-k)+1):
                    s=0
                    ans=inf
                    for j in range(i-1,k-2,-1):
                        s+=nums[j]
                        ans=fmin(ans,fmax(s,f[k-1][j]))
                    f[k][i]=ans
            return f[-1][-1]
        return solve(nums,k)
```

# 5.最大化最小值

**3600.升级后最大生成树稳定性**

```python
#3600(https://leetcode.cn/problems/maximize-spanning-tree-stability-with-upgrades/)
#二分答案求最大化最小+并查集
fmin=lambda x,y:x if x<y else y
fmax=lambda x,y:x if x>y else y
class Solution:
    def maxStability(self, n: int, edges: List[List[int]], k: int) -> int:
        all_uf=UnionFind(n) #全图并查集
        must_uf=UnionFind(n) #必选边并查集
        min_s,max_s=inf,0
        #先遍历一遍所有边,看必须边是否成环以及全图是否连通
        #同时记录边权的上下界
        for u,v,s,must in edges:
            if must and not must_uf.union(u,v): #必选边成环
                return -1 
            all_uf.union(u,v)
            min_s,max_s=fmin(min_s,s),fmax(max_s,s)
        if all_uf.cc>1: #全图不连通
            return -1
        #二分check函数
        def f(low):
            a=UnionFind(n)
            #遍历所有边
            for u,v,s,must in edges:
                #如果边必选并且<下界,说明该下界取小了不成立,返回
                #由于使用bisect_left api求最大值,因此不成立返回True
                if must and s<low:
                    return True
                #如果边权>=上界,合并
                if s>=low:
                    a.union(u,v)
            #需要修改外部变量,拷贝一份
            left_k=k
            #现在考虑非必选且强度<low的边
            for u,v,s,must in edges:
                #如果left_k==0,说明无法通过翻倍来使边权>low,break
                #如果a.cc==1,说明已经连通了,break
                if left_k==0 or a.cc==1:
                    break
                #如果能通过翻倍使强度不够的边>low,就翻倍,同时left_k-1
                if 2*s>=low and a.union(u,v):
                    left_k-=1
            #合法情况是a.cc=1,由于求最大值,因此当不合法时返回True,即a.cc>1时返回True
            return a.cc>1
        #二分下界是最小边权,上界是最大边权*2
        return bisect_left(range(max_s*2+1),True,lo=min_s,key=f)-1

class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.cc = n

    def separate(self, x, y):
        self.father[x], self.father[y] = x, y
        self.cc += 1
```

思维拓展:Kruskal解法

```python
fmin=lambda x,y:x if x<y else y
class Solution:
    def maxStability(self, n: int, edges: List[List[int]], k: int) -> int:
        all_uf=UnionFind(n) #全图并查集
        must_uf=UnionFind(n) #必选边并查集
        min_s=inf #min_s记录必选边最小边权
        #先遍历一遍所有边,看必须边是否成环以及全图是否连通
        #同时记录边权的上下界
        for u,v,s,must in edges:
            if must:
                if not must_uf.union(u,v): #必选边成环
                    return -1
                min_s=fmin(min_s,s)
            all_uf.union(u,v)
        if all_uf.cc>1: #全图不连通
            return -1
        if must_uf.cc==1: #只需要选必选边
            return min_s
        #按照边权从大到小排序
        edges.sort(key=lambda p:-p[2])
        a=[]
        #现在考虑非必选要翻倍的边
        for u,v,s,must in edges:
            #必选边都合并过了,因此如果union(u,v)返回True,合并的一定是非必选边
            if must_uf.union(u,v):
                a.append(s)
        #答案为以下三者的最小值
        #1.必选边最小边权
        #2.a中最小边权*2
        #3.非必选边权中的第k+1小边权(我们可以将最小的k条边翻倍,然后将ans和a[-1-k]取min)
        ans=fmin(min_s,a[-1]*2)
        if k<len(a):
            ans=fmin(ans,a[-1-k])
        return ans

class UnionFind:
    def __init__(self, n):
        self.father = list(range(n))
        self.cc = n

    def find(self, i):
        if i != self.father[i]:
            self.father[i] = self.find(self.father[i])
        return self.father[i]

    def union(self, x, y):
        fx, fy = self.find(x), self.find(y)
        if fx == fy:
            return False
        self.father[fx] = fy
        self.cc -= 1
        return True

    def reset(self):
        n = len(self.father)
        self.father = list(range(n))
        self.cc = n

    def separate(self, x, y):
        self.father[x], self.father[y] = x, y
        self.cc += 1
```

# 6.第k小/大

