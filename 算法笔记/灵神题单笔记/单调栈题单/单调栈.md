# 1.基础

# 2.进阶

**1019.链表的下一个更大节点**

此题很容易看出是单调栈,但是常规做法是需要初始化一个长度为n的数组,不存在的赋成题目给定的值.

朴素做法是两次遍历,第一次计算链表长度,第二次用单调递增栈解决.

另一种解法是一次遍历,每遍历到一个新的位置,用0占位,这样在赋值时就不会越界,也不需要知道链表长度,是一种比较巧妙的做法.

```python
#1019(https://leetcode.cn/problems/next-greater-node-in-linked-list/)
class Solution:
    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:
        ans=[]
        st=[]
        while head:
            t=head.val
            while st and t>st[-1][1]:
                ans[st.pop()[0]]=t
            st.append((len(ans),t))
            ans.append(0)
            head=head.next
        return ans
```

**3113.边界元素是最大值的子数组数目**

这道题反映了高难度的单调栈的一个特点,即在栈中保存多种信息,除了基本的值,位置信息,还可以保存出现次数.

此题是寻找子数组,子数组左右端点要相等,并且左右端点之间的数要<=端点值,很明显目标是寻找一个数右侧最近且大于等于它的数,且要取等.这可以使用单调递增栈解决.实际实现时,由于是子数组计数,考虑枚举右端点,左端点可能的位置.对于相等的数,没有必要将其重复加入到栈中,直接将其次数+1即可.当栈顶元素和当前数大小相同时,ans加上该数出现次数,然后将次数+1,即典型的枚举右,维护左计数思想.

换个角度,实际本题就是求满足a[i]=a[j],且i~j之间的数均<=a[i]的(i,j)数对数量.而求数对数量这是经典的枚举右,维护左问题.

注意:本题也可以用开点线段树或者并查集解决.

```python
#3113(https://leetcode.cn/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/?envType=problem-list-v2&envId=hgtpjpHr)
class Solution:
    def numberOfSubarrays(self, nums: List[int]) -> int:
        ans=len(nums) #答案初始化为len(nums),因为所有长度为1的子数组都满足题意
        #初始化时在栈底添加一个哨兵,从而后续无需检查栈是否为空
        #栈中保存二元组,第一维表示值,第二维表示值出现的次数
        #注意这里使用的是list而不是tuple,因为tuple不能修改
        st=[[inf,0]]
        for x in nums:
            while x>st[-1][0]:
                st.pop()
            #当前数等于栈顶元素,由于st[-1][1]表示的是等于栈顶元素的值v在左侧出现的次数j
            #因此以当前数为右端点,值v为左端点,可以形成j个子数组
            #同时次数j+1
            if st[-1][0]==x:
                ans+=st[-1][1]
                st[-1][1]+=1
            #不等,则在栈中加入当前元素,次数为1
            else:
                st.append([x,1])
        return ans
```

**456.132模式**

此题有多种解法,前后缀分解是比较容易想的,这里不再赘述,着重讲单调栈解法

本题其实与3113题有异曲同工之处,都是在栈里维护额外的信息

正难则反,反向思考,题目寻找132,我们可以先寻找32,再寻找1,即枚举2,寻找2左侧最近的大于它的数,即3,同时看3左侧是否存在小于2的数,即1

这样通过单调栈找左侧最近最大,同时维护前缀最小,即可解决问题

```python
min=lambda x,y:x if x<y else y
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        mn=inf
        #单调递增栈,初始化时加上哨兵,这样就不用检验栈是否为空
        #第一维存储值,第二维存储这个值之前的最小值
        #即如果栈顶元素下标为j,值为v,第一维度存储v,第二维存储[0,j)范围内的最小值
        st=[(inf,inf)]
        for x in nums:
            #如果当前值>=栈顶值,弹出
            while x>=st[-1][0]:
                st.pop()
            #此时栈顶元素即为当前元素左侧最近的大于它的值
            #此时检查栈顶第二维度的值是否<当前值,如果小于则找到合法答案
            if st[-1][1]<x:
                return True
            #注意先将元素加入栈,后更新最小值
            st.append((x,mn))
            mn=min(mn,x)
        return False
```

**654.最大二叉树**
维护单调递增栈,如果当前元素大于栈顶元素,那么栈顶需要弹出,最后一个被弹出的元素就是当前节点的左孩子
为了方便实现,每次弹出操作时都重新修改当前元素的左孩子
在弹出操作结束后,如果栈不为空,那么栈顶元素的右孩子即为当前遍历到的元素
最后返回栈底元素即为根节点

此题实现是比较巧妙的,值得反复揣摩

```python
#654(https://leetcode.cn/problems/maximum-binary-tree/)
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        st=[]
        tree=[TreeNode(x) for x in nums]
        for i,x in enumerate(nums):
            while st and x>nums[st[-1]]:
                tree[i].left=tree[st.pop()]
            if st:
                tree[st[-1]].right=tree[i]
            st.append(i)
        return tree[st[0]]
```

**1944.队列中可以看到的人数**

单调递增栈
0～n-2位置答案初始化化成1,n-1位置答案初始化成0
因为每个人一定可以看到他右边的人,最后一个人右边没人,所以是0
如果当前元素大于栈顶元素,弹出栈顶元素,同时栈顶元素对应的答案+1
栈内元素单调递增的性质使得每个弹出的元素一定能看见当前元素

```python
#1944(https://leetcode.cn/problems/number-of-visible-people-in-a-queue/)
class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        st=[]
        n=len(heights)
        ans=[1]*n
        ans[-1]=0
        for i,x in enumerate(heights):
            while st and x>heights[st[-1]]:
                st.pop()
                if st:
                    ans[st[-1]]+=1
            st.append(i)
        return ans
```

**2866.美丽塔II**
枚举峰值,考虑左右两侧最值
枚举中间然后进行前后缀分解是很容易想到的
难点在于如何高效地计算出递增前缀
由于要求单调递增前缀,因此可以用单调递减栈来实现
如果当前元素小于栈顶元素,弹出
如果栈中还有元素,pre[i]更新为栈顶元素的pre加上当前元素和栈顶元素之差
否则,pre[i]更新为当前位置前面的位置数*当前值

```python
#2866(https://leetcode.cn/problems/beautiful-towers-ii/description/)
class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:
        n=len(maxHeights)
        def f(arr):
            pre=[0]*n
            st=[]
            for i,x in enumerate(arr):
                while st and x<arr[st[-1]]:
                    st.pop()
                pre[i]+=(i-st[-1])*x+pre[st[-1]] if st else (i+1)*x
                st.append(i)
            return pre
        ans=0
        pre,suf=f(maxHeights),f(maxHeights[::-1])[::-1]
        for l,r,x in zip(pre,suf,maxHeights):
            ans=max(ans,l+r-x)
        return ans
```

**2454.下一个更大元素IV**

这道题的启发就是,当一个单调栈不足以解决问题时,就再引入一个,用双单调栈解决问题

如果是寻找第一大整数,可以想到用单调递增栈维护
本题是寻找第二大整数,即如果有两个位置i,j(i<j)对应的数都大于x,那么x的第二大数就是j
相当于对于同一个数x,要找两次比它大的数,且这两次位置不能一样
因此可以用两个单调递增栈维护
第二个单调栈存储的数,均满足:之前已经发现其右侧有一个比它更大的数
如果当前数比第二个栈中的数大,就意味着它们找到了第二个比它更大的数,弹出,结算答案
之后再检查当前数是否比第一个栈中的数大,如果是,就转移到第二个栈
为了在转移后仍保持栈后进先出的性质,需要借助一个辅助数组或者一个辅助指针

**双单调递增栈+辅助数组**

```python
#2454(https://leetcode.cn/problems/next-greater-element-iv/)
class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        n=len(nums)
        ans=[-1]*n
        st1,st2,tmp=[],[],[]
        for i,x in enumerate(nums):
            while st2 and x>nums[st2[-1]]:
                ans[st2.pop()]=x
            while st1 and x>nums[st1[-1]]:
                tmp.append(st1.pop())
            while tmp:
                st2.append(tmp.pop())
            st1.append(i)
        return ans
```

**双单调递增栈+指针维护弹出元素的下界**

```python
class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        n=len(nums)
        ans=[-1]*n
        st1,st2=[],[]
        for i,x in enumerate(nums):
            while st2 and x>nums[st2[-1]]:
                ans[st2.pop()]=x
            j=len(st1)-1
            while j>=0 and x>nums[st1[j]]:
                j-=1
            st2+=st1[j+1:]
            del st1[j+1:]
            st1.append(i)
        return ans
```

**2289.使数组按非递减顺序排列**

本题思维难度是比较大的

用到了和456题一样的技巧,即在单调栈中维护额外信息,本题是维护一个数在几轮后会被删除,即最大轮数

注意到,如果一个数左侧存在比其大的数,那么这个数就一定要被删除,不同数被删除的时间不尽相同,有的第1轮就被删除,有的若干轮之后才被删除

因此需要用单调递增栈维护左侧大于当前数的位置,同时需要维护一个数在几轮后会被删除,称其为最大轮数,最大轮数的更新实际是一个dp迭代的过程

如果当前元素>=栈顶元素,且栈顶元素要在j轮后才能被删除,那么当前元素至少也要j轮才能删除,前提是当前元素左侧有比它大的数,在弹出操作结束后,如果栈不为空,说明当前数左侧有比它大的数,将之前记录的最大次数+1,否则说明不需要删除当前元素,将次数置0

可以看到,本题额外维护的信息更加复杂,堪比dp中的状态定义,需要反复揣摩.

```python
#2289(https://leetcode.cn/problems/steps-to-make-array-non-decreasing/)
max=lambda x,y:x if x>y else y
class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        ans,st=0,[]
        for x in nums:
            mx=0
            while st and x>=st[-1][0]:
                mx=max(mx,st.pop()[1])
            mx=mx+1 if st else 0
            ans=max(ans,mx)
            st.append((x,mx))
        return ans
```

